
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <title>Andrew Forney - UCLA CS</title>
    <link href="../../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../../../css/magic-bootstrap.css" rel="stylesheet" type="text/css">
    <link href="../../../css/main.css" rel="stylesheet" type="text/css">
    <script src="../../../js/lib/jquery-2.0.3.min.js"></script>
    <script src="../../../js/lib/bootstrap.min.js"></script>
    <script src="../../../js/lib/expanding.js"></script>
    <script src="../../../js/lib/chart.min.js"></script>
    <script src="../../../js/display/general/general-display.js"></script>
    <script src="week-4-display.js"></script>
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
  </head>
  
  <body data-spy="scroll" data-target="#scrollspy">
    
    <!-- BEGIN WRAP -->
    <div id="wrap">
      
      <!-- BEGIN NAVIGATION -->
      <nav class='navbar navbar-default' role='navigation'>
        <div class='nav-accent'></div>
        <div class='container'>
          <div class='row'>
            <div class='col-md-12'>
              <div class='navbar-header'>
                <button class='navbar-toggle' type='button' data-toggle='collapse' data-target='.navbar-main-collapse'>
                  <span class='sr-only'>Toggle Navigation</span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                </button>
                <a class='navbar-brand' href='/~forns/'>
                  <span id='brand-text'>
                    Andrew Forney
                  </span>
                </a>
              </div>
              
              <div id='nav-main' class='collapse navbar-collapse navbar-main-collapse'>
                <ul class='nav navbar-nav navbar-right'>
                  
                  <li>
                    <a href='/~forns/about.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-user'></span>
                      </div>
                      <p class='text-center'>About</p>
                    </a>
                  </li>
                  
                  <li class='active'>
                    <a href='/~forns/classes.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-book'></span>
                      </div>
                      <p class='text-center'>Classes</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/contact.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-comment'></span>
                      </div>
                      <p class='text-center'>Contact</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/publications.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-file'></span>
                      </div>
                      <p class='text-center'>Publications</p>
                    </a>
                  </li>
                  
                </ul>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <!-- END NAVIGATION -->
      
      <!-- BEGIN MAIN CONTENT -->
      <div id="main-content" class="container">
        <div class="row">
          
          <!-- BEGIN SCROLLSPY -->
          <div class='col-md-2 hidden-sm hidden-xs'>
            <div class="bs-sidebar hidden-print affix" role="complementary">
              <ul id='scrollspy' class="nav bs-sidenav">
              </ul>
            </div>
          </div>
          <!-- END SCROLLSPY -->
          
          <!-- BEGIN PRESENTATION CONTENT -->
          <div class='col-md-10 presentation-content' role='main'>
            
            <ol class="breadcrumb hidden-print">
              <li><a href="../../../classes.html">Classes</a></li>
              <li><a href="./cs-32.html">CS32</a></li>
              <li class="active">Week 7</li>
            </ol>
            
            
            <div id='announcements' class='scrollspy-element' scrollspy-title='Announcements'></div>
            <h1>Announcements</h1>
            <div>
              <p>TBD!</p>
            </div>
            <hr/>
            <br/>
            
            
            <div id='trees' class='scrollspy-element' scrollspy-title='Tree Basics'></div>
            <h1>Tree Basics</h1>
            <div>
              <p>Hey, remember doubly linked lists?</p>
              <p>Yeah me neither... well that's OK, here's a refresher:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-3/linkedLists-7.PNG' />
              </div>
              <p>Double linked lists consisted of a sequence of nodes with data elements and pointers to the previous and next node in the sequence.</p>
              <p>Indeed, the concept of a Node is something that Trees and Linked Lists have in common:</p>
              <p class='definition'>A <strong>Node</strong> is just an object that stores some data as well as a means of accessing other Nodes in the data structure.</p>
              <p>The &quot;means of accessing other Nodes&quot; from a Node in a Linked List was to traverse it via prev and next; for Trees, it's only slightly more complicated.</p>
              <p>Trees (in the general definition) possess Nodes with any number of &quot;children,&quot; which are pointers to the next Node in the Tree.</p>
              <p>Let's go over some definitions, see a Tree, and then run some code!</p>
              <p class='definition'>
                A <strong>Tree</strong> is yet another abstract data type consisting of data nodes arranged hierarchically, with a root node possessing some number of pointers (edges) to other children nodes,
                who in turn have their own children, etc.
              </p>
              <p class='definition'>There are two primary constraints for a Tree to be a... Tree: (1) no node's pointer (edge) points to the root, and (2) no two pointers point to the same node.</p>
              <p>To formalize some of those definitions:</p>
              <p class='definition'>The <strong>root</strong> of a tree is a single node that has no inbound edges.</p>
              <p class='definition'>A <strong>leaf</strong> node is one that has no outbound edges.</p>
              <p class='definition'>An <strong>internal node</strong> has both inbound and outbound edges.</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-8/trees-0.PNG' />
              </div>
              <br/>
              <p>A tree can have duplicate values in its data nodes.</p>
              <p>There are also a variety of relationships we can define between nodes:</p>
              <p class='definition'>An edge extends from a <strong>parent</strong> to a <strong>child</strong> with the arrow pointing to the child.</p>
              <p class='definition'>An <strong>path</strong> is any set of connected, directed edges.</p>
              <p class='definition'>A <strong>descendant</strong> of a node A is any node B with a directed path from A to B.</p>
              <p class='definition'>An <strong>ancestor</strong> of a node B is any node A with a directed path from A to B.</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-8/trees-1.PNG' />
              </div>
              <br/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-8/trees-2.PNG' />
              </div>
              <br/>
              <p class='definition'>The <strong>depth</strong> of a node is equal to the number of edges along the path that separate it and the root.</p>
              <p class='definition'>The <strong>tree-depth</strong> a given tree is equal to maximum depth of any node in the tree.</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-8/trees-3.PNG' />
              </div>
              <br/>
              <p>Well, those are the tree basics! Let's look at some code now...</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='treeAlgos' class='scrollspy-element' scrollspy-title='Tree Algorithms'></div>
            <h1>Tree Algorithms</h1>
            <div>
              <p>I hope you liked recursion because trees were built for it! (or from it? any who...)</p>
              <p>Let's start off with how we might construct a Node class:</p>
<pre class='prettyprint'>
  struct TreeNode {
      int data;
      TreeNode(int d) {data = d;}
      void addChild (TreeNode* c) {
          this-&gt;children.push_back(c);
      }
      vector&lt;TreeNode*&gt; children;
  };
</pre>
              <p>Here, we have our TreeNode with an int data member and then an STL vector with TreeNode pointers to all of that TreeNode's children.</p>
              <p>Let's reformat our tree from before with numerical values.</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-8/trees-4.PNG' />
              </div>
              <br/>
              <p>Now, let's say I wanted to create this tree using my new TreeNode class... since my numbers are conveniently in sequence, I can make a vector with them and then create the edges!</p>
<pre class='prettyprint'>
  int main () {
      vector&lt;TreeNode&gt; tree;
      int nodes = 13;
  
      // Create the TreeNodes in the tree
      for (int i = 0; i &lt; 13; i++) {
          tree.push_back(TreeNode(i));
      }
  
      // Connect the nodes with edges!
      // (obviously there's a better way to do
      // this that we'll discuss next time)
      // [!] Left branch
      tree[0].addChild(&amp;tree[7]);
      tree[7].addChild(&amp;tree[2]);
      tree[7].addChild(&amp;tree[10]);
      tree[10].addChild(&amp;tree[5]);
      tree[5].addChild(&amp;tree[4]);
  
      // [!] Middle branch
      tree[0].addChild(&amp;tree[6]);
      tree[6].addChild(&amp;tree[3]);
      tree[3].addChild(&amp;tree[8]);
      tree[3].addChild(&amp;tree[11]);
  
      // [!] Right branch
      tree[0].addChild(&amp;tree[12]);
      tree[12].addChild(&amp;tree[1]);
      tree[1].addChild(&amp;tree[9]);
  
      // ...
  }
</pre>
              <br/>
              <p>Now, before we dive head-first into Tree algorithms, we should always be on the lookout for these 4 test cases:</p>
              <ul class='indent-1'>
                <li><p>Does my algorithm work (read: not break) for an input nullptr?</p></li>
                <li><p>Does my algorithm work for an input root node?</p></li>
                <li><p>Does my algorithm work for an input interior node?</p></li>
                <li><p>Does my algorithm work for an input leaf node?</p></li>
              </ul>
              <p>Let's start off light with the following problem... which might look a little familiar:</p>
<pre class='prettyprint'>
  // Returns the maximum data node value in the
  // tree; expect no input nullptr
  int maxInTree (TreeNode* n) {
      // Set the current max to the input node's
      // data member
      int currentMax = n-&gt;data;
  
      // Find the max of each child's subtree
      for (int i = 0; i &lt; n-&gt;children.size(); i++) {
          // Set currentMax equal to the max of
          // child i's subtree
          currentMax = max(currentMax, maxInTree(n-&gt;children[i]));
      }
      return currentMax;
  }
</pre>
              <br/>
              <p>Not too bad... let's try one ourselves:</p>
              <p class='example'>Modify your maxInTree function to implement treeDepth, a function that determines the tree depth of the input tree (TreeNode pointer).</p>
<pre class='prettyprint'>
  int treeDepth (TreeNode* n) {
      int currentMax = 0;
      for (int i = 0; i &lt; n-&gt;children.size(); i++) {
          currentMax = ??? ;
      }
      return currentMax;
  }
</pre>
              <br/>
              <p class='example'>Implement the nodesAtLevel function, which returns the number of nodes located at the depth specified.</p>
<pre class='prettyprint'>
  int nodesAtLevel (TreeNode* n, int level) {
      // Base case! Return when...
      if ( ??? ) {
          return ???;
      }
  
      // Iterate through every child
      int nodes = 0;
      for (int i = 0; i &lt; n-&gt;children.size(); i++) {
          // [!] Add the number of nodes at the next level
          // if that's our target level! (hint: don't
          // need to use a conditional due to our base case)
          nodes += ???;
      }
      return nodes;
  }
</pre>
              <br/>
              <p>Cool! How about a question to round things off?</p>
              <p class='question' name='trees-q0'>Are all doubly linked lists also trees?</p>
              <p class='answer' name='trees-q0'>No! Linked lists allow for the possibility of cycles.</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='naryTrees' class='scrollspy-element' scrollspy-title='N-ary Trees'></div>
            <h1>N-ary Trees</h1>
            <div>
              <p>Whereas with the general definition of a tree allowed us to specify an arbitrary number of children for any node, there may be some benefits in restricting that number...</p>
              <p class='definition'>An <strong>n-ary tree</strong> is a tree in which each node can have at most n children.</p>
              <p>Thus, a binary tree has nodes with at most 2 children, a trinary tree has nodes with at most 3 children... etc.</p>
              <p>For the purposes of this discussion, we'll be examining binary trees.</p>
              <p>Hey! Here comes one now!</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-8/trees-5.PNG' />
              </div>
              <br/>
              <p>&quot;Hey... isn't that just the last example but with the right branch gone and a couple of numbers swi--&quot;</p>
              <p>It's 3:00am! Sue me!</p>
              <p>Now, the Node structure that we define for binary trees might look a tiny bit different, just by convention because we like to define &quot;left&quot; and &quot;right&quot; children.</p>
<pre class='prettyprint'>
  struct BinTreeNode {
      int data;
      BinTreeNode* left;
      BinTreeNode* right;
      BinTreeNode(int d) {
          data = d;
          left = nullptr;
          right = nullptr;
      }
  };
</pre>
              <br/>
              <p>Again representing our example from above:</p>
<pre class='prettyprint'>
  int main () {
      vector&lt;BinTreeNode&gt; tree;
      int nodes = 10;
  
      // Create the TreeNodes in the tree
      for (int i = 0; i &lt; nodes; i++) {
          tree.push_back(BinTreeNode(i));
      }
  
      // Connect the nodes with edges!
      // (obviously there's a better way to do
      // this that we'll discuss next time)
      // [!] Left branch
      tree[0].left = &amp;tree[1];
      tree[1].left = &amp;tree[2];
      tree[1].right = &amp;tree[9];
      tree[9].left = &amp;tree[5];
      tree[5].right = &amp;tree[4];
  
      // [!] Right branch
      tree[0].right = &amp;tree[6];
      tree[6].left = &amp;tree[3];
      tree[3].left = &amp;tree[8];
      tree[3].right = &amp;tree[7];
  
      // ...
  }
</pre>
              <p>Let's look at some neat properties of binary trees.</p>
              
              <br/>
              <h3>Tree Traversal</h3>
              <p class='definition'>Tree traversal determines the order in which we visit each node in a tree, starting at some node (usually the root).</p>
              <p>Traversal strategies are defined recursively, in terms of the current node, its left child, and its right child.</p>
              <p>There are three primary traversal strategies under the heading of &quot;Depth first&quot; which we'll talk about later:</p>
              
              <br/>
              <h3>Pre-order Traversal</h3>
              <p>The preorder traversal strategy follows these steps:</p>
              <ol class='indent-1'>
                <li><p>Visit the current node (base case)</p></li>
                <li><p>Visit the left subtree (recursive case)</p></li>
                <li><p>Visit the right subtree (recursive case)</p></li>
              </ol>
              <p>The definition of &quot;visit&quot; will depend on your application. For the moment, let's consider our application to be simply to print out the data at each Node in a given order.</p>
<pre class='prettyprint'>
  // Prints the data in each node using
  // the preorder traversal strategy
  void preorderPrint (BinTreeNode* n) {
      if (n == nullptr) {return;}
      cout &lt;&lt; n-&gt;data &lt;&lt; endl;
      preorderPrint(n-&gt;left);
      preorderPrint(n-&gt;right);
  }
</pre>
              <p>Preorder traversal looks like this:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-8/trees-6.PNG' />
              </div>
              <p>So, here, preorder traversal prints out: 0, 1, 2, 9, 5, 4, 6, 3, 8, 7</p>
              
              <br/>
              <h3>Post-order Traversal</h3>
              <p>The postorder traversal strategy follows these steps:</p>
              <ol class='indent-1'>
                <li><p>Visit the left subtree (recursive case)</p></li>
                <li><p>Visit the right subtree (recursive case)</p></li>
                <li><p>Visit the current node (base case)</p></li>
              </ol>
              <p class='debug'>NOTE: This means, even though we might &quot;pass through&quot; a node, we don't print it until its left and right subtrees have been processed!</p>
              <p>Here is the postorderPrint function:</p>
<pre class='prettyprint'>
  void postorderPrint (BinTreeNode* n) {
      if (n == nullptr) {return;}
      postorderPrint(n-&gt;left);
      postorderPrint(n-&gt;right);
      cout &lt;&lt; n-&gt;data &lt;&lt; endl;
  }
</pre>
              <p>So, what will the postorder traversal of our tree print out?</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-8/trees-5.PNG' />
              </div>
              <br/>
              <p class='question' name='trees-q1'>The postorder traversal prints...</p>
              <p class='answer' name='trees-q1'>2, 4, 5, 9, 1, 8, 7, 3, 6, 0</p>
              
              <br/>
              <h3>In-order Traversal</h3>
              <p>The inorder traversal strategy follows these steps:</p>
              <ol class='indent-1'>
                <li><p>Visit the left subtree (recursive case)</p></li>
                <li><p>Visit the current node (base case)</p></li>
                <li><p>Visit the right subtree (recursive case)</p></li>
              </ol>
              <p>For completion, here's that in code form:</p>
<pre class='prettyprint'>
  void inorderPrint (BinTreeNode* n) {
      if (n == nullptr) {return;}
      inorderPrint(n-&gt;left);
      cout &lt;&lt; n-&gt;data &lt;&lt; endl;
      inorderPrint(n-&gt;right);
  }
</pre>
              <br/>
              <h3>Applications for Binary Trees</h3>
              <p>We've already discussed one of the most prevalent applications for binary trees: binary search.</p>
              <p class='definition'>
                A <strong>binary search tree</strong> is a binary tree in which all elements in the left subtree of a node are less than the data member of that node, and all elements of the right
                subtree are greater than the data member of that node.
              </p>
              <p>Some other constraints for binary search trees is that there must be no duplicate nodes, and the left and right subtrees of each node must also be a binary search tree.</p>
              <p>Let's revise our ongoing example:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-8/trees-7.PNG' />
              </div>
              <p>We observe that, for each node, the left subtree contains data elements strictly less than the data element of the subtree root, and vice versa for the right subtrees.</p>
              <p>Now, binary search becomes a trivial algorithm:</p>
<pre class='prettyprint'>
  bool binarySearch (BinTreeNode* n, int query) {
      if (n == nullptr) {return false;}
      if (n-&gt;data == query) {return true;}
      else if (query &lt; n-&gt;data) {
          return binarySearch(n-&gt;left, query);
      } else {
        return binarySearch(n-&gt;right, query);
      }
  }
</pre>
            </div>
            <hr/>
            
            
            <br/>
            <div id='practice' class='scrollspy-element' scrollspy-title='Practice'></div>
            <h1>Practice Problems</h1>
            <div>
              <p class='example'>Provide two binary trees that could elicit the preorder traversal print out: <code class='prettyprint'>5, 3, 1, 2, 0</code></p>
              <p class='question' name='practice-q0'>Is it possible for a binary search tree to have the postorder traversal print out of: <code class='prettyprint'>12, 18, 14, 21, 20, 17</code></p>
              <p class='answer' name='practice-q0'>
                No! The 18 wedged between the 12 and 14 implies that a number greater than the root (which we know must be 17 because it was printed last) existed on the side intended to be less than
                the root.
              </p>
            </div>
            <hr/>
            <br/>
            
            
            <div id='bstAlgorithms' class='scrollspy-element' scrollspy-title='BST Algorithms'></div>
            <h1>Binary Search Tree Algorithms</h1>
            <div>
              <p>Suppose we wish to create a binary search tree class... recall that BSTs must adhere to two principle restrictions:</p>
              <ul class='indent-1'>
                <li><p>No node may have more than 2 children</p></li>
                <li><p>All nodes to the left of a given node must be less than that node, and all nodes to the right of a given node must be less than (or equal) to it</p></li>
              </ul>
              <br/>
              <p>Here's a simple binary search tree class skeleton:</p>
              <br/>
<pre class='prettyprint'>
  struct BST {
      // BSTNode struct internal
      // to the BST
      struct BSTNode {
          int data;
          BSTNode* left;
          BSTNode* right;
          BSTNode(int d) {
              data = d;
              left = nullptr;
              right = nullptr;
          }
      };
      
      // Root just points to a single
      // BSTNode
      BSTNode* root;
      
      BST() {
          root = nullptr;
      }
      ~BST() {}; // TODO!
      bool find (int query, BSTNode* n = root); // TODO!
      void insert (int i); // TODO!
      void clear(BSTNode* subtree); // TODO!
  };
</pre>
              <br/>
              
              <p>Let's start using this simple BST class by fleshing out some of its member functions!</p>
              <p>Now, the insertion algorithm isn't too bad... let's try to code an iterative version.</p>
              <br/>
              <p class='example'>Complete the BST insert function started below:</p>
<pre class='prettyprint'>
  // Creates a new node with the given data member
  // in the BST
  void BST::insert (int data) {
      BSTNode* b = root;
      
      // Base case: tree is empty
      if ( ??? ) {
          ???
          return;
      }
      
      // Otherwise, find its proper position
      while (true) {
          // Case: Data is less than current node
          if (data &lt; b-&gt;data) {
              // If there's already a node left...
              if (b-&gt;left) {
                  // Then continue down the tree
                  ???
              
              // Otherwise, no node to left, so insert:
              } else {
                  ???
                  return;
              }
              
          // Case: Data is greater than / equal to node
          } else {
              if (b-&gt;right) {
                  ???
              } else {
                  ???
                  return;
              }
          }
      }
  }
</pre>
              <br/>
              <p>Cool, nice and simple... we can confirm that everything's working with the following main function:</p>
              <br/>
<pre class='prettyprint'>
  int main () {
      BST bs; // hehe... bs
      bs.insert(5);
      bs.insert(4);
      bs.insert(6);
      bs.insert(3);
      
      cout &lt;&lt; bs.root-&gt;data &lt;&lt; endl;             // 5
      cout &lt;&lt; bs.root-&gt;left-&gt;data &lt;&lt; endl;       // 4
      cout &lt;&lt; bs.root-&gt;right-&gt;data &lt;&lt; endl;      // 6
      cout &lt;&lt; bs.root-&gt;left-&gt;left-&gt;data &lt;&lt; endl; // 3
  }
</pre>
              <p class='question' name='bst-insert'>What is the time complexity of this insertion operation?</p>
              <p class='answer' name='bst-insert'>Finding the location to insert takes log(n) time and then the actual insertion is constant, giving us a grand total of log(n).</p>
              <br/>
              
              <p>Now that we have a taste for building our binary search trees, we see that implementing the actual search operation is pretty simple!</p>
              <p>We'll do things recursively this time for extra practice.</p>
              <p class='example'>Implement the BST's find member function, which takes in a query int to find in the tree, and returns true iff that value exists somewhere in the tree.</p>
<pre class='prettyprint'>
  bool BST::find (int query, BSTNode* n) {
      // If our given node pointer is nullptr, return
      // false -- we're out of tree to examine!
      if (n == nullptr) {return false;}
      
      // [!] Otherwise, if the current node's data is our
      // query, we're done!
      if ( ??? ) { ??? }
      
      // [!] If it's not, we have to determine whether we
      // want to continue by searching the left or right
      // subtree:
      else if ( ??? ) {
          return ???;
      } else {
          return ???;
      }
  }
</pre>
              <p class='question' name='bstq-1'>On average, What is the time complexity of this search algorithm? (we'll think about worst-case later)</p>
              <p class='answer' name='bstq-1'>O(log(n)), since at every step, we reduce the number of possible locations for the query to exist by about 1/2.</p>
              <br/>
              
              <p>Great! So we've got our BSTs insertable and searchable, but what about cleanup?</p>
              <p class='example'>Taking a step back for some review... remind me what postorder traversal is again? What's the postorder traversal of this tree?</p>
              <div class="text-center fit-pres">
                <img src="../../../assets/images/winter-2014/cs-32/week-8/trees-7.PNG">
              </div>
              <p class='question' name='bst-qdest'>Interesting property about postorder traversal... what happens when I remove each Node found in postorder traversal, in the order in which I visit them?</p>
              <p class='answer' name='bst-qdest'>We remove each node's children before removing it! Perfect for destroying our tree nodes when we need to clean up.</p>
              <br/>
              
              <p>So, here's a good practice problem... how might we code the destructor of our BST?</p>
              <p class='example'>Complete the destructor helper-function code skeleton for our BST class below:</p>
              <br/>
<pre class='prettyprint'>
  // Clears all nodes, making sure to
  // deallocate appropriately
  void BST::clear(BSTNode* subtree) {
      // Base case: reached an ending
      if ( ??? ) {
          return;
      }
      
      // Otherwise, traverse and delete:
      ???
      ???
      
      // [!] Printout for example before
      // deleting:
      cout &lt;&lt; subtree-&gt;data &lt;&lt; endl;
      ???
  }
  
  // Destructor properly calls clear
  BST::~BST() {
      clear(root);
  }
</pre>
              <p class='question' name='bst-destruction'>What is the time complexity of this destruction operation?</p>
              <p class='answer' name='bst-destruction'>O(n), since we visit every element once.</p>
              <br/>
              
              <h3>Binary Search Tree Node Deletion</h3>
              <p>We'll discuss how to perform arbitrary node deletion here, but won't code it (left as an exercise? yada yada).</p>
              <p>The steps for deletion are simple.</p>
              <br/>
              <div class='definition'><p>Suppose I wish to remove node N from a BST. This removal breaks down into several cases.</p>
                <ul class='indent-1'>
                  <li><p><strong>Node N is a leaf:</strong> remove N, and update the parent's pointer to it to nullptr.</p></li>
                  <li><p><strong>Node N has 1 child:</strong> update the parent's pointer to N to now refer to N's sole child, then remove N.</p></li>
                  <li><p><strong>Node N has 2 children:</strong> replace N with the smallest element of N's right subtree (call this S), remove N, then recursively call erase on S.</p></li>
                </ul>
              </div>
              <br/>
              <p>We can try this operation on our favorite example BST:</p>
              <div class="text-center fit-pres">
                <img src="../../../assets/images/winter-2014/cs-32/week-8/trees-7.PNG">
              </div>
              <p class='example'>Delete 12 in the above BST.</p>
              <p class='example'>Delete 11 in the above BST.</p>
              <p class='example'>Delete 21 in the above BST.</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='treeBalancing' class='scrollspy-element' scrollspy-title='Tree Balancing'></div>
            <h1>Balancing Binary Search Trees</h1>
            <div>
              <p class='question' name='btree-q0'>Say I'm inserting ints into a binary search tree. What property of this input list of ints will cause insertion to take O(n) time?</p>
              <p class='answer' name='btree-q0'>When the insertions are done one at a time and arrive in sorted order.</p>
              <p class='question' name='btree-q00'>Suppose I do create a binary search tree using the above detrimental insertion ordering. What efficiency guarantee on what operations does my BST lose?</p>
              <p class='answer' name='btree-q00'>I lose log(n) performance of search and insertion!</p>
              <p class='definition'>You can test out insertion into a binary tree <a href='http://www.cs.jhu.edu/~goodrich/dsa/trees/btree.html' target='_blank'>here (click me)</a></p>
              <br/>

              <p>Well, as it turned out, that worst case insertion was problematic... and the more linear, and less tree-like binary search trees became, the less efficient their search became too!</p>
              <p>So the eggheads of yore considered making an algorithm that would keep the tree balanced such that any insertion won't make the tree become too linear.</p>
              <br/>
              <p class='definition'><strong>Balancing</strong> binary search trees is an operation that prevents them from becoming too linear, thus securing the performance guarantees we expect in a BST.</p>
              <p>There are a variety of different ways to keep trees balanced and maintain the log(n) search guarantee for binary search trees; we'll examine a couple now.</p>
              <br/>
              
              <h3>AVL Trees</h3>
              <p class='definition'>AVL trees have 1 property in addition to those of binary search trees: the heights (depths) of any two of a given node's subtrees must differ by *at most* 1.</p>
              <p>This enforced property makes sure that the depth of any subtree never becomes too linear, which would degrade the efficiency of search and further insertions.</p>
              <p>This balancing act takes O(log(n)) time, which means that, upon insertion of any new value, we get O(log(n) + log(n)) = O(log(n)) time; a greater overhead, but same complexity class.</p>
              <br/>
              <ol class='indent-1'>
                <li><p>Firstly, we keep track of a &quot;balance factor&quot; at each node which is equal to: <code class='prettyprint'>balance = height(left_subtree) - height(right_subtree)</code></p></li>
                <li><p>A tree is out of balance if its balance factor is greater than or equal to 2, or less than or equal to -2.</p></li>
                <li><p>If a tree is out of balance, then we use the following balancing algorithm:</p></li>
              </ol>
<pre class='prettyprint'>
  // Code skeleton for C++, edited from Wikipedia :)
  if (balance_factor(L) == 2) { // The left subtree
      Node* P = left_child(L);
      if (balance_factor(P) == -1) { // The "Left Right Case"
          rotate_left(P); // Reduce to "Left Left Case"
      }
      // The Left Left Case
      rotate_right(L);
      
  } else { // balance_factor(L) == -2, the right subtree
      Node* P=right_child(L);
      if (balance_factor(P) == 1) { //The "Right Left Case"
         rotate_right(P); // Reduce to "Right Right Case"
      }
      // The Right Right Case
      rotate_left(L);
  }
</pre>
              <br/>
              <p>So what does it mean to &quot;rotate&quot; a tree, you might ask?</p>
              <p class='definition'>A rotation promotes a child node to the parent, and demotes the parent to a child node depending on the direction of the rotation. Subtree structures are maintained.</p>
              <div class='text-center fit-pres'>
                <a href='http://en.wikipedia.org/wiki/AVL_tree' target='_blank'>
                  <img src='../../../assets/images/winter-2014/cs-32/week-9/tree-rotation.png' />
                  <br/>
                  <small>(credit to Wiki for image)</small>
                </a>
              </div>
              <br/>
              <p>Above, a right / clockwise rotation would start at the right image and finish with the left image.</p>
              <p>Similarly, a left / counter-clockwise rotation would start at the left image and finish with the right image.</p>
              <p>Notice that the subtree structures are maintained with each rotation.</p>
              <div class='question' name='rotation-q0'><p>What would a left rotation of the 10 node look like in the following tree?</p>
                <div class='text-center fit-pres'>
                  <img src='../../../assets/images/winter-2014/cs-32/week-9/tree-rotation-1.png' />
                </div>
              </div>
              <div class='answer' name='rotation-q0'>
                <div class='text-center fit-pres'>
                  <img src='../../../assets/images/winter-2014/cs-32/week-9/tree-rotation-2.png' />
                </div>
              </div>
              <br/>
              <p>Now that we have the basics of rotation down, let's look at an example inserting into an AVL tree:</p>
              <br/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/summer-2014/cs-32/week-6/av-ex-0.png' />
              </div>
              <br/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/summer-2014/cs-32/week-6/av-ex-1.png' />
              </div>
              <br/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/summer-2014/cs-32/week-6/av-ex-2.png' />
              </div>
              <br/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/summer-2014/cs-32/week-6/av-ex-3.png' />
              </div>
              <br/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/summer-2014/cs-32/week-6/av-ex-4.png' />
              </div>
              <br/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/summer-2014/cs-32/week-6/av-ex-5.png' />
              </div>
              <br/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/summer-2014/cs-32/week-6/av-ex-6.png' />
              </div>
              <br/>
              <p>Neat!</p>
              <p>So remember: AVL trees balance subtree heights, not necessarily just the number of nodes per subtree!</p>
              <br/>
              <p class='definition'>Let's examine a visualization <a href='http://www.cs.jhu.edu/~goodrich/dsa/trees/avltree.html' target='_blank'>here (click me)</a></p>
              
              <br/>
              <h3>Red-Black Trees</h3>
              <p>
                So, the one problem with AVL trees is that with a lot of insertions, you'll have to keep performing the balancing overhead any time a branch becomes 2 depths or more greater than a parent.
              </p>
              <p>
                Red-Black Trees said, &quot;Hey, let's not do all of this rebalancing nonsense all the time; everything's chill until the path from the root to the farthest leaf is no more than twice
                the distance from the root to the closest leaf.&quot;
              </p>
              <p>So, without diving deep into how it rebalances when this distance is exceeded, let's just look at some properties of red-black trees lifted from wikipedia:</p>
              <ul class='indent-1'>
                <li><p>A node is &quot;painted&quot; either red or black</p></li>
                <li><p>The root is black</p></li>
                <li><p>Every red node must have two black child nodes</p></li>
                <li><p>Every path from a given node to any of its descendant leaves contains the same number of black nodes.</p></li>
              </ul>
              <p>What we end up with is a binary search tree that still ensures O(log(n)) search without the need to so frequently rebalance.</p>
              <p class='definition'>Let's examine a visualization <a href='http://www.ece.uc.edu/~franco/C321/html/RedBlack/redblack.html' target='_blank'>here (click me)</a></p>
            </div>
            <hr/>
              
            
            <br/>
            <div id='hash' class='scrollspy-element' scrollspy-title='Hash Tables'></div>
            <h1>Hash Tables</h1>
            <div>
              <p>If you're me and you're looking for something at a supermarket, you'll probably wander aimlessly, looking at each row until you find it.</p>
              <p>Yet, if you ask a store employee, you'll find that, for the most part, they'll know exactly which row your item is in without having to look!</p>
              <p>(I, of course, never ask because male ego, etc.)</p>
              <p>Now to bring the analogy home, it'd be nice if we had some &quot;store employee&quot; with our data structure collections that could tell tell us where to look for a query.</p>
              <p class='definition'>
                A <strong>hash table</strong> provides us with a means of storing data structures into certain buckets such that we can consult a hash function to determine where a particular item
                should go (for insertion) or where it might already live (for search).
              </p>
              <p class='definition'>For a given value to store or a query to a hash table, the <strong>hash function</strong> tells us which bucket to store it in / look in.</p>
              <br/>
              <p>So, to unpack those definitions a bit:</p>
              <ul class='indent-1'>
                <li><p>The hash table is like the grocery store in our analogy.</p></li>
                <li><p>The hash function is like the employee that we ask which aisle a particular item is in that we're looking for.</p></li>
                <li><p>The hash buckets are like the aisles of the grocery store.</p></li>
              </ul>
              <p>So why is this useful?</p>
              <p>
                Well, if we had about 1000 items we needed to store, and 1000 buckets in which to store them, then assuming we chose a good hash function to evenly divide up the items into buckets, we
                could perform insertion and search in near constant time! O(1), wow!
              </p>
              <p>
                This is because we reduce the possible set of matches down to only those contents of a particular bucket, which is, if the items are uniformly distributed, going to be very small
                compared to the original collection.
              </p>
              <p>Constant time is the gold standard of data structures and you're saying it's possible?! Let us learn of these wonderous devices by building a simple one of our own.</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/hash-0.png' />
              </div>
              
              <br/>
              <h3>The Hash Table</h3>
              <p>Let's begin by designing our hash table.</p>
              <p class='definition'>A hash table needs buckets that are accessible by index.</p>
              <br/>
              <p class='question' name='hash-q0'>Why do our hash buckets need to be accessible by index, and what data structure what you suggest to use for our buckets?</p>
              <p class='answer' name='hash-q0'>
                If we want constant time lookup and search, we'll need random access or else we'd have to traverse some number of Node-like objects to reach our goal bucket. Also, it's convenient
                for a hash function to only hash items to integer ids. So, for the purposes of this example, we'll use a vector.
              </p>
              <br/>
              <p>OK, let's define our HashTable class below:</p>
<pre class='prettyprint'>
  template &lt;typename T&gt;
  class HashTable {
      private:
          // LOL "BUCKET LIST"
          vector&lt;list&lt;T&gt;&gt; buckets;
  };
</pre>
              <br/>
              <p>Well that's dull so far...</p>
              <p>Note we use (for this example) a vector for the buckets (enable random access) and lists for the individual bucket contents.</p>
              <p>We'll template our HashTable so we can store different stuff.</p>
              <p>Now, for the constructor, how many buckets do we want to start it off with?</p>
              <p class='question' name='hash-q1'>What is the tradeoff for having more or fewer buckets in our hash table?</p>
              <p class='answer' name='hash-q1'>
                More buckets means that fewer items will be in each bucket (if our hash function performs a uniform distribution of the items) at the cost of having to take up more space in memory.
              </p>
              <br/>
              <p>So, let's start off at, say, 1,000 buckets.</p>
<pre class='prettyprint'>
  template &lt;typename T&gt;
  class HashTable {
      private:
          int MAX_BUCKETS;
          vector&lt;list&lt;T&gt;&gt; buckets;
      public:
          HashTable (): MAX_BUCKETS(1000) {
              // Start off the buckets with MAX_BUCKETS
              buckets.resize(MAX_BUCKETS);
          }
  };
</pre>
              <br/>
              <p>Alright, the stage is set... let's talk about hash functions.</p>
              
              <br/>
              <h3>Hash Functions</h3>
              <p>Hash functions act as our &quot;oracles&quot; that tell us which bucket a particular item should go in.</p>
              <p>They receive as input whatever item we're trying to store or lookup and output an int index somewhere between [0, b), where b is the number of buckets.</p>
              <p>There are some properties of hash functions we need to satisfy...</p>
              <p class='definition'>Hash functions need to be fast!</p>
              <br/>
              <p>
                If our hash function crawls wikipedia for articles on obscure topics, converts every character in those articles to its character code equivalent, adds them, and then mods them by the biggest
                prime number that will fit things neatly into our buckets... we're probably gonna have a bad time (literally).
              </p>
              <p>So, we want something that's simple, quick, and satisfies this other property:</p>
              <p class='definition'>Hash functions need to evenly distribute our items into buckets.</p>
              <br/>
              <p>If our buckets start to hold too many items, then the hash table will be pretty useless... we'll just have a linear search internal to our lists!</p>
              <p>So, we need to determine a way to, pretty uniquely, determine what item goes into what bucket!</p>
              <p class='definition'>When a hash function maps inputs to the same bucket, we call that a <strong>collision</strong>.</p>
              <br/>
              <p>Generally, we want to avoid collisions because they hurt.</p>
              <p>But seriously, the more collisions we have, the more our complexity suffers because it means we have to find values within our lists.</p>
              <p>A last property our hash functions should have:</p>
              <p class='definition'>
                Hash functions should be <strong>deterministic</strong>, meaning that if value A maps to bucket B in one call to our hash function, then it should map to bucket B in future calls as well.
              </p>
              <br/>
              <p>Keeping this in mind, let's propose a couple of hash functions for our HashTable.</p>
              <br/>
              <p class='example'>Judge whether or not the following is a good hash function:</p>
<pre class='prettyprint'>
  unsigned int hash (int toHash) {
      return toHash % 2;
  }
</pre>
              <br/>
              <p class='example'>Judge whether or not the following is a good hash function:</p>
<pre class='prettyprint'>
  unsigned int hash (string toHash) {
      unsigned int result = 0;
      for (int i = 0; i &lt; toHash.length(); i++) {
          result += toHash[i];
      }
      return result % rand();
  }
</pre>
              <br/>
              <p class='example'>Judge whether or not the following is a good hash function:</p>
<pre class='prettyprint'>
  unsigned int hash (string toHash) {
      unsigned int result = 0;
      for (int i = 0; i &lt; toHash.length(); i++) {
          result = result * 101 + toHash[i];
      }
      return result % MAX_BUCKETS;
  }
</pre>
              <br/>
              <p>This last one isn't bad; it's deterministic, simple, and stays in the range of our max number of buckets.</p>
              <p class='question' name='hash-q1-1'>Why did I choose to multiply by 101? What is special about the number 101 (or numbers like it)?</p>
              <p class='answer' name='hash-q1-1'>
                It's prime! When we multiply by a prime number, the chances of getting a unique result are higher because of the lack of factors. This helps us distribute keys to our buckets.
              </p>
              <br/>
              <p>Alright, so let's add that to our HashTable!</p>
              <p>We'll make it private because for this example, only our HashTable functions will care about the hash.</p>
<pre class='prettyprint'>
  template &lt;typename T&gt;
  class HashTable {
      private:
          int MAX_BUCKETS;
          vector&lt;list&lt;T&gt;&gt; buckets;
  
          // NOTE: If we want to be able to handle other
          // template types than strings for T, we'd need
          // other, more generalized hash functions...
          unsigned int hash (string toHash) {
              unsigned int result = 0;
              for (int i = 0; i &lt; toHash.length(); i++) {
                  result = result * 101 + toHash[i];
              }
              return result % MAX_BUCKETS;
          }
  
      public:
          HashTable (): MAX_BUCKETS(1000) {
              // Start off the buckets with MAX_BUCKETS
              buckets.resize(MAX_BUCKETS);
          }
  };
</pre>
              <br/>
              <p>It's coming along!</p>
              <p>Let's examine inserting items into our HashTable.</p>
              
              <br/>
              <h3>HashTable Insertion</h3>
              <p>So now that we have our hash function and our buckets with their lists, let's define our insertion behavior.</p>
              <p class='example'>Complete the HashTable's insertion function below:</p>
<pre class='prettyprint'>
  void insert (T toInsert) {
    // [!] Push toInsert to the back of the list that the
    // hash function gives you from input toInsert
    buckets[ ??? ].push_back(toInsert);
  }
</pre>
              <br/>
              <p class='debug'>Warning! The above insert function is missing something? What is it?</p>
              <p>OK we'll deal with that in a moment...</p>
              <p>I'll provide you with a neat print function just to display some syntactic sugaring for a printout:</p>
<pre class='prettyprint'>
  void print () {
      for (int i = 0; i &lt; buckets.size(); i++) {
          list&lt;T&gt;::iterator it = buckets[i].begin();
          if (buckets[i].empty()) {
              continue;
          }
          cout &lt;&lt; "=== Bucket[ " &lt;&lt; i &lt;&lt; " ] ===" &lt;&lt; endl;
          while (it != buckets[i].end()) {
              cout &lt;&lt; *it++ &lt;&lt; endl;
          }
      }
  }
</pre>
              <br/>
              <p>OK, so now we have the following HashTable class and a nice little test script:</p>
<pre class='prettyprint'>
  template &lt;typename T&gt;
  class HashTable {
      private:
          int MAX_BUCKETS;
          vector&lt;list&lt;T&gt;&gt; buckets;
  
          unsigned int hash (string toHash) {
              unsigned int result = 0;
              for (int i = 0; i &lt; toHash.length(); i++) {
                  result = result * 101 + toHash[i];
              }
              return result % MAX_BUCKETS;
          }
  
      public:
          HashTable (): MAX_BUCKETS(1000) {
              buckets.resize(MAX_BUCKETS);
          }
          void insert (T toInsert) {
              buckets[HashTable::hash(toInsert)].push_back(toInsert);
          }
          void print () {
              for (int i = 0; i &lt; buckets.size(); i++) {
                  typename list&lt;T&gt;::iterator it = buckets[i].begin();
                  if (buckets[i].empty()) {
                      continue;
                  }
                  cout &lt;&lt; "=== Bucket[ " &lt;&lt; i &lt;&lt; " ] ===" &lt;&lt; endl;
                  while (it != buckets[i].end()) {
                      cout &lt;&lt; *it++ &lt;&lt; endl;
                  }
              }
          }
  };
  
  int main () {
      HashTable&lt;string&gt; hashy;
      hashy.insert("To");
      hashy.insert("Hash");
      hashy.insert("Or");
      hashy.insert("Not");
      hashy.insert("To");
      hashy.insert("Hash");
      hashy.print();
  }
</pre>
              <br/>
              <p>
                Now, the issue with our insert is that it currently allows for duplicate keys... we can't have this behavior in a hash table because it would be ambiguous to talk about a key (which is
                meant to be unique) when there are multiple instances of that key.
              </p>
              <p>Let's implement our hasKey function below:</p>
              <p class='debug'>
                NOTE: If we were really designing a HashTable class, we'd probably want to implement a HashTable iterator, but since this is an intro example, we'll reduce the find functionality
                to just a boolean return function.
              </p>
<pre class='prettyprint'>
  bool hasKey (T query) {
      // Store a pointer to the bucket's list
      list&lt;T&gt;* lPtr = &amp;buckets[hash(query)];
      // Start an iterator at it's beginning
      list&lt;T&gt;::iterator it = lPtr-&gt;begin();
      // Search linearly for the query item
      while (it != lPtr-&gt;end()) {
          if (*it == query) {
              break;
          }
          it++;
      }
      // Return whether the iterator found a
      // match or not
      return it != lPtr-&gt;end();
  }
</pre>
              <p>Now, we can fix our insertion function to not add duplicates!</p>
<pre class='prettyprint'>
  void insert (T toInsert) {
      if (hasKey(toInsert)) {
          return;
      }
      buckets[HashTable::hash(toInsert)].push_back(toInsert);
  }
</pre>
              <p>Now if we run our previous test main function, we see that duplicate keys are not added, just as we'd like. Cool!</p>
              
              <br/>
              <h3>Hash Table Complexities</h3>
              <p>So it might be clear how we're able to find a bucket in constant time (random access of vector + hash function), but why is searching the bucket list considered average case constant?</p>
              <p>Well let's look at a certain property of hash tables:</p>
              <p class='definition'>The <strong>load factor</strong> of a hash table is the ratio of the number of items stored in total divided by the number of buckets.</p>
              <br/>
              <p>So, the lower the load factor, and assuming our hash function is doing a good job of evenly distributing keys across buckets, the faster our lookup in each list is going to be!</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/hash-1.png' />
              </div>
              <hr/>
              <p>We see that a hash table with a ton of items and few buckets will have a large load factor and nearing linear lookup and insertion time.</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/hash-2.png' />
              </div>
              <br/>
              
              <p>Solutions to resolving collisions depend on how we've modeled our Hashtables.</p>
              <p>In the previous hash table examples, we've seen only one strategy of storing our keys, but there are two main divisions for how we might collect them.</p>
              <ul class='indent-1'>
                <li><p><strong>"Closed" Hashtables:</strong> keys are stored in separate containers for each bucket. This is the type of Hashtable we implemented above, since we have lists in
                  each bucket location.</p></li>
                <li><p><strong>"Open" Hashtables:</strong> keys are stored one-per-bucket, i.e., in the buckets themselves. When we wish to insert a new item in this schema, we first consult the
                  hash function and then proceed to the first open bucket.</p></li>
              </ul>
              <br/>
              
              <p class='question' name='hashtypes-0'>What are some benefits / drawbacks of Closed Hashtables?</p>
              <p class='answer' name='hashtypes-0'><strong>Benefits:</strong> good for storing large objects, robust for growth. <strong>Drawbacks:</strong> large overhead for storing small objects,
                traversing linked lists inefficient, and allocating new LL nodes expensive.</p>
              <p class='question' name='hashtypes-1'>What are some benefits / drawbacks of Open Hashtables?</p>
              <p class='answer' name='hashtypes-1'><strong>Benefits:</strong> good for storing small objects, fast cache access, no need for allocating new nodes in LL buckets, smaller space footprint.
                <strong>Drawbacks:</strong> bad for storing large objects, more stringent requirements on hash function, less adaptable to growth.</p>
              
              <p>So, how do we avoid poor performance when our number of collisions gets too high?</p>
              <p>One solution that modern hash tables use: create more buckets whenever the load factor gets too high!</p>
              <p>Assuming that our hash function is uniformly distributing keys, this puts a *constant upper bound* on the number of items in any given bucket list. Thus guaranteeing the O(1).</p>
              
              <br/>
              <h3>Hash Table Sorting</h3>
              <p>With binary search trees, obtaining a sorted list of the items was trivial: an inorder traversal...</p>
              <p>With hash tables, we don't have the same luxury of structure since our hash function threw keys all over the place.</p>
              <p class='definition'>With hash tables, our concern is less about sorting values than it is about quickly storing and looking them up...</p>
              <br/>
              <p>Just like STL lists don't have a find function because it's a rather wonky operation taking O(n), so is a sort operation somewhat auxiliary to the hash table purpose.</p>
              <p>So what's a viable work-around for implementing a hash table sort?</p>
              <p class='question' name='hash-q2'>Assume we have iterators for our hash tables... how might we use these to sort our keys?</p>
              <p class='answer' name='hash-q2'>
                You could, upon a sort function call, simply create some other data structure (like a BST) comprised of pointers to the values in the hash table, which could then give a nice
                ordering for the values currently in the hash table.
              </p>
              
              <br/>
              <h3>#include &lt;unordered_set&gt;</h3>
              <p>The STL version of a hash table is an unordered_set. You can use it in the following way:</p>
<pre class='prettyprint'>
  int main () {
      unordered_set&lt;int&gt; ui;
      
      // You can insert keys
      ui.insert(1);
      ui.insert(17);
      ui.insert(12);
      ui.insert(20);
  
      // You can define iterators and look for values
      unordered_set&lt;int&gt;::iterator it = ui.find(1);
  
      // [!] WARNING: Will the following necessarily print
      // out 1, 12, 17, 20 in order?
      it = ui.begin();
      while (it != ui.end()) {
          cout &lt;&lt; *it++ &lt;&lt; endl;
      }
  
      // You can even print out how many buckets it has!
      cout &lt;&lt; "Buckets: " &lt;&lt; ui.bucket_count() &lt;&lt; endl;
  
      // And the load factor!
      cout &lt;&lt; "Load factor: " &lt;&lt; ui.load_factor() &lt;&lt; endl;
  
      // And of course, clear it
      ui.clear();
  }
</pre>
              <br/>
              <p>So those are hash tables!</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='23trees' class='scrollspy-element' scrollspy-title='2-3 Trees'></div>
            <h1>2-3 Trees</h1>
            <div>
              <p>Because 1 tree wasn't enough!</p>
              <p>2-3 trees belong to a class of data structures called B-Trees:</p>
              <br/>
              <p class='definition'><strong>B-Trees</strong> are generalizations of binary search trees that, while accomplishing access, insertion, and deletion in logarithmic time, allow for nodes with 
                more than 2 children each.</p>
              <br/>
              <p>So why do we care about generalizations of binary search trees?</p>
              <p>As it turns out, we can improve somewhat on the constant of proportionality with our logarithmic time complexity of insertion, lookup, and other operations by saving some rebalancing.</p>
              <p>The chief properties of a 2-3 tree that allow us to do that are the following:</p>
              <br/>
              <div class='definition'>
                <p>A <strong>2-3 Tree</strong> possesses two types of nodes:</p>
                <br/>
                <ul class='indent-1'>
                  <li><p>A <strong>2-node</strong> contains 1 data element in its node, and has at most 2 children; nodes in its left subtree are less than it, and nodes in its right are greater than
                    (or equal to) it.</p></li>
                  <li><p>A <strong>3-node</strong> contains 2 data elements in its node (a left and a right value), and has at most 3 children; nodes in its left subtree are less than the left value,
                    nodes in its middle subtree are between the left and the right, and nodes in its right subtree are greater than (or equal to) the right value.</p></li>
                </ul>
              </div>
              <br/>
              <p>Here's an example of a 2-3 Tree and the types of nodes they contain:</p>
              <br/>
              <div class="text-center fit-pres">
                <img src="../../../assets/images/summer-2014/cs-32/week-6/2-3-tree.png">
              </div>
              
              <br/>
              <h3>Insertion</h3>
              <p>So how do we actually end up with a 2-3 tree? Well, the algorithm can be boiled down to the following pseudocode:</p>
              <br/>
<pre class='prettyprint'>
  // insert algorithm:
  
  if the tree is empty, insert a 2-Node with the value
  else, traverse the tree to find where the value goes
      once you find the node
          if that node is a 2-Node
              add the value to make it a 3-Node
          else
              promote the middle value to the parent
  
              
  // promote algorithm:
  
  if the parent is a 2-Node
      add promoted value as 2nd value, making it a 3-Node
      children placed according to relation to parent values
  if the parent is a 3-Node
      promote the middle value of those three (recursive call)
  if no parent
      promote the middle value to its own 2-Node
      split the remaining 2 values into their own 2-Nodes
      children placed according to relation to new 2-Nodes
</pre>
              <br/>
              <p>Whew! That looks complicated, but let's look at a simple example, step by step:</p>
              <br/>
              <div class="text-center fit-pres">
                <img src="../../../assets/images/summer-2014/cs-32/week-6/23-ex-0.png">
              </div>
              <br/>
              <div class="text-center fit-pres">
                <img src="../../../assets/images/summer-2014/cs-32/week-6/23-ex-1.png">
              </div>
              <br/>
              <div class="text-center fit-pres">
                <img src="../../../assets/images/summer-2014/cs-32/week-6/23-ex-2.png">
              </div>
              <br/>
              <div class="text-center fit-pres">
                <img src="../../../assets/images/summer-2014/cs-32/week-6/23-ex-3.png">
              </div>
              <br/>
              <div class="text-center fit-pres">
                <img src="../../../assets/images/summer-2014/cs-32/week-6/23-ex-4.png">
              </div>
              <br/>
              <div class="text-center fit-pres">
                <img src="../../../assets/images/summer-2014/cs-32/week-6/23-ex-5.png">
              </div>
              <br/>
              <div class="text-center fit-pres">
                <img src="../../../assets/images/summer-2014/cs-32/week-6/23-ex-6.png">
              </div>
              <br/>
              <div class="text-center fit-pres">
                <img src="../../../assets/images/summer-2014/cs-32/week-6/23-ex-7.png">
              </div>
              <br/>
              <div class="text-center fit-pres">
                <img src="../../../assets/images/summer-2014/cs-32/week-6/23-ex-8.png">
              </div>
              <br/>
              <p>And there you have it!</p>
              <p>Deletion is substantively more complicated and won't be detailed in this lecture.</p>
              <p>There are many articles and videos on the topic that a simple Google search will demonstrate, but for which we simply don't have time in discussion.</p>
            </div>
            <hr/>
            <br/>
            
            
            <div id='STLSetMap' class='scrollspy-element' scrollspy-title='STL Set &amp; Map'></div>
            <h1>STL Set &amp; Map</h1>
            <div>
              <p>Let's take a whirlwind tour through two STL collections: the set and the map</p>
              
              <br/>
              <h3>#include &lt;set&gt;</h3>
              <p class='definition'><strong>Sets</strong> are simply a collection of items of the given templated type stored in a binary search tree.</p>
              <p>Here's an example of some common operations with sets:</p>
<pre class='prettyprint'>
  int main () {
      set&lt;int&gt; s;
  
      // Inserting values into set
      s.insert(5);
      s.insert(20);
      s.insert(2);
  
      // You can erase values from the set
      s.erase(2);
      s.insert(3);
  
      // You can define iterators
      // [!] This is a binary search tree,
      // what will get printed out?
      set&lt;int&gt;::iterator sit = s.begin();
      while (sit != s.end()) {
          cout &lt;&lt; *sit++ &lt;&lt; endl;
      }
  
      // Get the size of the set
      cout &lt;&lt; "size: " &lt;&lt; s.size() &lt;&lt; endl;
  
      // Clear the set
      s.clear();
  }
</pre>
              <br/>
              <h3>#include &lt;map&gt;</h3>
              <p class='definition'><strong>Maps</strong> are simply a collection of key/value pairs (associations) of the given templated types stored in a binary search tree.</p>
<pre class='prettyprint'>
  int main () {
      map&lt;string, int&gt; m;
  
      // Inserting values into map
      m["look"] = 3;
      m["at"] = 20;
      m["me"] = 10;
      // [!] Note! Unlike vectors, in which the
      // bracket operator is undefined when the
      // index is out of range, this insertion
      // method is OK for keys that haven't been
      // set yet
  
      // You can erase values from the map
      m.erase("look");
      m["yo"] = 15;
  
      // You can update existing values
      m["me"] = 12;
  
      // You can define iterators
      // [!] This is a binary search tree,
      // what will get printed out?
      map&lt;string, int&gt;::iterator mit = m.begin();
      while (mit != m.end()) {
          // [!] Keys in iterators are stored in a
          // "first" field; values in a "second" field
          cout &lt;&lt; mit-&gt;first &lt;&lt; ": " &lt;&lt; mit-&gt;second &lt;&lt; endl;
          mit++;
      }
  
      // Get the size of the map
      cout &lt;&lt; "size: " &lt;&lt; m.size() &lt;&lt; endl;
  
      // Clear the map
      m.clear();
  }
</pre>
            </div>
            <hr/>
            
            
            <div id='practice2' class='scrollspy-element' scrollspy-title='More Practice'></div>
            <h1>Practice &amp; Review</h1>
            <div>
                            <h3>Complexity Review</h3>
              
              <p>There were a significant number of questions regarding time complexity in the logarithmic case.</p>
              <p>Since tree algorithms generally involve some flavor of a log complexity, let's review some algorithms now...</p>
              <p class='definition'>
                A rule of thumb for logarithm complexity is when you're omitting or ignoring some number of input elements with every step that is proportional to the log of the size of the input.
              </p>
              <p>Often, this is manifest in divide-and-conquer algorithms, but sometimes it's simpler than that... that for example the following:</p>
              <p class='example'>What is the time complexity of the following function?</p>
<pre class='prettyprint'>
  void someFunc (vector&lt;int&gt; v) {
      for (int i = 1; i &lt; v.size(); i *= 2) {
          cout &lt;&lt; v[i] &lt;&lt; endl;
      }
  }
</pre>
              <br/>
              <p>We also know that some algorithms can have logarithmic components that rely on other components of the algorithm, and vice versa...</p>
              <p class='example'>What is the time complexity of the following function?</p>
<pre class='prettyprint'>
  void someFunc (vector&lt;int&gt; v) {
      for (int i = 0; i &lt; v.size(); i++) {
          for (int j = i; j &gt; 0; j /= 2) {
              if (v[j] == v[i]) {
                  cout &lt;&lt; v[i] &lt;&lt; endl;
              }
          }
      }
  }
</pre>
              <br/>
              <p>You should also be aware that big-O complexity need not be reliant upon a single input; you can have complexities in terms of multiple inputs as well!</p>
              <p class='example'>What is the time complexity of the following function?</p>
<pre class='prettyprint'>
  // [!] Consider N = v1.size() and M = v2.size()
  void someFunc (vector&lt;int&gt; v1, vector&lt;int&gt; v2) {
      for (int i = 0; i &lt; v1.size(); i++) {
          for (int j = 0; j &lt; v2.size(); j += 2) {
              if (v1[i] == v2[j]) {
                  cout &lt;&lt; v1[i] &lt;&lt; endl;
              }
          }
      }
  }
</pre>
              <br/>
              <p>Lastly, let's remember our tree algorithm complexities...</p>
              <p class='example'>What is the time complexity of the following function?</p>
<pre class='prettyprint'>
  // [!] Consider N = v1.size() and M = s.size()
  void someFunc (vector&lt;int&gt; v1, set&lt;int&gt; s) {
      for (int i = 0; i &lt; v1.size(); i++) {
          if (s.find(v[i]) != s.end()) {
              cout &lt;&lt; v1[i] &lt;&lt; endl;
          }
      }
  }
</pre>

              <br/>
              <h3>Binary Tree Review</h3>
              <p>We've seen some traversal algorithms for binary trees, but let's look at a couple extra for practice.</p>
              <p>Below, I've gotten us started with a Binary Tree class, as well as a new way to insert Nodes with a given path to an empty space.</p>
<pre class='prettyprint'>
  struct BinTree {
      // BinTreeNode struct internal
      // to the BinTree
      struct BinTreeNode {
          int data;
          BinTreeNode* left;
          BinTreeNode* right;
          BinTreeNode(int d) {
              data = d;
              left = nullptr;
              right = nullptr;
          }
      };
  
      // Root just points to a single
      // BinTreeNode
      BinTreeNode* root;
  
      BinTree() {
          root = nullptr;
      }
      ~BinTree() {}; // TODO!
      void insertAt (int i, string path);
  };
</pre>
              <br/>
              
              <p>Now, suppose I wish to define the insertAt member function:</p>
<pre class='prettyprint'>
  // Creates a new node with the given data member
  // if input string p specifies a path in terms of
  // L and R children to follow to an empty spot in
  // the tree
  // The path p will look like some string of "LRL"
  void BinTree::insertAt (int data, string p) {
      BinTreeNode* b = root;
      BinTreeNode* last = nullptr;
      int i = 0;
  
      // First, we'll go through our desired path
      // of insertion
      while (i &lt; p.length()) {
          // If we hit the nullptr before we're
          // done, just break out of the loop
          if (b == nullptr) {
              break;
          }
          // Keep track of our parent node...
          last = b;
          // ...then move on to the path's desired
          // child
          b = (p[i] == 'L') ? b-&gt;left : b-&gt;right;
          i++;
      }
  
      // If we followed a path the length of
      // our desired path, then we have a valid
      // insertion; otherwise the path was
      // mis-specified
      if (i == p.length()) {
          // If there's already a node there,
          // bad path, so we'll just return
          if (b != nullptr) {
              return;
          }
          // Otherwise, there's an opening, so
          // we'll make a new node at b
          b = new BinTreeNode(data);
          // If there's nothing in the tree yet,
          // then b is our root!
          if (root == nullptr) {
              root = b;
          }
          // If we have a parent node to add
          // the child to, update its left or
          // right pointer
          if (last != nullptr) {
              if (p[i - 1] == 'L') {
                  last-&gt;left = b;
              } else {
                  last-&gt;right = b;
              }
          }
      }
  }
</pre>
              <p>So, if I wanted to add Nodes to my tree, I would simply say:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-9/btree-0.png' />
              </div>
              <br/>
              <p>So, now I can recreate this tree in my BinaryTree class via:</p>
<pre class='prettyprint'>
  int main () {
      BinTree bt;
      bt.insertAt(14, "");
      bt.insertAt(10, "L");
      bt.insertAt(8, "LL");
      bt.insertAt(11, "LR");
      bt.insertAt(15, "R");
  }
</pre>
              <br/>
              <p>Neat! Now let's look at making some of our own functions...</p>
              <p>First, let's have a way to print out our tree; we'll print out each subtree as enclosed within parentheses, like so:</p>
<pre class='prettyprint'>
  int main () {
      BinTree bt;
      
      bt.insertAt(14, "");
      // prints: (14)
      printByClosure(bt.root);
      cout &lt;&lt; endl;
        
      bt.insertAt(10, "L");
      // prints: ((10)14)
      printByClosure(bt.root);
      cout &lt;&lt; endl;
        
      bt.insertAt(8, "LL");
      // prints: (((8)10)14)
      printByClosure(bt.root);
      cout &lt;&lt; endl;
        
      bt.insertAt(11, "LR");
      // prints: (((8)10(11))14)
      printByClosure(bt.root);
      cout &lt;&lt; endl;
        
      bt.insertAt(15, "R");
      // prints: (((8)10(11))14(15))
      printByClosure(bt.root);
      cout &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>Complete the function shell for printByClosure below:</p>
<pre class='prettyprint'>
  void printByClosure (BinTree::BinTreeNode* b) {
      // [!] Base case
      if ( ??? ) {
          ???
      }
  
      // [!] Otherwise, starting a new
      // closure, so print out...
      cout &lt;&lt; ???;
  
      // [!] Perform some form of traversal
      // here... which one will give us the
      // desired output?
      
      // [!] Ending our closure, so print...
      cout &lt;&lt; ???;
  }
</pre>
              <br/>
              <p>Let's do something &quot;fun&quot;... why don't we create a function that turns our tree into a mirror image of itself?</p>
<pre class='prettyprint'>
  int main () {
      BinTree bt;
      bt.insertAt(14, "");
      bt.insertAt(10, "L");
      bt.insertAt(18, "R");
      printByClosure(bt.root);
      cout &lt;&lt; endl;
      // Was ((10)14(18)),
      // Now ((18)14(10))
      mirror(bt.root);
      printByClosure(bt.root);
      cout &lt;&lt; endl;
  
      bt.insertAt(17, "LR");
      printByClosure(bt.root);
      cout &lt;&lt; endl;
      // Was ((18(17))14(10)),
      // Now ((10)14((17)18))
      mirror(bt.root);
      printByClosure(bt.root);
      cout &lt;&lt; endl;
  }
</pre>
              <br/>
              <p class='example'>Complete the function shell for mirror, below:</p>
<pre class='prettyprint'>
  void mirror (BinTree::BinTreeNode* b) {
      // [!] Base Case
      if ( ??? ) {
          return;
      }
    
    // Create a temp holder for our swap
      BinTree::BinTreeNode* temp;
    
    // [!] Perform some order of traversal
    // to do the swap... which one?
      ???
    
    // [!] Swap the current node's left
    // and right with the temp, saving
    // one into temp first
      ???
  }
  // ^ Example credit to Stanford's tree examples
  // (listed later)
</pre>
              <br/>
              <p>I'll have some more examples using this class on the practice final...</p>
            </div>
            <hr/>
            
            
            <a class='btn btn-default pull-right hidden-print' href='javascript:window.print();'>
              <span class='glyphicon glyphicon-print'></span>
              &nbsp; PDF / Print
            </a>
            
          </div>
          <!-- END PRESENTATION CONTENT -->
          
          <!-- MATERIALS FROM CLASS: -->
          
        </div>
      </div>
      <!-- END MAIN CONTENT -->
      
      
    </div>
    <!-- END WRAPPER -->
    
    <!-- BEGIN FOOTER -->
    <div id="footer">
      <div class="container">
        <div class="col-md-12 text-center">
          
        </div>
      </div>
    </div>
    <!-- END FOOTER -->
    
  </body>
</html>
