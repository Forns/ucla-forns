
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <title>Andrew Forney - UCLA CS</title>
    <link href="../../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../../../css/magic-bootstrap.css" rel="stylesheet" type="text/css">
    <link href="../../../css/main.css" rel="stylesheet" type="text/css">
    <script src="../../../js/lib/jquery-2.0.3.min.js"></script>
    <script src="../../../js/lib/bootstrap.min.js"></script>
    <script src="../../../js/lib/expanding.js"></script>
    <script src="../../../js/display/general/general-display.js"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
  </head>
  
  <body data-spy="scroll" data-target="#scrollspy">
    
    <!-- BEGIN WRAP -->
    <div id="wrap">
      
      <!-- BEGIN NAVIGATION -->
      <nav class='navbar navbar-default' role='navigation'>
        <div class='nav-accent'></div>
        <div class='container'>
          <div class='row'>
            <div class='col-md-12'>
              <div class='navbar-header'>
                <button class='navbar-toggle' type='button' data-toggle='collapse' data-target='.navbar-main-collapse'>
                  <span class='sr-only'>Toggle Navigation</span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                </button>
                <a class='navbar-brand' href='/~forns/'>
                  <span id='brand-text'>
                    Andrew Forney
                  </span>
                </a>
              </div>
              
              <div id='nav-main' class='collapse navbar-collapse navbar-main-collapse'>
                <ul class='nav navbar-nav navbar-right'>
                  
                  <li>
                    <a href='/~forns/about.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-user'></span>
                      </div>
                      <p class='text-center'>About</p>
                    </a>
                  </li>
                  
                  <li class='active'>
                    <a href='/~forns/classes.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-book'></span>
                      </div>
                      <p class='text-center'>Classes</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/contact.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-comment'></span>
                      </div>
                      <p class='text-center'>Contact</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/publications.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-file'></span>
                      </div>
                      <p class='text-center'>Publications</p>
                    </a>
                  </li>
                  
                </ul>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <!-- END NAVIGATION -->
      
      <!-- BEGIN MAIN CONTENT -->
      <div id="main-content" class="container">
        <div class="row">
          
          <!-- BEGIN SCROLLSPY -->
          <div class='col-md-2 hidden-sm hidden-xs'>
            <div class="bs-sidebar hidden-print affix" role="complementary">
              <ul id='scrollspy' class="nav bs-sidenav">
              </ul>
            </div>
          </div>
          <!-- END SCROLLSPY -->
          
          <!-- BEGIN PRESENTATION CONTENT -->
          <div class='col-md-10 presentation-content' role='main'>
            
            <ol class="breadcrumb hidden-print">
              <li><a href="../../../classes.html">Classes</a></li>
              <li><a href="./cs-31.html">Winter14 CS32</a></li>
              <li class="active">Week 4</li>
            </ol>
            
            
            <br/>
            <div id='review' class='scrollspy-element' scrollspy-title='Review'></div>
            <h1>Questions from Last Week</h1>
            <div>
            </div>
            <hr/>
            
            <br/>
            <div id='inheritance' class='scrollspy-element' scrollspy-title='Inheritance'></div>
            <h1>Class Inheritance</h1>
            <div>
              <p>Last week was unfortunately... quite dull... can we do something vaguely resembling entertainment?</p>
              <p>Yeah I wish so too... unfortunately, all I have is the following:</p>
              <hr/>
              <p>I'm glad you guys are here because I'm designing an all new battle game that in no way, shape, or form resembles a certain Nintendo franchise...</p>
              <p>Naturally, I'm calling it ForneyMon, where we have different mythical pets of different types locked in psuedo-humane combat for our amusement!</p>
              <p>I'm starting off slow and hoping we can develop the concept a bit in this class... here's the gist:</p>
              <ul class='indent-1'>
                <li><p>I have two types of ForneyMon right now: the BurnyMon, which singes its opponents with the fire of 5 suns, and DampyMon, which annoys its opponents by getting them wet.</p></li>
                <li><p>Both have a certain amount of starting health and a name that its <span class='strike'>trainer</span> err... owner has given it.</p></li>
                <li><p>Presently, ForneyMon can only interact by dealing damage and taking damage of a certain type (e.g. Burny damage or Dampy damage).</p></li>
                <li><p>DampyMon take bonus damage from BurnyMon, but DampyMon start with more health.</p></li>
              </ul>
              <p>...anyways here's the sketch I have so far, take a look:</p>
              <br/>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
    
  class DampyMon;
  
  class BurnyMon {
      private:
          string m_name;
          int m_health;
  
      public:
          BurnyMon (string name);
          int takeDamage (int dam, string type);
          void dealDamage (DampyMon* other, int dam, string type);
  };
  
  class DampyMon {
      private:
          string m_name;
          int m_health;
  
      public:
          DampyMon (string name);
          int takeDamage (int dam, string type);
          void dealDamage (BurnyMon* other, int dam, string type);
  };
</pre>
              <br/>
              <p class='question' name='inheritance-q0'>Point out some problems with my class definitions (and don't you dare say the whole example).</p>
              <div class='answer' name='inheritance-q0'>
                <ul class='indent-1'>
                  <li><p>No ability to talk about groups of ForneyMon, regardless of whether they're DampyMon or BurnyMon</p></li>
                  <li><p>Code repetition, especially with private members and constructors</p></li>
                  <li><p>No scalability: all of my functions that target other ForneyMon are specific to the class of the other ForneyMon!</p></li>
                </ul>
              </div>
              <p>Let's look at each of these problems separately and see how we might fix them:</p>
              
              <br/>
              
              <h3>Abstracting Common Members</h3>
              <p>As we noticed, the private members for our two classes are the same!</p>
              <p class='question' name='inheritance-q1'>Remind me, why is code repetition bad?</p>
              <p class='answer' name='inheritance-q1'>It violates the One-Change, One-Place principal, wastes file space, and can potentially hinder efficiency.</p>
              <p>If we could somehow abstract those elements outside of these two classes into another class that, say, was higher in a hierarchy, that would be great!</p>
              <p>Turns out, that's exactly what we'll do...</p>
              <p class='definition'>A <strong>base class</strong> is a class from which other (derived) classes inherit properties.</p>
              <p>We'll define a base class from which our two classes inherit some common elements. This makes our two classes that inherit from the base class called derived classes.</p>
              <p class='definition'>A <strong>derived class</strong> is a class that inherits features from a base class.</p>
              <p class='definition'>
                <strong>Inheritance</strong>, therefore, is the process of defining a derived class from an existing base class. We say that the derived class <strong>inherits</strong>
                certain characteristics of its base.
              </p>
              <p>The syntax for defining inheritance is the following:</p>
<pre class='prettyprint'>
  class DerivedClass: public BaseClass {
    // ...
  };
</pre>
              <p class='example'>Here's a simple example of inheritance of a Base class to a Derived class:</p>
<pre class='prettyprint'>
  struct DropTheBase {
      int a;
      string s;
      string m;
      DropTheBase () {
          a = 3;
          s = "[s] Base!";
          m = "[m] Base!";
      }
  };
  
  // This example's puns are off the hook
  struct DerivingMeCrazy : public DropTheBase {
      int a;
      string s;
      string t;
      DerivingMeCrazy () {
          a = 1;
          s = "[s] Derived!";
          t = "[t] Derived!";
      }
  };
</pre>
              <p>So what's happening behind the scenes here? Let's look at a few properties of inheritance:</p>
              <p class='definition'>The <strong>is-a</strong> relationship describes the inheritance flow from a base class to a derived class. We say that a derived class is-a type of the base class.</p>
              <p>Well, during lecture, we said that a <code class='prettyprint'>Dog</code> (derived class) is-a <code class='prettyprint'>Mammal</code> (base class).</p>
              <p>So, above, we say that <code class='prettyprint'>DerivingMeCrazy</code> is-a <code class='prettyprint'>DropTheBase</code>... hmm, not one of my finest examples... but worth the joke.</p>
              <p>What this means is that the Base class, and all of its members, are now a PART of the derived class!</p>
              
              <!-- TODO: DIAGRAM HERE -->
              
              <p>See how that relationship works out?</p>
              <p>This means that I can access any member of a Base class from its Derived classes.</p>
              <p class='example'>See how we access the m member from a DerivingMeCrazy class:</p>
<pre class='prettyprint'>
  struct DropTheBase {
      int a;
      string s;
      string m;
      DropTheBase () {
          a = 3;
          s = "[s] Base!";
          m = "[m] Base!";
      }
  };
  
  struct DerivingMeCrazy : public DropTheBase {
      int a;
      string s;
      string t;
      DerivingMeCrazy () {
          a = 1;
          s = "[s] Derived!";
          t = "[t] Derived!";
      }
  };
  
  int main () {
      DerivingMeCrazy d;
      cout &lt;&lt; d.a &lt;&lt; endl;
      cout &lt;&lt; d.s &lt;&lt; endl;
      cout &lt;&lt; d.t &lt;&lt; endl;
      cout &lt;&lt; d.m &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>
                Now that's all fine and good, but why did I get the Derived class versions of <code class='prettyprint'>a</code> and <code class='prettyprint'>s</code>
                over the <code class='prettyprint'>DropTheBase</code> versions?
              </p>
              <div class='definition'>
                <p>If a data member is defined in both a Derived class and its Base class, AND:</p>
                <ul class='indent-1'>
                  <li><p>An object is an instance of the Derived class, then we use the Derived class' definitions of those members.</p></li>
                  <li><p>An object is an instance of the Base class, then we use the Base class' definitions of those members.</p></li>
                </ul>
              </div>
              <p>So, if I have a DropTheBase object, I use the Base class' <code class='prettyprint'>a</code> and <code class='prettyprint'>s</code>...</p>
              <p>So, if I have a DerivingMeCrazy object, I use the Derived class' <code class='prettyprint'>a</code> and <code class='prettyprint'>s</code>...</p>
              <p class='definition'>If a member is not defined in my object's class, I will try to find it in my Base classes.</p>
              <p class='example'>What will the following code print out?</p>
<pre class='prettyprint'>
  struct DropTheBase {
      int a;
      string s;
      string m;
      DropTheBase () {
          a = 3;
          s = "[s] Base!";
          m = "[m] Base!";
      }
  };
  
  struct DerivingMeCrazy : public DropTheBase {
      int a;
      string s;
      string t;
      DerivingMeCrazy () {
          a = 1;
          s = "[s] Derived!";
          t = "[t] Derived!";
      }
  };
  
  int main () {
      DropTheBase b;
      DerivingMeCrazy d;
      cout &lt;&lt; d.a &lt;&lt; endl;
      cout &lt;&lt; b.a &lt;&lt; endl;
      
      cout &lt;&lt; d.s &lt;&lt; endl;
      cout &lt;&lt; b.s &lt;&lt; endl;
      
      cout &lt;&lt; d.m &lt;&lt; endl;
      cout &lt;&lt; b.m &lt;&lt; endl;
  }
</pre>
              <br/>
              
              <!-- TODO: What classes have access to what members? Do a 3 class chain, a Base object trying to get a Derived member, and a 2 Derived - 1 Base -->
              
              <p>Now, here comes the magic...</p>
              <p>I know that because DerivingMeCrazy inherits from DropTheBase, which means that somewhere in DerivingMeCrazy is a DropTheBase object... how do I access its members?</p>
              <p class='toolkit'>
                If I have a pointer of type Base class, and it points to an object of one that Base class' Derived classes, then my pointer now points to the Base class portion of that
                Derived class object.
              </p>
              <p>Here's what that looks like:</p>
              
              <!-- TODO: DIAGRAM HERE -->
              
              <p class='example'>So knowing that's how pointers of the Base class behave, what will the following print out?</p>
<pre class='prettyprint'>
  struct DropTheBase {
      int a;
      string s;
      string m;
      DropTheBase () {
          a = 3;
          s = "[s] Base!";
          m = "[m] Base!";
      }
  };
  
  struct DerivingMeCrazy : public DropTheBase {
      int a;
      string s;
      string t;
      DerivingMeCrazy () {
          a = 1;
          s = "[s] Derived!";
          t = "[t] Derived!";
      }
  };
  
  int main () {
      DerivingMeCrazy d;
      DropTheBase* bPtr = &amp;d;
      
      cout &lt;&lt; bPtr-&gt;a &lt;&lt; endl;
      cout &lt;&lt; bPtr-&gt;s &lt;&lt; endl;
      cout &lt;&lt; bPtr-&gt;m &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>NOTE: I said that a Base class pointer can point to the Base class portion of one of its Derived class' objects... it does NOT work the other way around.</p>
              <p class='debug'>Will the following code compile?</p>
<pre class='prettyprint'>
  int main () {
      DropTheBase b;
      DerivingMeCrazy* dPtr = &amp;b;
      
      cout &lt;&lt; dPtr-&gt;s &lt;&lt; endl;
  }
</pre>
              
              <!-- TODO: LEFT OFF HERE -->
              
              
              <p>So, let's define a new base class called ForneyMon and use it to make a heterogeneous collection:</p>
<pre class='prettyprint'>
</pre>
              <br/>
              <p>Now, I can make statements like:</p>
<pre class='prettyprint'>
  int main () {
  }
</pre>
              <p>See how I was able to store both a BurnyMon and DampyMon in that array?! Crazy!</p>
              
              <!-- TODO:
              <h3>Heterogeneous Collections</h3>
              <p>One of the issues we noticed was that I cannot make a collection (let's say, an array) of ForneyMon that consists of both BurnyMon and DampyMon.</p>
              <p>It would be nice if I could tell the compiler that I want to make a sort of type hierarchy where I arrange both of these classes under amore general one...</p>
              <p>Hey, how bout that! Turns out I can:</p>
              
              
              -->
              
            </div>
            <hr/>
            
            
            <a class='btn btn-default pull-right hidden-print' href='javascript:window.print();'>
              <span class='glyphicon glyphicon-print'></span>
              &nbsp; PDF / Print
            </a>
            
          </div>
          <!-- END PRESENTATION CONTENT -->
          
          <!-- MATERIALS FROM CLASS: -->
          
          <!-- TODO: Inheritance -->
            <!-- TODO: Base class / superclass / generalization -->
            <!-- TODO: Derived class / subclass / specialization -->
              <!-- TODO: Derived classes has embedded within it the Base class(es) that it is a part of -->
              <!-- TODO: Within each of the derived classes, you inherit the data members of the base class -->
              <!-- TODO: Any time you need a pointer to a derived class where a pointer to its base class is expected, there's an automatic conversion to the base -->
                <!-- TODO: This conversion makes a pointer to the BASE CLASS portion of the derived class (remember the base class is a part of the derived) -->
                <!-- TODO: Shape* shapePtrs[3]; ... shapePtrs[0] = new Circle(); // OK! heterogeneous collection established -->
                <!-- TODO: Shape shapePtrs[3]; ... shapePtrs[0] = Circle(); // BAD! now array is not an array of the same thing! -->
              <!-- TODO: Any time you have a derived object and you need a reference to a Base object, it will also perform the automatic conversion -->
                <!-- TODO: The reference will be to the BASE CLASS portion of the derived object -->
              <!-- TODO: Summary *Circle => *Shape, Circle& => Shape& -->
              
          <!-- TODO: If a base class says it has some function (like move), then all derived classes must declare it UNLESS They wish to inherit it from the base -->
            <!-- TODO: e.g., if I have a Circle that did NOT declare a member function called move, but the Shape class (a Base for Circle) DOES, then it just uses that implementation -->
            <!-- TODO: Example: Call to different functions that are implemented in the base class, but not the derived, and every variation of that -->
            <!-- TODO: You can provide overriding implementations in derived classes, should the base class also contain a function definition -->
              <!-- TODO: How to get the base class implementation of a function from a derived class? can use the base class::functionName -->
                <!-- TODO: PROBLEM: what if you have a base class' virtual move function, and in a derived class, you have a function called move that invokes the superclass' move? -->
                  <!-- TODO: It will try to call the Derived class': infinite loop! -->
              <!-- TODO: PROBLEM: what if the base class' move is NOT virtual? Then we call different functions based on which object is expected (e.g., a Shape parameter for a Circle object) -->
                <!-- TODO: Circle c; Shape* sPtr = c; c.move() different from sPtr->move()!!! -->
                <!-- TODO: SOLUTION: NEVER override a non-virtual function!!! -->
            <!-- TODO: How does the compiler know which function to call? Well, if it is uncertain if it's the superclass or the subclass at runtime, it DEFAULTS to calling the base class' implementation! -->
              <!-- TODO: If the decision of what call to make happens at compile time, it's called Static Binding -->
                <!-- TODO: Need to bind a call to some portion of machine code -->
              <!-- TODO: We WANT dynamic binding, which will be decided at runtime, after a particular object has been EITHER generalized or specialized -->
                <!-- TODO: Every other language (Java, C#) does dynamic binding by default, but C++, designed for performance, doesn't -->
                  <!-- TODO: With inheritance, dynamic binding is the right choice, so we need to make sure that our code makes the right decision -->
                  <!-- TODO: Declaring a function as virtual in the base class will choose the correct function implementation during runtime -->
                    <!-- TODO: Declaring a function virtual IS ONLY REQUIRED in the base class, and is unnecessary in the derived classes, but often good to write virtual there too -->
                  <!-- TODO: Example with different member functions defined as virtual (dynamic) vs. non-virtual (static) -->
                <!-- TODO: For every class that has at least 1 virtual function, the compiler sets up a Virtual Table (vtbl), that has one entry for every virtual function -->
                  <!-- TODO: NO virtual functions => NO virtual table -->
                  <!-- TODO: IF a function has no implementation in a derived class, better to make it NON virtual (no need to follow virtual pointers at that point) -->
                  <!-- TODO: 
                    Each table element has a pointer to the particular implementations of that virtual function; SO, if we have a Shape, it will have a virtual table entry for
                    every virtual function it has, and Rectangle will have a Virtual table entry for every virtual function... etc.
                  -->
                <!-- TODO: When an object is created, it contains a POINTER (the Virtual Pointer) to the VIRTUAL TABLE that applies to it -->
                  <!-- TODO: This provides runtime definitions for the functions that have been overrided -->
                  <!-- TODO: Virtual pointers are correctly linked to the right table during RUNTIME because we won't know what object's table to point to until new objects are made -->
                  
            <!-- TODO: Abstract / Pure Virtual functions -->
              <!-- TODO: Declaring a virtual function with = 0 after the signature says that this might be an implemented function in derived classes, but NOT to be implemented by the Base class -->
              <!-- TODO: virtual void draw() const = 0; // for example -->
              <!-- TODO: AS SOON AS you declare one abstract function in a class, that becomes an Abstract Class that cannot be constructed directly (unlike Concrete Classes: Circle, Rectangle) -->
              <!-- TODO: Banned statements: Shape s; Shape* sPtr = new Shape(); // BAD -->
              <!-- TODO: Why not just omit the draw function from Shape? Without including it, any derived class objects will not be able to call their draw! -->
              <!-- TODO: Abstract classes are useful for grouping common characteristics and adhering to a contract -->
                <!-- TODO: Ex: abstract class with abstract functions that has a derived class that DOES NOT implement that function--then that derived class is now abstract as well! -->
                
            <!-- TODO: Construction, revisited -->
              <!-- TODO: Steps: -->
                <!-- TODO: 1) Construct the base part (looks for it in member initialization list) -->
                  <!-- TODO: Circle::Circle (double x, double y, double r) : Shape(x, y), m_r(r) {...} -->
                  <!-- TODO: Example: what if I left the member initialization list w/o the Circle constructor, and it doesn't have a default? Won't compile -->
                <!-- TODO: 2) Construct the data members (member initialization list) -->
                <!-- TODO: 3) Execute the body of the constructor -->
            
            <!-- TODO: Destruction goes in the opposite order -->
              <!-- TODO: 1) Execute the body of the constructor -->
              <!-- TODO: 2) Destroy the data members -->
              <!-- TODO: 3) Destroy the base members -->
                <!-- TODO: Derived class need not worry about the Base class' member cleanup; that's handled in the base class'  -->
            
            <!-- TODO: Virtual destructors -->
              <!-- TODO: Consists of a linked list of vertices -->
              <!-- TODO: What if I declare a Shape* s = new Polygon(); -->
              <!-- TODO: How to know which destructor to call? At compile time, it might try to call the shape destructor ALONE, and not the appropriate one for Polygon -->
              <!-- TODO: Need to declare the destructor for the base class as Virtual -->
                <!-- TODO: What if I just declare the base class destructor as virtual but then don't implement it? Linker error! -->
                <!-- TODO: Any derived class will call the destructor for the base class which, if not implemented, will cause problems -->
                <!-- TODO: Rule: if a class is going to be a base class, need to at least give the base class a shell of a destructor implementation or it won't compile -->
            
            <!-- TODO: Interface classes -->
              <!-- TODO: Classes that have NO function implementations; every function is pure virtual / abstract -->
              <!-- TODO: No special keywords like in java to indicate this, just the nomenclature for C++ -->
            
            <!-- TODO: What class (derived, base) has access from and to what other class? (derived, base) -->
            <!-- TODO: Example: virtual function that goes from base A -> derived B, which is a base to -> derived C -->
            
            
            <!-- TODO: Sorting -->
              <!-- TODO: Review of merge sort of two stacks of sorted papers: simple -->
              <!-- TODO: What about sorting two *unsorted* stacks? -->
              <!-- TODO: Merge sort algorithm: -->
                <!-- TODO: if n >= 2 -->
                  <!-- TODO: Split pile into two -->
                  <!-- TODO: *Sort one half and then sort the other, separately -->
                <!-- TODO: Merge the two results -->
              <!-- TODO: *how to perform this sort? Well, I already have the algorithm for this split: the original! -->
              <!-- TODO: Each sort of a sub-problem is just a smaller instance of the same algorithm -->
              <!-- TODO: This is a divide-and-conquer method that uses Recursion -->
                <!-- TODO: Notice that it has a stopping condition when we no longer recurse: this is called the base case, and above it's when n < 2 -->
                <!-- TODO: The remaining cases are the recursive cases, with the *condition* that each recursive call must be getting smaller / closer to the base case -->
              <!-- TODO: Just a mention that recursion can be proven using mathematical induction -->
              <!-- TODO: Merge sort in code:
                  void sort (int a[], int b, int e) {
                    // If we have at least 2 elements to sort,
                    // then split the array into two pieces:
                    if (e - b >= 2) {
                      int mid = (b + e) / 2;
                      // Sort left half
                      sort(a, b, mid);
                      // Sort right half
                      sort(a, mid, e);
                      // Assume merge implemented
                      merge(a, b, mid, e); 
                    }
                  }
               -->
          
        </div>
      </div>
      <!-- END MAIN CONTENT -->
      
      
      
    </div>
    <!-- END WRAPPER -->
    
    <!-- BEGIN FOOTER -->
    <div id="footer">
      <div class="container">
        <div class="col-md-12 text-center">
          
        </div>
      </div>
    </div>
    <!-- END FOOTER -->
    
  </body>
</html>
