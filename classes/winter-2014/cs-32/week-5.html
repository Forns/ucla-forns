
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <title>Andrew Forney - UCLA CS</title>
    <link href="../../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../../../css/magic-bootstrap.css" rel="stylesheet" type="text/css">
    <link href="../../../css/main.css" rel="stylesheet" type="text/css">
    <script src="../../../js/lib/jquery-2.0.3.min.js"></script>
    <script src="../../../js/lib/bootstrap.min.js"></script>
    <script src="../../../js/lib/expanding.js"></script>
    <script src="../../../js/display/general/general-display.js"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
  </head>
  
  <body data-spy="scroll" data-target="#scrollspy">
    
    <!-- BEGIN WRAP -->
    <div id="wrap">
      
      <!-- BEGIN NAVIGATION -->
      <nav class='navbar navbar-default' role='navigation'>
        <div class='nav-accent'></div>
        <div class='container'>
          <div class='row'>
            <div class='col-md-12'>
              <div class='navbar-header'>
                <button class='navbar-toggle' type='button' data-toggle='collapse' data-target='.navbar-main-collapse'>
                  <span class='sr-only'>Toggle Navigation</span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                </button>
                <a class='navbar-brand' href='/~forns/'>
                  <span id='brand-text'>
                    Andrew Forney
                  </span>
                </a>
              </div>
              
              <div id='nav-main' class='collapse navbar-collapse navbar-main-collapse'>
                <ul class='nav navbar-nav navbar-right'>
                  
                  <li>
                    <a href='/~forns/about.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-user'></span>
                      </div>
                      <p class='text-center'>About</p>
                    </a>
                  </li>
                  
                  <li class='active'>
                    <a href='/~forns/classes.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-book'></span>
                      </div>
                      <p class='text-center'>Classes</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/contact.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-comment'></span>
                      </div>
                      <p class='text-center'>Contact</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/publications.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-file'></span>
                      </div>
                      <p class='text-center'>Publications</p>
                    </a>
                  </li>
                  
                </ul>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <!-- END NAVIGATION -->
      
      <!-- BEGIN MAIN CONTENT -->
      <div id="main-content" class="container">
        <div class="row">
          
          <!-- BEGIN SCROLLSPY -->
          <div class='col-md-2 hidden-sm hidden-xs'>
            <div class="bs-sidebar hidden-print affix" role="complementary">
              <ul id='scrollspy' class="nav bs-sidenav">
              </ul>
            </div>
          </div>
          <!-- END SCROLLSPY -->
          
          <!-- BEGIN PRESENTATION CONTENT -->
          <div class='col-md-10 presentation-content' role='main'>
            
            <ol class="breadcrumb hidden-print">
              <li><a href="../../../classes.html">Classes</a></li>
              <li><a href="./cs-31.html">Winter14 CS32</a></li>
              <li class="active">Week 4</li>
            </ol>
            
            
            <br/>
            <div id='review' class='scrollspy-element' scrollspy-title='Review'></div>
            <h1>Questions from Last Week</h1>
            <div>
            </div>
            <hr/>
            
            <br/>
            <div id='inheritance' class='scrollspy-element' scrollspy-title='Inheritance'></div>
            <h1>Class Inheritance</h1>
            <div>
              <p>Last week was unfortunately... quite dull... can we do something vaguely resembling entertainment?</p>
              <p>Yeah I wish so too... unfortunately, all I have is the following:</p>
              <hr/>
              <p>I'm glad you guys are here because I'm designing a new discussion-section simulator that is in no way, shape, or form related to a certain franchise of Nintendo's...</p>
              <p>The gist is this: I want to model the intense back-and-forth that we have in class as a game with certain actors locked in the battle of classroom participation.</p>
              <p>I have the following so far:</p>
              <ul class='indent-1'>
                <li><p><strong>TA_Mon</strong> ask Student_Mons to do examples, after which the students fall asleep and lose some health.</p></li>
                <li><p><strong>Student_Mon</strong> ask TA_Mons questions, after which the TA loses 2 health from exhaustion.</p></li>
                <li><p>
                  Later, I might want to add a Crasher_Mon, who isn't enrolled in the class but attends anyways and for some reason participates excessively... I'll probably
                  want to add other actors as well, each of which will interact with one another
                </p></li>
              </ul>
              <p>...anyways I could use some feedback, take a look:</p>
              <br/>
<pre class='prettyprint'>
  #include &lt;queue&gt;
  #include &lt;stack&gt;
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
  
  class Discussion_Mon {};
  class Student_Mon;
  
  class TA_Mon {
      private:
          int m_health;
          bool m_conscious;
          queue&lt;char&gt; m_plan;
  
      public:
          void answerQuestion ();
          void provideBoringExample (Student_Mon&amp; s);
          // ... other functions omitted
  };
  
  class Student_Mon {
      private:
          int m_health;
          bool m_conscious;
          queue&lt;char&gt; m_plan;
  
      public:
          void askQuestion (TA_Mon&amp; ta);
          void doBoringExample ();
          // ... other functions omitted
  };
  
  void TA_Mon::answerQuestion () {m_health -= 2;}
  void TA_Mon::provideBoringExample (Student_Mon&amp; s) {
      s.doBoringExample();
  }
  
  void Student_Mon::askQuestion (TA_Mon&amp; ta) {
      if (m_conscious) {
          ta.answerQuestion();
      }
      m_conscious = true;
  }
  void Student_Mon::doBoringExample () {
      m_health -= 1;
      m_conscious = false;
  }
  
  int main () {
      TA_Mon forns;
      Student_Mon s;
      forns.provideBoringExample(s);
      // ... riveting gameplace mechanics omitted
  }
</pre>
              <br/>
              <p class='question' name='inheritance-q0'>Point out some problems with my class definitions (and don't you dare say the whole example!).</p>
              <div class='answer' name='inheritance-q0'>
                <ul class='indent-1'>
                  <li><p>No ability to talk about groups of actors, regardless of whether they're TA_Mons or Student_Mons</p></li>
                  <li><p>Code repetition, especially with private members and constructors</p></li>
                  <li><p>No scalability: all of my functions that target other actors are specific to the class of the other actor!</p></li>
                </ul>
              </div>
              <p>Let's look at each of these problems separately and see how we might fix them:</p>
              
              <br/>
              
              <!-- TODO:
              <h3>Abstracting Common Members</h3>
              <p>As we noticed, the private members and constructors for our two classes are the same!</p>
              <p class='question' name='inheritance-q1'>Remind me, why is code repetition bad?</p>
              <p class='answer' name='inheritance-q1'>It violates the One-Change, One-Place principal, wastes file space, and can potentially hinder efficiency.</p>
              <p>If we could somehow abstract those elements outside of these two classes into another class that, say, was higher in a hierarchy, that would be great!</p>
              <p>Turns out, that's exactly what we'll do...</p>
              -->
              
              <h3>Heterogeneous Collections</h3>
              <p>One of the issues we noticed was that I cannot make a collection (let's say, a stack) of actors that consists of both TA_Mons and Student_Mons.</p>
              <p>It would be nice if I could tell the compiler that I want to make a sort of type hierarchy where I arrange both of these classes under amore general one...</p>
              <p>Hey, how bout that! Turns out I can:</p>
              <p class='definition'>A <strong>base class</strong> is a class that does not inherit from any other class.</p>
              <p>We'll define a base class from which our two classes inherit some common elements. This makes our two classes that inherit from the base class called derived classes.</p>
              <p class='definition'>A <strong>derived class</strong> is a class that inherits features from a base class.</p>
              <p class='definition'>
                <strong>Inheritance</strong>, therefore, is the process of defining a derived class from an existing base class. We say that the derived class <strong>inherits</strong>
                certain characteristics of its base.
              </p>
              <p>The syntax for defining inheritance is the following:</p>
<pre class='prettyprint'>
  class DerivedClass: public BaseClass {
    // ...
  };
</pre>
              <p>So, let's define a new base class called Discussion_Mon and use it to make a heterogeneous collection:</p>
<pre class='prettyprint'>
  #include &lt;queue&gt;
  #include &lt;stack&gt;
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
  
  class Discussion_Mon {};
  class Student_Mon;
  
  class TA_Mon: public Discussion_Mon {
      private:
          int m_health;
          bool m_conscious;
          queue&lt;char&gt; m_plan;
  
      public:
          void answerQuestion ();
          void provideBoringExample (Student_Mon&amp; s);
          // ... other functions omitted
  };
  
  class Student_Mon: public Discussion_Mon {
      private:
          int m_health;
          bool m_conscious;
          queue&lt;char&gt; m_plan;
  
      public:
          void askQuestion (TA_Mon&amp; ta);
          void doBoringExample ();
          // ... other functions omitted
  };
  
  void TA_Mon::answerQuestion () {m_health -= 2;}
  void TA_Mon::provideBoringExample (Student_Mon&amp; s) {
      s.doBoringExample();
  }
  
  void Student_Mon::askQuestion (TA_Mon&amp; ta) {
      if (m_conscious) {
          ta.answerQuestion();
      }
      m_conscious = true;
  }
  void Student_Mon::doBoringExample () {
      m_health -= 1;
      m_conscious = false;
  }
</pre>
              <br/>
              <p>Now, I can make statements like:</p>
<pre class='prettyprint'>
  int main () {
      TA_Mon forns;
      Student_Mon s;
      
      stack&lt;Discussion_Mon&gt; actorStack;
      actorStack.push(forns);
      actorStack.push(s);
  }
</pre>
              <p>See how I was able to store both a TA_Mon and a Student_Mon object in that stack?! Crazy!</p>
              <p>Unfortunately, we're going to have to wait to see what more we can do with inheritance... next week!</p>
            </div>
            <hr/>
            
            
            <a class='btn btn-default pull-right hidden-print' href='javascript:window.print();'>
              <span class='glyphicon glyphicon-print'></span>
              &nbsp; PDF / Print
            </a>
            
          </div>
          <!-- END PRESENTATION CONTENT -->
          
          <!-- MATERIALS FROM CLASS: -->
          
          <!-- TODO: Inheritance -->
            <!-- TODO: Base class / superclass / generalization -->
            <!-- TODO: Derived class / subclass / specialization -->
              <!-- TODO: Derived classes has embedded within it the Base class(es) that it is a part of -->
              <!-- TODO: Within each of the derived classes, you inherit the data members of the base class -->
              <!-- TODO: Any time you need a pointer to a derived class where a pointer to its base class is expected, there's an automatic conversion to the base -->
                <!-- TODO: This conversion makes a pointer to the BASE CLASS portion of the derived class (remember the base class is a part of the derived) -->
                <!-- TODO: Shape* shapePtrs[3]; ... shapePtrs[0] = new Circle(); // OK! heterogeneous collection established -->
                <!-- TODO: Shape shapePtrs[3]; ... shapePtrs[0] = Circle(); // BAD! now array is not an array of the same thing! -->
              <!-- TODO: Any time you have a derived object and you need a reference to a Base object, it will also perform the automatic conversion -->
                <!-- TODO: The reference will be to the BASE CLASS portion of the derived object -->
              <!-- TODO: Summary *Circle => *Shape, Circle& => Shape& -->
              
          <!-- TODO: If a base class says it has some function (like move), then all derived classes must declare it UNLESS They wish to inherit it from the base -->
            <!-- TODO: e.g., if I have a Circle that did NOT declare a member function called move, but the Shape class (a Base for Circle) DOES, then it just uses that implementation -->
            <!-- TODO: Example: Call to different functions that are implemented in the base class, but not the derived, and every variation of that -->
            <!-- TODO: You can provide overriding implementations in derived classes, should the base class also contain a function definition -->
              <!-- TODO: How to get the base class implementation of a function from a derived class? can use the base class::functionName -->
                <!-- TODO: PROBLEM: what if you have a base class' virtual move function, and in a derived class, you have a function called move that invokes the superclass' move? -->
                  <!-- TODO: It will try to call the Derived class': infinite loop! -->
              <!-- TODO: PROBLEM: what if the base class' move is NOT virtual? Then we call different functions based on which object is expected (e.g., a Shape parameter for a Circle object) -->
                <!-- TODO: Circle c; Shape* sPtr = c; c.move() different from sPtr->move()!!! -->
                <!-- TODO: SOLUTION: NEVER override a non-virtual function!!! -->
            <!-- TODO: How does the compiler know which function to call? Well, if it is uncertain if it's the superclass or the subclass at runtime, it DEFAULTS to calling the base class' implementation! -->
              <!-- TODO: If the decision of what call to make happens at compile time, it's called Static Binding -->
                <!-- TODO: Need to bind a call to some portion of machine code -->
              <!-- TODO: We WANT dynamic binding, which will be decided at runtime, after a particular object has been EITHER generalized or specialized -->
                <!-- TODO: Every other language (Java, C#) does dynamic binding by default, but C++, designed for performance, doesn't -->
                  <!-- TODO: With inheritance, dynamic binding is the right choice, so we need to make sure that our code makes the right decision -->
                  <!-- TODO: Declaring a function as virtual in the base class will choose the correct function implementation during runtime -->
                    <!-- TODO: Declaring a function virtual IS ONLY REQUIRED in the base class, and is unnecessary in the derived classes, but often good to write virtual there too -->
                  <!-- TODO: Example with different member functions defined as virtual (dynamic) vs. non-virtual (static) -->
                <!-- TODO: For every class that has at least 1 virtual function, the compiler sets up a Virtual Table (vtbl), that has one entry for every virtual function -->
                  <!-- TODO: NO virtual functions => NO virtual table -->
                  <!-- TODO: IF a function has no implementation in a derived class, better to make it NON virtual (no need to follow virtual pointers at that point) -->
                  <!-- TODO: 
                    Each table element has a pointer to the particular implementations of that virtual function; SO, if we have a Shape, it will have a virtual table entry for
                    every virtual function it has, and Rectangle will have a Virtual table entry for every virtual function... etc.
                  -->
                <!-- TODO: When an object is created, it contains a POINTER (the Virtual Pointer) to the VIRTUAL TABLE that applies to it -->
                  <!-- TODO: This provides runtime definitions for the functions that have been overrided -->
                  <!-- TODO: Virtual pointers are correctly linked to the right table during RUNTIME because we won't know what object's table to point to until new objects are made -->
                  
            <!-- TODO: Abstract / Pure Virtual functions -->
              <!-- TODO: Declaring a virtual function with = 0 after the signature says that this might be an implemented function in derived classes, but NOT to be implemented by the Base class -->
              <!-- TODO: virtual void draw() const = 0; // for example -->
              <!-- TODO: AS SOON AS you declare one abstract function in a class, that becomes an Abstract Class that cannot be constructed directly (unlike Concrete Classes: Circle, Rectangle) -->
              <!-- TODO: Banned statements: Shape s; Shape* sPtr = new Shape(); // BAD -->
              <!-- TODO: Why not just omit the draw function from Shape? Without including it, any derived class objects will not be able to call their draw! -->
              <!-- TODO: Abstract classes are useful for grouping common characteristics and adhering to a contract -->
                <!-- TODO: Ex: abstract class with abstract functions that has a derived class that DOES NOT implement that function--then that derived class is now abstract as well! -->
                
            <!-- TODO: Construction, revisited -->
              <!-- TODO: Steps: -->
                <!-- TODO: 1) Construct the base part (looks for it in member initialization list) -->
                  <!-- TODO: Circle::Circle (double x, double y, double r) : Shape(x, y), m_r(r) {...} -->
                <!-- TODO: 2) Construct the data members (member initialization list) -->
                <!-- TODO: 3) Execute the body of the constructor -->
            <!-- TODO: Destruction goes in the opposite order -->
          
        </div>
      </div>
      <!-- END MAIN CONTENT -->
      
      
      
    </div>
    <!-- END WRAPPER -->
    
    <!-- BEGIN FOOTER -->
    <div id="footer">
      <div class="container">
        <div class="col-md-12 text-center">
          
        </div>
      </div>
    </div>
    <!-- END FOOTER -->
    
  </body>
</html>
