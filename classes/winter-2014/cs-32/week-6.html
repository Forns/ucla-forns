
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <title>Andrew Forney - UCLA CS</title>
    <link href="../../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../../../css/magic-bootstrap.css" rel="stylesheet" type="text/css">
    <link href="../../../css/main.css" rel="stylesheet" type="text/css">
    <script src="../../../js/lib/jquery-2.0.3.min.js"></script>
    <script src="../../../js/lib/bootstrap.min.js"></script>
    <script src="../../../js/lib/expanding.js"></script>
    <script src="../../../js/display/general/general-display.js"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
  </head>
  
  <body data-spy="scroll" data-target="#scrollspy">
    
    <!-- BEGIN WRAP -->
    <div id="wrap">
      
      <!-- BEGIN NAVIGATION -->
      <nav class='navbar navbar-default' role='navigation'>
        <div class='nav-accent'></div>
        <div class='container'>
          <div class='row'>
            <div class='col-md-12'>
              <div class='navbar-header'>
                <button class='navbar-toggle' type='button' data-toggle='collapse' data-target='.navbar-main-collapse'>
                  <span class='sr-only'>Toggle Navigation</span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                </button>
                <a class='navbar-brand' href='/~forns/'>
                  <span id='brand-text'>
                    Andrew Forney
                  </span>
                </a>
              </div>
              
              <div id='nav-main' class='collapse navbar-collapse navbar-main-collapse'>
                <ul class='nav navbar-nav navbar-right'>
                  
                  <li>
                    <a href='/~forns/about.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-user'></span>
                      </div>
                      <p class='text-center'>About</p>
                    </a>
                  </li>
                  
                  <li class='active'>
                    <a href='/~forns/classes.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-book'></span>
                      </div>
                      <p class='text-center'>Classes</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/contact.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-comment'></span>
                      </div>
                      <p class='text-center'>Contact</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/publications.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-file'></span>
                      </div>
                      <p class='text-center'>Publications</p>
                    </a>
                  </li>
                  
                </ul>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <!-- END NAVIGATION -->
      
      <!-- BEGIN MAIN CONTENT -->
      <div id="main-content" class="container">
        <div class="row">
          
          <!-- BEGIN SCROLLSPY -->
          <div class='col-md-2 hidden-sm hidden-xs'>
            <div class="bs-sidebar hidden-print affix" role="complementary">
              <ul id='scrollspy' class="nav bs-sidenav">
              </ul>
            </div>
          </div>
          <!-- END SCROLLSPY -->
          
          <!-- BEGIN PRESENTATION CONTENT -->
          <div class='col-md-10 presentation-content' role='main'>
            
            <ol class="breadcrumb hidden-print">
              <li><a href="../../../classes.html">Classes</a></li>
              <li><a href="./cs-31.html">Winter14 CS32</a></li>
              <li class="active">Week 6</li>
            </ol>
            
            <div id='review' class='scrollspy-element' scrollspy-title='Review'></div>
            <h1>Questions from Last Week</h1>
            <div>
              <p><strong>Q: Is there a general strategy to approaching a recursion problem?</strong></p>
              <p>General? Well, not really, but there are some guidelines that might help you to think recursively:</p>
              <ul class='indent-1'>
                <li>
                  <p>Start with the very simplest case of the problem that you know how to solve.</p>
                  <ul class='indent-1'>
                    <li><p>Write down the steps that you use to solve it</p></li>
                    <li><p>See if you can reduce those steps to recursive ones</p></li>
                  </ul>
                </li>
                <li>
                  <p>Once you see the very simple case, try applying the same strategy to a more difficult case</p>
                  <ul class='indent-1'>
                    <li><p>If that works, then cool! You're done!</p></li>
                    <li><p>If that *doesn't* work, see if you can split the data in a meaningful way that reduces it to the simple case that you know how to solve.</p></li>
                  </ul>
                </li>
                <li>
                  <p>It also helps to think about base cases and the conditions of termination</p>
                  <ul class='indent-1'>
                    <li><p>
                      Problems involving arrays usually have to look out for index out of bound problems, for example, and how the &quot;end index&quot; relates to where the current recursive
                      call pointer is to an element in that array
                    </p></li>
                  </ul>
                </li>
                <li>
                  <p>Remember the tools available to you in your problem's scenario:</p>
                  <ul class='indent-1'>
                    <li><p>
                      If it's an array input, remember that the elements are indexed; this means that if I have a pointer to the &quot;first&quot; element 
                      (I put &quot;first&quot; in quotes because that might be the first element of a recursive call, but not necessarily the true first element of the array) 
                      and also the length of that array, then I know I have access to that first element and any offset up to the length - 1.
                    </p></li>
                    <li><p>
                      Remember that you can add to and chain recursive calls, for example some function f taking in a pointer to some array element and the remaining length, 
                      I can do: return f(a1 + 1, n1 - 1) + f(a2, n2 - 1); (just an example, not a real answer to anything)
                    </p></li>
                    <li><p>
                      If your function isn't void, try to put your recursive cases into return statements (like above) and plan around that mechanic.
                    </p></li>
                  </ul>
                </li>
              </ul>
              <p>
                The most fruitful experience I have is to do problems by hand, see how I solve it mentally, and then try to abstract those steps to an algorithm--after 
                that, I'll try to make that algorithm recursive!
              </p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='templates' class='scrollspy-element' scrollspy-title='Templates'></div>
            <h1>Templates</h1>
            <div>
              <p>If you remember from our discussion of stacks and queues, we said that these were two instances of abstract data types.</p>
              <p>This meant that, for example, stacks had the FILO behavior, and as long as this behavior is honored, any stack implementation can decide the details for itself.</p>
              <p>We noted that one detail that should be in a stack implementation is that it should be <em>type agnostic,</em> i.e., I can have a stack of whatever types I want:</p>
<pre class='prettyprint'>
  int main () {
      stack&lt;int&gt; intsOnInts;
      intsOnInts.push(4);
      intsOnInts.push(20);
      intsOnInts.push(-2);
  
      stack&lt;string&gt; weave;
      weave.push("bad");
      weave.push("puns");
      weave.push("return");
  }
</pre>
              <br/>
              <p>Along with this point, we said that, to keep things simple, we wanted to talk about a stack of only one type (for the present). So:</p>
<pre class='prettyprint'>
  int main () {
      stack&lt;int&gt; intsOnInts;
      stack&lt;string&gt; weave;
      // weave.push(-2); BAD!
      // intsOnInts.push("bad"); BAD!
  }
</pre>
              <br/>
              <p>
                But this begs the question: how do I have stacks that can handle ints, strings, or whatever types I want them to handle? Is there a different stack type defined for whatever
                type I want to stack?
              </p>
              <p>No! We used templates!</p>
              <p class='definition'><strong>Templates</strong> are a C++ language feature that allow functions and classes to operate with generic types.</p>
              <p class='definition'>A <strong>generic type</strong> is a sort of <em>placeholder</em> for a type that will be matched as needed during compilation.</p>
              <br/>
              <p>
                Using templates, we can define functions and classes that work for a variety of different types without having to explicitly create multiple function and class definitions, one for each type.
              </p>
              <p>So what does the syntax for a template look like? Let's start by discussing them for functions:</p>
              <div class='toolkit'>
                <p>A function template is defined for some number of generic types with the following syntax:</p>
<pre class='prettyprint'>
  template &lt;typename TypeOneName, typename TypeTwoName, ...&gt;
  returnType nameOfFunction (...parameters...) {
      // ... function body ...
  }
</pre>
              </div>
              <p>Now, say I wanted to have a function that compares two types and determines which one is &quot;greater.&quot;</p>
              <p>For many types, we have a good understanding of what this means:</p>
              <ul class='indent-1'>
                <li><p>An int, int1 is greater than int2 if int1 - int2 > 0; i.e., if the quantity of int1 is greater than int2</p></li>
                <li><p>A char operates the same way, except we examine character codes and perform the same comparison.</p></li>
                <li><p>A string s1 is greater than a string s2 by examining each character in the sequence one by one and determining which comes first in the alphabet.</p></li>
              </ul>
              <p>Without templates, we would need to define 3 different functions for the above:</p>
<pre class='prettyprint'>
  int maximum(int i1, int i2) {
      return (i1 &gt; i2) ? i1 : i2;
  }
  
  char maximum(char c1, char c2) {
      return (c1 &gt; c2) ? c1 : c2;
  }
  
  string maximum(string s1, string s2) {
      return (s1 &gt; s2) ? s1 : s2;
  }
  
  int main () {
      string s1 = "test",
             s2 = "this";
      cout &lt;&lt; maximum(s1, s2) &lt;&lt; endl;
  
      int i1 = 20,
          i2 = 8;
      cout &lt;&lt; maximum(i1, i2) &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>Immediately we see that there are syntactic similarities between our three max functions, not to mention the code repetition.</p>
              <p>Let's fix it using a template:</p>
<pre class='prettyprint'>
  template &lt;typename T&gt;
  T maximum(T i1, T i2) {
      return (i1 &gt; i2) ? i1 : i2;
  }
  
  int main () {
      string s1 = "test",
             s2 = "this";
      cout &lt;&lt; maximum(s1, s2) &lt;&lt; endl;
  
      int i1 = 20,
          i2 = 8;
      cout &lt;&lt; maximum(i1, i2) &lt;&lt; endl;
  }
</pre>
              <p>Well that's handy... so is this template some magical one-stop function that handles all of these different cases?</p>
              <p>NO! Templates work like this:</p>
              <p class='definition'>A template function defines a &quot;prototype&quot; function that, during compilation, will be forked into a matching one for the type that wants to use it.</p>
              <p>So, when we call maximum with the 2 strings, our compiler sees the matching template expecting 2 string parameters, and then creates its own, copied function implementation where 
                <code class='prettyprint'>typename T</code> is replaced by <code class='prettyprint'>string</code>
              </p>
              <p>
                Similarly, when the compiler sees maximum called with 2 int parameters, it forks yet another copy from the prototype where <code class='prettyprint'>typename T</code> 
                is replaced by <code class='prettyprint'>int</code>
              </p>
              <p class='definition'>The process by which the compiler finds matches between a function call and a template is called <strong>argument deduction.</strong></p>
              <p class='debug'>Remember: templates are not functions, they are *patterns* for functions that are then created by the compiler when they see that they are needed.</p>
              <br/>
              <p>Sometimes, the compiler will fail at argument deduction:</p>
              <p class='debug'>Will the following code compile? If so, what will it print?</p>
<pre class='prettyprint'>
  template &lt;typename T&gt;
  T maximum(T i1, T i2) {
      return (i1 &gt; i2) ? i1 : i2;
  }
  
  int main () {
      int i = 22;
      double d = 22.2;
      // [!] Will this work?
      cout &lt;&lt; maximum(i, d) &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>Hmm, so why didn't that work?</p>
              <p class='definition'>When templates define a generic type, e.g. <code class='prettyprint'>typename T</code>, then parameters defined in terms of that generic type must be EXACT matches.</p>
              <p>This means that <code class='prettyprint'>template &lt;typename T&gt; T maximum(T i1, T i2)</code> says, &quot;You can match me as long as T i1 and T i2 are EXACTLY the same type.&quot;</p>
              <p>This strict rule is different than what we're used to because ints and doubles can usually be coerced into one another quite easily.</p>
              <p>Such is not the case for templates, where an exact match is required.</p>
              <p class='definition'>A template <strong>ambiguity</strong> is an error when our compiler fails to deduce the correct argument type for a call to a template function.</p>
              <p>To solve this, we can give our compiler a hint as to which implementation we want to use; we do this in our function call by saying:</p>
<pre class='prettyprint'>
  template &lt;typename T&gt;
  T maximum(T i1, T i2) {
      return (i1 &gt; i2) ? i1 : i2;
  }
  
  int main () {
      int i = 22;
      double d = 22.2;
      // [!] Notice the hint we gave to our compiler suggesting
      // that the call to maximum should now expect two doubles,
      // which means we'll simply coerce argument i into a double
      cout &lt;&lt; maximum&lt;double&gt;(i, d) &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>Cool, so that gives us a little more control over our templates arguments, but what about the following:</p>
              <p class='debug'>Examine how maximum is being used below and its intended use with parameters of type ProtoForneyMon. Will the following code compile?</p>
<pre class='prettyprint'>
  class ProtoForneyMon {
      private:
          int m_health;
      public:
          ProtoForneyMon (int h) {
              m_health = h;
          }
          int getHealth () {
              return m_health;
          }
  };
  
  template &lt;typename T&gt;
  T maximum(T i1, T i2) {
      return (i1 &gt; i2) ? i1 : i2;
  }
  
  int main () {
      ProtoForneyMon p1(10), p2(15);
      // [!] I'd like to compare two ProtoForneyMon
      // (the early sketch of the hit-game ForneyMon)
      // and return the health of the one that has more
      cout &lt;&lt; maximum(p1, p2) &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>Well that's a problem... I want my maximum function to behave in a way that's an exception to the template!</p>
              <p>No problem! We'll just create our own definition for how to handle two ProtoForneyMon parameters:</p>
<pre class='prettyprint'>
  // ... ProtoForneyMon defined here ...
  
  template &lt;typename T&gt;
  T maximum(T i1, T i2) {
      return (i1 &gt; i2) ? i1 : i2;
  }
  
  // [!] Overload maximum with an implementation specific
  // to ProtoForneyMon
  int maximum(ProtoForneyMon p1, ProtoForneyMon p2) {
      int h1 = p1.getHealth(),
          h2 = p2.getHealth();
      return (h1 &gt; h2) ? h1 : h2;
  }
  
  int main () {
      ProtoForneyMon p1(10), p2(15);
      cout &lt;&lt; maximum(p1, p2) &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>Nice, but why didn't my compiler try to perform argument deduction using the template and still blow up?</p>
              <p class='definition'>
                The compiler will always check for explicit function specializations (no templating) for function call matches before attempting to perform type deduction using a function
                template.
              </p>
              <br/>
            </div>
            <hr/>
            
            
            <br/>
            <div id='partialTemplates' class='scrollspy-element' scrollspy-title='Partial Templates'></div>
            <h1>Partial Templates</h1>
            <div>
              <p>So far we've seen templates where all parameter types are generic, but it's also possible to mingle generic types and explicit ones.</p>
              <p>Let's use this section to develop the maxInArray function, which takes in an array of some generic type and then returns the maximum element.</p>
<pre class='prettyprint'>
  template &lt;typename T&gt;
  T maximum(T i1, T i2) {
      return (i1 &gt; i2) ? i1 : i2;
  }
  
  template &lt;typename T&gt;
  T maxInArray(T* arr, int size) {
      if (size &lt;= 0) {
          return NULL;
      }
  
      // Seed our max with the first
      // element
      T currentMax = arr[0];
      for (int i = 1; i &lt; size; i++) {
          currentMax = maximum(currentMax, arr[i]);
      }
      return currentMax;
  }
  
  int main () {
      int i[] = {4, 5, 2, 3};
      cout &lt;&lt; maxInArray(i, 4) &lt;&lt; endl;
  
      string s[] = {"max", "me", "now"};
      cout &lt;&lt; maxInArray(s, 3) &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>I might also want to be able to provide multiple generic types in a function definition, like comparing two arrays for equivalence.</p>
              <p>Let's make an arraysEqual function that is designed to compare two arrays of generic types that support the equivalence operation:</p>
<pre class='prettyprint'>
  template &lt;typename Type1, typename Type2&gt;
  bool arraysEquivalent (Type1* arr1, Type2* arr2, int size) {
      for (int i = 0; i &lt; size; i++) {
          if (arr1[i] != arr2[i]) {
              return false;
          }
      }
      return true;
  }
  
  int main () {
      int i[] = {48, 49, 50, 51};
      char c[] = {'0', '1', '2', '3'};
      cout &lt;&lt; arraysEquivalent(i, c, 4) &lt;&lt; endl;
  
      double d[] = {48, 49.5, 50.3, 51.2};
      cout &lt;&lt; arraysEquivalent(i, d, 4) &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>
                Remembering that templates are patterns for functions, we see that the compiler deduced Type1 -> int and Type2 -> char in the first call to arraysEquivalent, and
                then deduced Type1 -> int and Type2 -> double in the second call.
              </p>
              <br/>
              <h3>Summary</h3>
              <p>When designing function templates, we need to double check three key points for our function calls, pretending we're the compiler trying to make sense of the templates:</p>
              <ul class='indent-1'>
                <li><p>
                  The call must match a template; if it doesn't, we either need to create an explicit specification to be compatible with the argument types, or give our compiler a template hint
                  in the function call
                </p></li>
                <li><p>
                  Once a match has been made (successful argument deduction), the matching template's code must compile; recall that our ProtoForneyMon matched the maximum template, but
                  the maximum function compared its parameters using the '&gt;' operator, which was not defined for two ProtoForneyMon.
                </p></li>
                <li><p>
                  The resulting function, once matched and compiled, must perform the intended behavior; the maximum of two pointer addresses may not behave as intended if the pointers are
                  to elements in different arrays (for example)!
                </p></li>
              </ul>
              
              <br/>
              <h3>Miscellany</h3>
              <p>A couple last remarks that don't fit well into any other section:</p>
              <p class='definition'>
                Attempt to make template function parameters passed by constant reference where possible; since the function could possibly work on large, user-defined
                types as well as built-in types, the cost of passing parameters by value can be significant.
              </p>
              <p class='definition'>
                If you need to initialize a generic type to the &quot;0&quot; equivalent defined by the class (e.g. 0 for ints, &quot;&quot; for strings) you can
                simply declare (for typename T): T();
              </p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='classTemplates' class='scrollspy-element' scrollspy-title='Class Templates'></div>
            <h1>Class Templates</h1>
            <div>
              <p>Just as we have templates for different function parameters, so can we have templates for our own classes!</p>
              <p>This means that whenever I create a new object of a particular type, I can define a type to use for the generic type described in the class template.</p>
              <p>We've already seen this in action with the Standard Template Library (STL) stacks, like from the start of this lecture:</p>
<pre class='prettyprint'>
  int main () {
      stack&lt;int&gt; intsOnInts;
      intsOnInts.push(4);
      intsOnInts.push(20);
      intsOnInts.push(-2);
  
      stack&lt;string&gt; weave;
      weave.push("bad");
      weave.push("puns");
      weave.push("return");
  }
</pre>
              <p>We know, then, that the stack class must have a class template that allows us to use stack in conjunction with whatever types we want (int and string in our example).</p>
              <br/>
              <p class='definition'>Similar to function templates, <strong>class templates</strong> allow us to define a multitude of classes from a single pattern.</p>
              <p>The syntax is the same as function templates, with one exception; let's look at a simple example:</p>
<pre class='prettyprint'>
  template &lt;typename Type1, typename Type2&gt;
  class TwoTypes {
      private:
          Type1 m_t1;
          Type2 m_t2;
      public:
          TwoTypes (Type1 t1, Type2 t2) {
              m_t1 = t1;
              m_t2 = t2;
          }
          
          // [!] What is being returned here?
          // Can we predict what a given argument
          // deduction will resolve to?
          Type1 arbitraryFunc () {
              return m_t1 * m_t2;
          }
  };
  
  int main () {
      TwoTypes&lt;int, int&gt; tII(2, 3);
      cout &lt;&lt; tII.arbitraryFunc() &lt;&lt; endl;
  
      // [!] This line may give you warnings;
      // do you see why?
      TwoTypes&lt;bool, double&gt; tBD(true, 2.3);
      cout &lt;&lt; tBD.arbitraryFunc() &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>No surprises there, we're used to templating; there's just one issue if we try to define member functions outside of the class definition:</p>
<pre class='prettyprint'>
  template &lt;typename Type1, typename Type2&gt;
  class TwoTypes {
      private:
          Type1 m_t1;
          Type2 m_t2;
      public:
          TwoTypes (Type1 t1, Type2 t2);
          Type1 arbitraryFunc ();
  };
  
  // [!] Observe; I need to list the template types above
  // each function definition
  template &lt;typename Type1, typename Type2&gt;
  // [!] Furthermore, I need to define that this is a function
  // on a TwoTypes object with template types &lt;Type1, Type2&gt;
  TwoTypes&lt;Type1, Type2&gt;::TwoTypes (Type1 t1, Type2 t2) {
      m_t1 = t1;
      m_t2 = t2;
  }
  
  template &lt;typename Type1, typename Type2&gt;
  Type1 TwoTypes&lt;Type1, Type2&gt;::arbitraryFunc () {
      return m_t1 * m_t2;
  }
  
  int main () {
      TwoTypes&lt;int, int&gt; tII(2, 3);
      cout &lt;&lt; tII.arbitraryFunc() &lt;&lt; endl;
  
      TwoTypes&lt;bool, double&gt; tBD(true, 2.3);
      cout &lt;&lt; tBD.arbitraryFunc() &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>So, just make sure you treat any template member function definitions outside of the class definition as though they were blind to the template types that the class was created with.</p>
              <p>That was a nice sentence.</p>
              <br/>
              <p>As a final note, you should be aware that you can program the same explicit specification for template member functions that we did for template functions.</p>
              <p>For example, if I wanted TwoTypes' arbitraryFunc to handle bools specially, I could write:</p>
<pre class='prettyprint'>
  template &lt;typename Type1, typename Type2&gt;
  class TwoTypes {
      private:
          Type1 m_t1;
          Type2 m_t2;
      public:
          TwoTypes (Type1 t1, Type2 t2);
          Type1 arbitraryFunc ();
  };
  
  template &lt;typename Type1, typename Type2&gt;
  TwoTypes&lt;Type1, Type2&gt;::TwoTypes (Type1 t1, Type2 t2) {
      m_t1 = t1;
      m_t2 = t2;
  }
  
  template &lt;typename Type1, typename Type2&gt;
  Type1 TwoTypes&lt;Type1, Type2&gt;::arbitraryFunc () {
      return m_t1 * m_t2;
  }
  
  // [!] 2 Bool specification
  bool TwoTypes&lt;bool, bool&gt;::arbitraryFunc () {
      cout &lt;&lt; "[Bool specification]" &lt;&lt; endl;
      return m_t1 || m_t2;
  }
  
  int main () {
      TwoTypes&lt;int, int&gt; tII(2, 3);
      cout &lt;&lt; tII.arbitraryFunc() &lt;&lt; endl;
  
      TwoTypes&lt;bool, bool&gt; tBD(true, false);
      cout &lt;&lt; tBD.arbitraryFunc() &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>And that's all we have to say about templates for now! Handy eh?</p>
              <p>Not a whole lot new under the sun, but you have some new coding tools under your belt to simplify otherwise bulky code.</p>
            </div>
            <hr/>
            
            
            <a class='btn btn-default pull-right hidden-print' href='javascript:window.print();'>
              <span class='glyphicon glyphicon-print'></span>
              &nbsp; PDF / Print
            </a>
            
          </div>
          <!-- END PRESENTATION CONTENT -->
          
          <!-- MATERIALS FROM CLASS: -->
          
          <!-- TODO: Class Templates -->
            <!-- TODO: again, we can define a *pattern* for class definitions -->
            <!-- TODO: template <typename T> class Stack { ... } -->
              <!-- TODO: each member function definition needs to have that template definition as well: -->
              <!-- TODO: template <typename T> Stack<T>::pop () { ... } -->
              <!-- TODO: The constructor need not specify the parameterization -->
              <!-- TODO: template <typename T> Stack::Stack () { ... } -->
            <!-- TODO: can have a stack of ints class that we want to abstract into a stack of arbitrary type -->
            <!-- TODO: can also define member functions in terms of special case handling; e.g., Stack<Coord>::Stack () { ... } vs. Stack<int>::Stack () { ... } -->
              
        </div>
      </div>
      <!-- END MAIN CONTENT -->
      
      
      
    </div>
    <!-- END WRAPPER -->
    
    <!-- BEGIN FOOTER -->
    <div id="footer">
      <div class="container">
        <div class="col-md-12 text-center">
          
        </div>
      </div>
    </div>
    <!-- END FOOTER -->
    
  </body>
</html>
