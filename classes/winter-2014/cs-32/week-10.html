
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <title>Andrew Forney - UCLA CS</title>
    <link href="../../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../../../css/magic-bootstrap.css" rel="stylesheet" type="text/css">
    <link href="../../../css/main.css" rel="stylesheet" type="text/css">
    <script src="../../../js/lib/jquery-2.0.3.min.js"></script>
    <script src="../../../js/lib/bootstrap.min.js"></script>
    <script src="../../../js/lib/expanding.js"></script>
    <script src="../../../js/lib/chart.min.js"></script>
    <script src="../../../js/display/general/general-display.js"></script>
    <script src="week-7-display.js"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
  </head>
  
  <body data-spy="scroll" data-target="#scrollspy">
    
    <!-- BEGIN WRAP -->
    <div id="wrap">
      
      <!-- BEGIN NAVIGATION -->
      <nav class='navbar navbar-default' role='navigation'>
        <div class='nav-accent'></div>
        <div class='container'>
          <div class='row'>
            <div class='col-md-12'>
              <div class='navbar-header'>
                <button class='navbar-toggle' type='button' data-toggle='collapse' data-target='.navbar-main-collapse'>
                  <span class='sr-only'>Toggle Navigation</span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                </button>
                <a class='navbar-brand' href='/~forns/'>
                  <span id='brand-text'>
                    Andrew Forney
                  </span>
                </a>
              </div>
              
              <div id='nav-main' class='collapse navbar-collapse navbar-main-collapse'>
                <ul class='nav navbar-nav navbar-right'>
                  
                  <li>
                    <a href='/~forns/about.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-user'></span>
                      </div>
                      <p class='text-center'>About</p>
                    </a>
                  </li>
                  
                  <li class='active'>
                    <a href='/~forns/classes.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-book'></span>
                      </div>
                      <p class='text-center'>Classes</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/contact.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-comment'></span>
                      </div>
                      <p class='text-center'>Contact</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/publications.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-file'></span>
                      </div>
                      <p class='text-center'>Publications</p>
                    </a>
                  </li>
                  
                </ul>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <!-- END NAVIGATION -->
      
      <!-- BEGIN MAIN CONTENT -->
      <div id="main-content" class="container">
        <div class="row">
          
          <!-- BEGIN SCROLLSPY -->
          <div class='col-md-2 hidden-sm hidden-xs'>
            <div class="bs-sidebar hidden-print affix" role="complementary">
              <ul id='scrollspy' class="nav bs-sidenav">
              </ul>
            </div>
          </div>
          <!-- END SCROLLSPY -->
          
          <!-- BEGIN PRESENTATION CONTENT -->
          <div class='col-md-10 presentation-content' role='main'>
            
            <ol class="breadcrumb hidden-print">
              <li><a href="../../../classes.html">Classes</a></li>
              <li><a href="./cs-32.html">Winter14 CS32</a></li>
              <li class="active">Week 10</li>
            </ol>
            
            
            <div id='review' class='scrollspy-element' scrollspy-title='Review'></div>
            <h1>Practice from Last Week</h1>
            <div>
            </div>
            <hr/>
            
            
            <br/>
            <div id='hash' class='scrollspy-element' scrollspy-title='Hash Tables'></div>
            <h1>Hash Tables</h1>
            <div>
              <p>If you're me and you're looking for something at a supermarket, you'll probably wander aimlessly, looking at each row until you find it.</p>
              <p>Yet, if you ask a store employee, you'll find that, for the most part, they'll know exactly which row your item is in without having to look!</p>
              <p>(I, of course, never ask because male ego, etc.)</p>
              <p>Now to bring the analogy home, it'd be nice if we had some &quot;store employee&quot; with our data structure collections that could tell tell us where to look for a query.</p>
              <p class='definition'>
                A <strong>hash table</strong> provides us with a means of storing data structures into certain buckets such that we can consult a hash function to determine where a particular item
                should go (for insertion) or where it might already live (for search).
              </p>
              <p class='definition'>For a given value to store or a query to a hash table, the <strong>hash function</strong> tells us which bucket to store it in / look in.</p>
              <br/>
              <p>So, to unpack those definitions a bit:</p>
              <ul class='indent-1'>
                <li><p>The hash table is like the grocery store in our analogy.</p></li>
                <li><p>The hash function is like the employee that we ask which aisle a particular item is in that we're looking for.</p></li>
                <li><p>The hash buckets are like the aisles of the grocery store.</p></li>
              </ul>
              <p>So why is this useful?</p>
              <p>
                Well, if we had about 1000 items we needed to store, and 1000 buckets in which to store them, then assuming we chose a good hash function to evenly divide up the items into buckets, we
                could perform insertion and search in near constant time! O(1), wow!
              </p>
              <p>
                This is because we reduce the possible set of matches down to only those contents of a particular bucket, which is, if the items are uniformly distributed, going to be very small
                compared to the original collection.
              </p>
              <p>Constant time is the gold standard of data structures and you're saying it's possible?! Let us learn of these wonderous devices by building a simple one of our own.</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/hash-0.png' />
              </div>
              
              <br/>
              <h3>The Hash Table</h3>
              <p>Let's begin by designing our hash table.</p>
              <p class='definition'>A hash table needs buckets that are accessible by index.</p>
              <br/>
              <p class='question' name='hash-q0'>Why do our hash buckets need to be accessible by index, and what data structure what you suggest to use for our buckets?</p>
              <p class='answer' name='hash-q0'>
                If we want constant time lookup and search, we'll need random access or else we'd have to traverse some number of Node-like objects to reach our goal bucket. Also, it's convenient
                for a hash function to only hash items to integer ids. So, for the purposes of this example, we'll use a vector.
              </p>
              <br/>
              <p>OK, let's define our HashTable class below:</p>
<pre class='prettyprint'>
  template &lt;typename T&gt;
  class HashTable {
      private:
          // LOL "BUCKET LIST"
          vector&lt;list&lt;T&gt;&gt; buckets;
  };
</pre>
              <br/>
              <p>Well that's dull so far...</p>
              <p>Note we use (for this example) a vector for the buckets (enable random access) and lists for the individual bucket contents.</p>
              <p>We'll template our HashTable so we can store different stuff.</p>
              <p>Now, for the constructor, how many buckets do we want to start it off with?</p>
              <p class='question' name='hash-q1'>What is the tradeoff for having more or fewer buckets in our hash table?</p>
              <p class='answer' name='hash-q1'>
                More buckets means that fewer items will be in each bucket (if our hash function performs a uniform distribution of the items) at the cost of having to take up more space in memory.
              </p>
              <br/>
              <p>So, let's start off at, say, 1,000 buckets.</p>
<pre class='prettyprint'>
  template &lt;typename T&gt;
  class HashTable {
      private:
          int MAX_BUCKETS;
          vector&lt;list&lt;T&gt;&gt; buckets;
      public:
          HashTable (): MAX_BUCKETS(1000) {
              // Start off the buckets with MAX_BUCKETS
              buckets.resize(MAX_BUCKETS);
          }
  };
</pre>
              <br/>
              <p>Alright, the stage is set... let's talk about hash functions.</p>
              
              <br/>
              <h3>Hash Functions</h3>
              <p>Hash functions act as our &quot;oracles&quot; that tell us which bucket a particular item should go in.</p>
              <p>They receive as input whatever item we're trying to store or lookup and output an int index somewhere between [0, b), where b is the number of buckets.</p>
              <p>There are some properties of hash functions we need to satisfy...</p>
              <p class='definition'>Hash functions need to be fast!</p>
              <br/>
              <p>
                If our hash function crawls wikipedia for articles on obscure topics, converts every character in those articles to its character code equivalent, adds them, and then mods them by the biggest
                prime number that will fit things neatly into our buckets... we're probably gonna have a bad time (literally).
              </p>
              <p>So, we want something that's simple, quick, and satisfies this other property:</p>
              <p class='definition'>Hash functions need to evenly distribute our items into buckets.</p>
              <br/>
              <p>If our buckets start to hold too many items, then the hash table will be pretty useless... we'll just have a linear search internal to our lists!</p>
              <p>So, we need to determine a way to, pretty uniquely, determine what item goes into what bucket!</p>
              <p class='definition'>When a hash function maps inputs to the same bucket, we call that a <strong>collision</strong>.</p>
              <br/>
              <p>Generally, we want to avoid collisions because they hurt.</p>
              <p>But seriously, the more collisions we have, the more our complexity suffers because it means we have to find values within our lists.</p>
              <p>A last property our hash functions should have:</p>
              <p class='definition'>
                Hash functions should be <strong>deterministic</strong>, meaning that if value A maps to bucket B in one call to our hash function, then it should map to bucket B in future calls as well.
              </p>
              <br/>
              <p>Keeping this in mind, let's propose a couple of hash functions for our HashTable.</p>
              <br/>
              <p class='example'>Judge whether or not the following is a good hash function:</p>
<pre class='prettyprint'>
  unsigned int hash (int toHash) {
      return toHash % 2;
  }
</pre>
              <br/>
              <p class='example'>Judge whether or not the following is a good hash function:</p>
<pre class='prettyprint'>
  unsigned int hash (string toHash) {
      unsigned int result = 0;
      for (int i = 0; i &lt; toHash.length(); i++) {
          result += toHash[i];
      }
      return result % rand();
  }
</pre>
              <br/>
              <p class='example'>Judge whether or not the following is a good hash function:</p>
<pre class='prettyprint'>
  unsigned int hash (string toHash) {
      unsigned int result = 0;
      for (int i = 0; i &lt; toHash.length(); i++) {
          result = result * 101 + toHash[i];
      }
      return result % MAX_BUCKETS;
  }
</pre>
              <br/>
              <p>This last one isn't bad; it's deterministic, simple, and stays in the range of our max number of buckets.</p>
              <p class='question' name='hash-q1-1'>Why did I choose to multiply by 101? What is special about the number 101 (or numbers like it)?</p>
              <p class='answer' name='hash-q1-1'>
                It's prime! When we multiply by a prime number, the chances of getting a unique result are higher because of the lack of factors. This helps us distribute keys to our buckets.
              </p>
              <br/>
              <p>Alright, so let's add that to our HashTable!</p>
              <p>We'll make it private because for this example, only our HashTable functions will care about the hash.</p>
<pre class='prettyprint'>
  template &lt;typename T&gt;
  class HashTable {
      private:
          int MAX_BUCKETS;
          vector&lt;list&lt;T&gt;&gt; buckets;
  
          // NOTE: If we want to be able to handle other
          // template types than strings for T, we'd need
          // other, more generalized hash functions...
          unsigned int hash (string toHash) {
              unsigned int result = 0;
              for (int i = 0; i &lt; toHash.length(); i++) {
                  result = result * 101 + toHash[i];
              }
              return result % MAX_BUCKETS;
          }
  
      public:
          HashTable (): MAX_BUCKETS(1000) {
              // Start off the buckets with MAX_BUCKETS
              buckets.resize(MAX_BUCKETS);
          }
  };
</pre>
              <br/>
              <p>It's coming along!</p>
              <p>Let's examine inserting items into our HashTable.</p>
              
              <br/>
              <h3>HashTable Insertion</h3>
              <p>So now that we have our hash function and our buckets with their lists, let's define our insertion behavior.</p>
              <p class='example'>Complete the HashTable's insertion function below:</p>
<pre class='prettyprint'>
  void insert (T toInsert) {
    // [!] Push toInsert to the back of the list that the
    // hash function gives you from input toInsert
    buckets[ ??? ].push_back(toInsert);
  }
</pre>
              <br/>
              <p class='debug'>Warning! The above insert function is missing something? What is it?</p>
              <p>OK we'll deal with that in a moment...</p>
              <p>I'll provide you with a neat print function just to display some syntactic sugaring for a printout:</p>
<pre class='prettyprint'>
  void print () {
      for (int i = 0; i &lt; buckets.size(); i++) {
          list&lt;T&gt;::iterator it = buckets[i].begin();
          if (buckets[i].empty()) {
              continue;
          }
          cout &lt;&lt; "=== Bucket[ " &lt;&lt; i &lt;&lt; " ] ===" &lt;&lt; endl;
          while (it != buckets[i].end()) {
              cout &lt;&lt; *it++ &lt;&lt; endl;
          }
      }
  }
</pre>
              <br/>
              <p>OK, so now we have the following HashTable class and a nice little test script:</p>
<pre class='prettyprint'>
  template &lt;typename T&gt;
  class HashTable {
      private:
          int MAX_BUCKETS;
          vector&lt;list&lt;T&gt;&gt; buckets;
  
          unsigned int hash (string toHash) {
              unsigned int result = 0;
              for (int i = 0; i &lt; toHash.length(); i++) {
                  result = result * 101 + toHash[i];
              }
              return result % MAX_BUCKETS;
          }
  
      public:
          HashTable (): MAX_BUCKETS(1000) {
              buckets.resize(MAX_BUCKETS);
          }
          void insert (T toInsert) {
              buckets[HashTable::hash(toInsert)].push_back(toInsert);
          }
          void print () {
              for (int i = 0; i &lt; buckets.size(); i++) {
                  list&lt;T&gt;::iterator it = buckets[i].begin();
                  if (buckets[i].empty()) {
                      continue;
                  }
                  cout &lt;&lt; "=== Bucket[ " &lt;&lt; i &lt;&lt; " ] ===" &lt;&lt; endl;
                  while (it != buckets[i].end()) {
                      cout &lt;&lt; *it++ &lt;&lt; endl;
                  }
              }
          }
  };
  
  int main () {
      HashTable&lt;string&gt; hashy;
      hashy.insert("To");
      hashy.insert("Hash");
      hashy.insert("Or");
      hashy.insert("Not");
      hashy.insert("To");
      hashy.insert("Hash");
      hashy.print();
  }
</pre>
              <br/>
              <p>
                Now, the issue with our insert is that it currently allows for duplicate keys... we can't have this behavior in a hash table because it would be ambiguous to talk about a key (which is
                meant to be unique) when there are multiple instances of that key.
              </p>
              <p>Let's implement our hasKey function below:</p>
              <p class='debug'>
                NOTE: If we were really designing a HashTable class, we'd probably want to implement a HashTable iterator, but since this is an intro example, we'll reduce the find functionality
                to just a boolean return function.
              </p>
<pre class='prettyprint'>
  bool hasKey (T query) {
      // Store a pointer to the bucket's list
      list&lt;T&gt;* lPtr = &amp;buckets[hash(query)];
      // Start an iterator at it's beginning
      list&lt;T&gt;::iterator it = lPtr-&gt;begin();
      // Search linearly for the query item
      while (it != lPtr-&gt;end()) {
          if (*it == query) {
              break;
          }
      }
      // Return whether the iterator found a
      // match or not
      return it != lPtr-&gt;end();
  }
</pre>
              <p>Now, we can fix our insertion function to not add duplicates!</p>
<pre class='prettyprint'>
  void insert (T toInsert) {
      if (hasKey(toInsert)) {
          return;
      }
      buckets[HashTable::hash(toInsert)].push_back(toInsert);
  }
</pre>
              <p>Now if we run our previous test main function, we see that duplicate keys are not added, just as we'd like. Cool!</p>
              
              <br/>
              <h3>Hash Table Complexities</h3>
              <p>So it might be clear how we're able to find a bucket in constant time (random access of vector + hash function), but why is searching the bucket list considered average case constant?</p>
              <p>Well let's look at a certain property of hash tables:</p>
              <p class='definition'>The <strong>load factor</strong> of a hash table is the ratio of the number of items stored in total divided by the number of buckets.</p>
              <br/>
              <p>So, the lower the load factor, and assuming our hash function is doing a good job of evenly distributing keys across buckets, the faster our lookup in each list is going to be!</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/hash-1.png' />
              </div>
              <hr/>
              <p>We see that a hash table with a ton of items and few buckets will have a large load factor and nearing linear lookup and insertion time.</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/hash-2.png' />
              </div>
              <p>The solution that modern hash tables use: create more buckets whenever the load factor gets too high!</p>
              <p>Assuming that our hash function is uniformly distributing keys, this puts a *constant upper bound* on the number of items in any given bucket list. Thus the O(1).</p>
              
              <br/>
              <h3>Hash Table Sorting</h3>
              <p>With binary search trees, obtaining a sorted list of the items was trivial: an inorder traversal...</p>
              <p>With hash tables, we don't have the same luxury of structure since our hash function threw keys all over the place.</p>
              <p class='definition'>With hash tables, our concern is less about sorting values than it is about quickly storing and looking them up...</p>
              <br/>
              <p>Just like STL lists don't have a find function because it's a rather wonky operation taking O(n), so is a sort operation somewhat auxiliary to the hash table purpose.</p>
              <p>So what's a viable work-around for implementing a hash table sort?</p>
              <p class='question' name='hash-q2'>Assume we have iterators for our hash tables... how might we use these to sort our keys?</p>
              <p class='answer' name='hash-q2'>
                You could, upon a sort function call, simply create some other data structure (like a BST) comprised of pointers to the values in the hash table, which could then give a nice
                ordering for the values currently in the hash table.
              </p>
              
              <br/>
              <h3>#include &lt;unordered_set&gt;</h3>
              <p>The STL version of a hash table is an unordered_set. You can use it in the following way:</p>
<pre class='prettyprint'>
  int main () {
      unordered_set&lt;int&gt; ui;
      
      // You can insert keys
      ui.insert(1);
      ui.insert(17);
      ui.insert(12);
      ui.insert(20);
  
      // You can define iterators and look for values
      unordered_set&lt;int&gt;::iterator it = ui.find(1);
  
      // [!] WARNING: Will the following necessarily print
      // out 1, 12, 17, 20 in order?
      it = ui.begin();
      while (it != ui.end()) {
          cout &lt;&lt; *it++ &lt;&lt; endl;
      }
  
      // You can even print out how many buckets it has!
      cout &lt;&lt; "Buckets: " &lt;&lt; ui.bucket_count() &lt;&lt; endl;
  
      // And the load factor!
      cout &lt;&lt; "Load factor: " &lt;&lt; ui.load_factor() &lt;&lt; endl;
  
      // And of course, clear it
      ui.clear();
  }
</pre>
              <br/>
              <p>So those are hash tables!</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='heaps' class='scrollspy-element' scrollspy-title='Heaps'></div>
            <h1>Heaps</h1>
            <div>
              <p>Let's talk about a new tree data structure. The heap!</p>
              <p class='debug'>WARNING: The heap data structure is on no way related to the heap where dynamically allocated variables are stored!</p>
              <p>Such unfortunate naming schemas in computer science... it's not like humans have infinite generative language capacities or anything...</p>
              <p>To break the ice, here's another topical XKCD because you guys seem to love these as much as I do:</p>
              <a href='https://xkcd.com/835/' target='_blank'>
                <div class='text-center fit-pres'>
                  <img src='http://imgs.xkcd.com/comics/tree.png' />
                </div>
              </a>
              <br/>
              <p class='definition'>A <strong>heap</strong> (generally referring to a max heap) is a special type of tree where all subtrees of a given Node have values less than or equal to that Node's.</p>
              <br/>
              <p>In the above comic, we see that the heap of presents at the base has the largest at the top with children decreasing in size with greater depth.</p>
              <p>Our discussion, however, will be restricted to binary heaps, which have some additional restrictions.</p>
              <p class='definition'>A <strong>binary heap</strong> is a complete binary tree where all subtrees of a given Node have values less than or equal to that Node's.</p>
              <br/>
              <p>So we're restricting the number of children any Node can have to 2, AND requiring the binary tree be complete.</p>
              <p class='definition'>
                A <strong>complete</strong> binary tree is a binary tree with all full levels, except for possibly the last level, in which case it is required that the Nodes be filled from left to right without
                any spaces.
              </p>
              <br/>
              <p class='example'>Is the following binary tree complete? Is it a heap?</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-0.png' />
              </div>
              <hr/>
              <p class='example'>Is the following binary tree complete? Is it a heap?</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-1.png' />
              </div>
              <hr/>
              <p class='example'>Is the following binary tree complete? Is it a heap?</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-2.png' />
              </div>
              <hr/>
              <p class='example'>Is the following binary tree complete? Is it a heap?</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-3.png' />
              </div>
              <br/>
              <p class='question' name='heap-q0'>Is a single-node tree a heap?</p>
              <p class='answer' name='heap-q0'>
                Yes! It must be complete because the last (and only) level is full, and its value must be larger than its subtrees because it has no subtrees!
              </p>
              <br/>
              <p class='question' name='heap-q1'>How many unique structural configurations (ignoring node values) are there for a complete binary tree with N nodes?</p>
              <p class='answer' name='heap-q1'>
                Just 1! If you were to change the position of any node in the structure, it would cease to be complete.
              </p>
              
              <br/>
              <h3>Heap Properties</h3>
              <p>Heaps have some nice properties, for example:</p>
              <p class='definition'>The largest value of a (max)heap is always at the root, and therefore accessible with constant time!</p>
              <br/>
              <p>One of the most useful aspects of heaps is that, because they are complete trees, we can represent them as arrays to enable random access!</p>
              <p>This is nice, as we'll see in a moment, because we can access any &quot;node&quot; in constant time, a distinct advantage over the traditionally linked Binary Tree Nodes.</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-4.png' />
              </div>
              <br/>
              <p>&quot;Nice colors in that graph, Andrew, do you also design children's play equipment?&quot;</p>
              <p>Shhh! It was illustrative!</p>
              
              <br/>
              <p class='definition'>We know that in the array representation of a heap, the root must always be at index 0.</p>
              <br/>
              <p>But how do we determine the children and parent of any given index in an array?</p>
              <p>Well, since it's a complete tree, we have a simple computational way of finding these indexes...</p>
              <p class='question' name='heap-q2'>Given the index n of a &quot;Node&quot; in our conceptual tree structure, how can I get the index of the parent?</p>
              <p class='answer' name='heap-q2'>
                Index of parent: (n - 1) / 2; (NOTE: this is integer division, so we ignore the decimal of the quotient)
              </p>
              <br/>
              <p>So, we can define a simple functional mapping:</p>
<pre class='prettyprint'>
  int getParent (int index) {
      return (index - 1) / 2;
  }
</pre>
              <br/>
              <p>Getting the left and right children is a similar mechanical exercise:</p>
<pre class='prettyprint'>
  // Child is either 'L' or 'R'
  int getChild (int index, char child) {
      int result = (index * 2) + 1;
      if (child == 'R') {
          result++;
      }
      return result;
  }
</pre>
              <br/>
              <p class='example'>Draw the binary tree representation of the following heap:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-5.png' />
              </div>
              <br/>
              <p>Now that we have the basic tools down, we're ready to go over some heap algorithms!</p>
              
              <br/>
              <h3>Insertion</h3>
              <p>After every operation on a heap, we have some general steps: perform the operation and then &quot;reheapify&quot; the binary tree.</p>
              <p>For insertion, that looks like this:</p>
              <ol class='indent-1'>
                <li><p>Create a complete binary tree with the newly inserted node in its proper location as the right-most vacant leaf position on the last level of the tree.</p></li>
                <li><p>Starting at that newly inserted node, bubble upwards ensuring that each node is less than its parent.</p></li>
                <li><p>As soon as a parent is greater than the node we're bubbling, stop--your array is now reheapified! (assuming it was a heap before the insertion).</p></li>
              </ol>
              <p>Let's try an example where we're inserting the node 50 into the heap below:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-6.png' />
              </div>
              <hr/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-7.png' />
              </div>
              <hr/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-8.png' />
              </div>
              <hr/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-9.png' />
              </div>
              <br/>
              <p>Got that?</p>
              <p>Let's make a simple BinaryHeap class with this algorithm!</p>
              <p>I'll start you off...</p>
              <p class='example'>Complete the insert function and its helper, bubbleUp, in our BinaryHeap below:</p>
              <br/>
<pre class='prettyprint'>
  template &lt;typename T&gt;
  class BinaryHeap {
      private:
          vector&lt;T&gt; heap;
  
          // Traversal helpers
          int getParent (int index) {
              return (index - 1) / 2;
          }
          int getChild (int index, char child) {
              int result = (index * 2) + 1;
              if (child == 'R') {
                  result++;
              }
              return result;
          }
  
          // Continues to bubble values up the
          // tree until we find a node that is
          // greater than it
          void bubbleUp (int index) {
              // [!] If we're at the root, then
              // we're done
              if ( ??? ) {return;}
  
              // [!] Get parent index and store it
              int parent = ???;
  
              // [!] If the parent's value is less than
              // the current one's...
              if ( ??? ) {
                  // [!] ...then we swap them...
                  ???
  
                  // [!] ...and recurse on the new parent!
                  bubbleUp(parent);
              }
  
          }
  
      public:
          void print () {
              for (int i = 0; i &lt; heap.size(); i++) {
                  cout &lt;&lt; heap[i] &lt;&lt; endl;
              }
          }
  
          void insert (T toInsert) {
              // [!] Add new element to next available
              // slot in the binary tree
              ???
  
              // [!] Start bubbling values up from
              // the newly added value
              ???
          }
  };
</pre>
              <br/>
              <p>Now let's test it using our example from before!</p>
              <br/>
<pre class='prettyprint'>
  int main () {
      BinaryHeap&lt;int&gt; b;
      b.insert(25);
      b.insert(10);
      b.insert(20);
      b.insert(8);
  
      cout &lt;&lt; "BEFORE adding 50:" &lt;&lt; endl;
      b.print();
  
      b.insert(50);
      cout &lt;&lt; "AFTER adding 50:" &lt;&lt; endl;
      b.print();
  }
</pre>
              <br/>
              <p>Great! On to deletion.</p>
              
              <br/>
              <h3>Deletion</h3>
              
            </div>
            <hr/>
            
              
            <a class='btn btn-default pull-right hidden-print' href='javascript:window.print();'>
              <span class='glyphicon glyphicon-print'></span>
              &nbsp; PDF / Print
            </a>
            
          </div>
          <!-- END PRESENTATION CONTENT -->
          
          <!-- MATERIALS FROM CLASS: -->
          
          <!-- TODO: Priority Queues -->
            <!-- TODO: A collection of items where every item has a given priority -->
            <!-- TODO: Whenever you want to take an item out, you take out the item with the highest priority -->
            <!-- TODO: 
              Misleading because we think of queues as just the FIFO data structure, but these queues are simply a special case of priority queues where the priority of each item is simply how
              long it's been in the list
             -->
            <!-- TODO: How to store this notion of a priority queue? -->
              <!-- TODO: Vectors -->
                <!-- TODO: Simple to insert: just stick it at the end O(1) -->
                <!-- TODO: Linear to pull out because we have to check each item for the highest priority O(n) -->
              <!-- TODO: Sorted collection -->
                <!-- TODO: Insertion: could do a binary search to determine where it goes on a vector, but insertion would be O(n) to shift; couldn't do binary search on a list, so also O(n) -->
                <!-- TODO: Simple to pull out because the highest priority is always at the front -->
              <!-- TODO: Binary search tree -->
                <!-- TODO: Lower priority goes in left subtree; higher goes in right -->
                <!-- TODO: Insertion and search are both log(n) time -->
                <!-- TODO: Problem: items being removed will unbalance the tree and require upkeep -->
            <!-- TODO: Properties of a heap: -->
              <!-- TODO: Deletion algorithm: -->
                <!-- TODO: Make a complete binary tree; remove target Node, and promote the bottom-right-most item to the root -->
                <!-- TODO: Trickle down the promoted item -->
                  <!-- TODO: Promote one of the children of whatever you just promoted; choose the largest of the children and promote that -->
                  <!-- TODO: Continue doing this until none of the children are larger than the bubbling Node -->
              <!-- TODO: Better constant of proportionality with binary search trees for insertion and deletion but still O(log(n)) -->
            <!-- TODO: HeapSort -->
              <!-- TODO: Steps -->
                <!-- TODO: 1) Make our data into a heap -->
                <!-- TODO: 2) Swap the root with the farthest leaf to the right -->
                <!-- TODO: 3) Now consider the array holding the elements to have 1 fewer item (effectively chopping off the sorted tail) -->
                <!-- TODO: 4) Re-heapify -->
              <!-- TODO: Complexity: average case log(n) ??? check that out... -->
                
          <!-- TODO: Graphs -->
            <!-- TODO: Simply nodes connected by edges -->
            <!-- TODO: Some graphs are undirected in which edges are just linked, but without any notion of beginning or end -->
            <!-- TODO: Some graphs are directed in which edges have a beginning and a terminus -->
            <!-- TODO: Some graphs can have cycles: cyclic graphs -->
            <!-- TODO: DAGs are directed, acyclic graphs -->
              <!-- TODO: Are all trees graphs and vice versa? -->
              <!-- TODO: DAGs don't really have a root -->
            <!-- TODO: Some algorithms: -->
              <!-- TODO: Topological sort -->
            <!-- TODO: Some representations: -->
              <!-- TODO: Adjacency matrix: 2D array with nodes on each axis and 0s and 1s representing edges between them -->
                <!-- TODO: Problem: lots of wasted space; grows quickly -->
              <!-- TODO: Sparse matrix -->
                <!-- TODO: Every node maps to a list of the other nodes that it connects to -->
          
          <!-- TODO: Review -->
            <!-- TODO: Design a hash function that takes this input and sticks it in these buckets -->
            <!-- TODO: Heapification -->
            <!-- TODO: Heap Sort -->
            <!-- TODO: Scenario based data structure choices and computational complexities -->
          
          <!-- TODO: Summary table of data structures and their different complexities? -->
          
          
        </div>
      </div>
      <!-- END MAIN CONTENT -->
      
          
    </div>
    <!-- END WRAPPER -->
    
    <!-- BEGIN FOOTER -->
    <div id="footer">
      <div class="container">
        <div class="col-md-12 text-center">
          
        </div>
      </div>
    </div>
    <!-- END FOOTER -->
    
  </body>
</html>
