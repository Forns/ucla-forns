
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <title>Andrew Forney - UCLA CS</title>
    <link href="../../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../../../css/magic-bootstrap.css" rel="stylesheet" type="text/css">
    <link href="../../../css/main.css" rel="stylesheet" type="text/css">
    <script src="../../../js/lib/jquery-2.0.3.min.js"></script>
    <script src="../../../js/lib/bootstrap.min.js"></script>
    <script src="../../../js/lib/expanding.js"></script>
    <script src="../../../js/lib/chart.min.js"></script>
    <script src="../../../js/display/general/general-display.js"></script>
    <script src="week-7-display.js"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
  </head>
  
  <body data-spy="scroll" data-target="#scrollspy">
    
    <!-- BEGIN WRAP -->
    <div id="wrap">
      
      <!-- BEGIN NAVIGATION -->
      <nav class='navbar navbar-default' role='navigation'>
        <div class='nav-accent'></div>
        <div class='container'>
          <div class='row'>
            <div class='col-md-12'>
              <div class='navbar-header'>
                <button class='navbar-toggle' type='button' data-toggle='collapse' data-target='.navbar-main-collapse'>
                  <span class='sr-only'>Toggle Navigation</span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                </button>
                <a class='navbar-brand' href='/~forns/'>
                  <span id='brand-text'>
                    Andrew Forney
                  </span>
                </a>
              </div>
              
              <div id='nav-main' class='collapse navbar-collapse navbar-main-collapse'>
                <ul class='nav navbar-nav navbar-right'>
                  
                  <li>
                    <a href='/~forns/about.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-user'></span>
                      </div>
                      <p class='text-center'>About</p>
                    </a>
                  </li>
                  
                  <li class='active'>
                    <a href='/~forns/classes.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-book'></span>
                      </div>
                      <p class='text-center'>Classes</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/contact.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-comment'></span>
                      </div>
                      <p class='text-center'>Contact</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/publications.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-file'></span>
                      </div>
                      <p class='text-center'>Publications</p>
                    </a>
                  </li>
                  
                </ul>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <!-- END NAVIGATION -->
      
      <!-- BEGIN MAIN CONTENT -->
      <div id="main-content" class="container">
        <div class="row">
          
          <!-- BEGIN SCROLLSPY -->
          <div class='col-md-2 hidden-sm hidden-xs'>
            <div class="bs-sidebar hidden-print affix" role="complementary">
              <ul id='scrollspy' class="nav bs-sidenav">
              </ul>
            </div>
          </div>
          <!-- END SCROLLSPY -->
          
          <!-- BEGIN PRESENTATION CONTENT -->
          <div class='col-md-10 presentation-content' role='main'>
            
            <ol class="breadcrumb hidden-print">
              <li><a href="../../../classes.html">Classes</a></li>
              <li><a href="./cs-32.html">Winter14 CS32</a></li>
              <li class="active">Week 10</li>
            </ol>
            
            
            <br/>
            <div id='hash' class='scrollspy-element' scrollspy-title='Hash Tables'></div>
            <h1>Hash Tables</h1>
            <div>
              <p>If you're me and you're looking for something at a supermarket, you'll probably wander aimlessly, looking at each row until you find it.</p>
              <p>Yet, if you ask a store employee, you'll find that, for the most part, they'll know exactly which row your item is in without having to look!</p>
              <p>(I, of course, never ask because male ego, etc.)</p>
              <p>Now to bring the analogy home, it'd be nice if we had some &quot;store employee&quot; with our data structure collections that could tell tell us where to look for a query.</p>
              <p class='definition'>
                A <strong>hash table</strong> provides us with a means of storing data structures into certain buckets such that we can consult a hash function to determine where a particular item
                should go (for insertion) or where it might already live (for search).
              </p>
              <p class='definition'>For a given value to store or a query to a hash table, the <strong>hash function</strong> tells us which bucket to store it in / look in.</p>
              <br/>
              <p>So, to unpack those definitions a bit:</p>
              <ul class='indent-1'>
                <li><p>The hash table is like the grocery store in our analogy.</p></li>
                <li><p>The hash function is like the employee that we ask which aisle a particular item is in that we're looking for.</p></li>
                <li><p>The hash buckets are like the aisles of the grocery store.</p></li>
              </ul>
              <p>So why is this useful?</p>
              <p>
                Well, if we had about 1000 items we needed to store, and 1000 buckets in which to store them, then assuming we chose a good hash function to evenly divide up the items into buckets, we
                could perform insertion and search in near constant time! O(1), wow!
              </p>
              <p>
                This is because we reduce the possible set of matches down to only those contents of a particular bucket, which is, if the items are uniformly distributed, going to be very small
                compared to the original collection.
              </p>
              <p>Constant time is the gold standard of data structures and you're saying it's possible?! Let us learn of these wonderous devices by building a simple one of our own.</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/hash-0.png' />
              </div>
              
              <br/>
              <h3>The Hash Table</h3>
              <p>Let's begin by designing our hash table.</p>
              <p class='definition'>A hash table needs buckets that are accessible by index.</p>
              <br/>
              <p class='question' name='hash-q0'>Why do our hash buckets need to be accessible by index, and what data structure what you suggest to use for our buckets?</p>
              <p class='answer' name='hash-q0'>
                If we want constant time lookup and search, we'll need random access or else we'd have to traverse some number of Node-like objects to reach our goal bucket. Also, it's convenient
                for a hash function to only hash items to integer ids. So, for the purposes of this example, we'll use a vector.
              </p>
              <br/>
              <p>OK, let's define our HashTable class below:</p>
<pre class='prettyprint'>
  template &lt;typename T&gt;
  class HashTable {
      private:
          // LOL "BUCKET LIST"
          vector&lt;list&lt;T&gt;&gt; buckets;
  };
</pre>
              <br/>
              <p>Well that's dull so far...</p>
              <p>Note we use (for this example) a vector for the buckets (enable random access) and lists for the individual bucket contents.</p>
              <p>We'll template our HashTable so we can store different stuff.</p>
              <p>Now, for the constructor, how many buckets do we want to start it off with?</p>
              <p class='question' name='hash-q1'>What is the tradeoff for having more or fewer buckets in our hash table?</p>
              <p class='answer' name='hash-q1'>
                More buckets means that fewer items will be in each bucket (if our hash function performs a uniform distribution of the items) at the cost of having to take up more space in memory.
              </p>
              <br/>
              <p>So, let's start off at, say, 1,000 buckets.</p>
<pre class='prettyprint'>
  template &lt;typename T&gt;
  class HashTable {
      private:
          int MAX_BUCKETS;
          vector&lt;list&lt;T&gt;&gt; buckets;
      public:
          HashTable (): MAX_BUCKETS(1000) {
              // Start off the buckets with MAX_BUCKETS
              buckets.resize(MAX_BUCKETS);
          }
  };
</pre>
              <br/>
              <p>Alright, the stage is set... let's talk about hash functions.</p>
              
              <br/>
              <h3>Hash Functions</h3>
              <p>Hash functions act as our &quot;oracles&quot; that tell us which bucket a particular item should go in.</p>
              <p>They receive as input whatever item we're trying to store or lookup and output an int index somewhere between [0, b), where b is the number of buckets.</p>
              <p>There are some properties of hash functions we need to satisfy...</p>
              <p class='definition'>Hash functions need to be fast!</p>
              <br/>
              <p>
                If our hash function crawls wikipedia for articles on obscure topics, converts every character in those articles to its character code equivalent, adds them, and then mods them by the biggest
                prime number that will fit things neatly into our buckets... we're probably gonna have a bad time (literally).
              </p>
              <p>So, we want something that's simple, quick, and satisfies this other property:</p>
              <p class='definition'>Hash functions need to evenly distribute our items into buckets.</p>
              <br/>
              <p>If our buckets start to hold too many items, then the hash table will be pretty useless... we'll just have a linear search internal to our lists!</p>
              <p>So, we need to determine a way to, pretty uniquely, determine what item goes into what bucket!</p>
              <p class='definition'>When a hash function maps inputs to the same bucket, we call that a <strong>collision</strong>.</p>
              <br/>
              <p>Generally, we want to avoid collisions because they hurt.</p>
              <p>But seriously, the more collisions we have, the more our complexity suffers because it means we have to find values within our lists.</p>
              <p>A last property our hash functions should have:</p>
              <p class='definition'>
                Hash functions should be <strong>deterministic</strong>, meaning that if value A maps to bucket B in one call to our hash function, then it should map to bucket B in future calls as well.
              </p>
              <br/>
              <p>Keeping this in mind, let's propose a couple of hash functions for our HashTable.</p>
              <br/>
              <p class='example'>Judge whether or not the following is a good hash function:</p>
<pre class='prettyprint'>
  unsigned int hash (int toHash) {
      return toHash % 2;
  }
</pre>
              <br/>
              <p class='example'>Judge whether or not the following is a good hash function:</p>
<pre class='prettyprint'>
  unsigned int hash (string toHash) {
      unsigned int result = 0;
      for (int i = 0; i &lt; toHash.length(); i++) {
          result += toHash[i];
      }
      return result % rand();
  }
</pre>
              <br/>
              <p class='example'>Judge whether or not the following is a good hash function:</p>
<pre class='prettyprint'>
  unsigned int hash (string toHash) {
      unsigned int result = 0;
      for (int i = 0; i &lt; toHash.length(); i++) {
          result = result * 101 + toHash[i];
      }
      return result % MAX_BUCKETS;
  }
</pre>
              <br/>
              <p>This last one isn't bad; it's deterministic, simple, and stays in the range of our max number of buckets.</p>
              <p class='question' name='hash-q1-1'>Why did I choose to multiply by 101? What is special about the number 101 (or numbers like it)?</p>
              <p class='answer' name='hash-q1-1'>
                It's prime! When we multiply by a prime number, the chances of getting a unique result are higher because of the lack of factors. This helps us distribute keys to our buckets.
              </p>
              <br/>
              <p>Alright, so let's add that to our HashTable!</p>
              <p>We'll make it private because for this example, only our HashTable functions will care about the hash.</p>
<pre class='prettyprint'>
  template &lt;typename T&gt;
  class HashTable {
      private:
          int MAX_BUCKETS;
          vector&lt;list&lt;T&gt;&gt; buckets;
  
          // NOTE: If we want to be able to handle other
          // template types than strings for T, we'd need
          // other, more generalized hash functions...
          unsigned int hash (string toHash) {
              unsigned int result = 0;
              for (int i = 0; i &lt; toHash.length(); i++) {
                  result = result * 101 + toHash[i];
              }
              return result % MAX_BUCKETS;
          }
  
      public:
          HashTable (): MAX_BUCKETS(1000) {
              // Start off the buckets with MAX_BUCKETS
              buckets.resize(MAX_BUCKETS);
          }
  };
</pre>
              <br/>
              <p>It's coming along!</p>
              <p>Let's examine inserting items into our HashTable.</p>
              
              <br/>
              <h3>HashTable Insertion</h3>
              <p>So now that we have our hash function and our buckets with their lists, let's define our insertion behavior.</p>
              <p class='example'>Complete the HashTable's insertion function below:</p>
<pre class='prettyprint'>
  void insert (T toInsert) {
    // [!] Push toInsert to the back of the list that the
    // hash function gives you from input toInsert
    buckets[ ??? ].push_back(toInsert);
  }
</pre>
              <br/>
              <p class='debug'>Warning! The above insert function is missing something? What is it?</p>
              <p>OK we'll deal with that in a moment...</p>
              <p>I'll provide you with a neat print function just to display some syntactic sugaring for a printout:</p>
<pre class='prettyprint'>
  void print () {
      for (int i = 0; i &lt; buckets.size(); i++) {
          list&lt;T&gt;::iterator it = buckets[i].begin();
          if (buckets[i].empty()) {
              continue;
          }
          cout &lt;&lt; "=== Bucket[ " &lt;&lt; i &lt;&lt; " ] ===" &lt;&lt; endl;
          while (it != buckets[i].end()) {
              cout &lt;&lt; *it++ &lt;&lt; endl;
          }
      }
  }
</pre>
              <br/>
              <p>OK, so now we have the following HashTable class and a nice little test script:</p>
<pre class='prettyprint'>
  template &lt;typename T&gt;
  class HashTable {
      private:
          int MAX_BUCKETS;
          vector&lt;list&lt;T&gt;&gt; buckets;
  
          unsigned int hash (string toHash) {
              unsigned int result = 0;
              for (int i = 0; i &lt; toHash.length(); i++) {
                  result = result * 101 + toHash[i];
              }
              return result % MAX_BUCKETS;
          }
  
      public:
          HashTable (): MAX_BUCKETS(1000) {
              buckets.resize(MAX_BUCKETS);
          }
          void insert (T toInsert) {
              buckets[HashTable::hash(toInsert)].push_back(toInsert);
          }
          void print () {
              for (int i = 0; i &lt; buckets.size(); i++) {
                  list&lt;T&gt;::iterator it = buckets[i].begin();
                  if (buckets[i].empty()) {
                      continue;
                  }
                  cout &lt;&lt; "=== Bucket[ " &lt;&lt; i &lt;&lt; " ] ===" &lt;&lt; endl;
                  while (it != buckets[i].end()) {
                      cout &lt;&lt; *it++ &lt;&lt; endl;
                  }
              }
          }
  };
  
  int main () {
      HashTable&lt;string&gt; hashy;
      hashy.insert("To");
      hashy.insert("Hash");
      hashy.insert("Or");
      hashy.insert("Not");
      hashy.insert("To");
      hashy.insert("Hash");
      hashy.print();
  }
</pre>
              <br/>
              <p>
                Now, the issue with our insert is that it currently allows for duplicate keys... we can't have this behavior in a hash table because it would be ambiguous to talk about a key (which is
                meant to be unique) when there are multiple instances of that key.
              </p>
              <p>Let's implement our hasKey function below:</p>
              <p class='debug'>
                NOTE: If we were really designing a HashTable class, we'd probably want to implement a HashTable iterator, but since this is an intro example, we'll reduce the find functionality
                to just a boolean return function.
              </p>
<pre class='prettyprint'>
  bool hasKey (T query) {
      // Store a pointer to the bucket's list
      list&lt;T&gt;* lPtr = &amp;buckets[hash(query)];
      // Start an iterator at it's beginning
      list&lt;T&gt;::iterator it = lPtr-&gt;begin();
      // Search linearly for the query item
      while (it != lPtr-&gt;end()) {
          if (*it == query) {
              break;
          }
      }
      // Return whether the iterator found a
      // match or not
      return it != lPtr-&gt;end();
  }
</pre>
              <p>Now, we can fix our insertion function to not add duplicates!</p>
<pre class='prettyprint'>
  void insert (T toInsert) {
      if (hasKey(toInsert)) {
          return;
      }
      buckets[HashTable::hash(toInsert)].push_back(toInsert);
  }
</pre>
              <p>Now if we run our previous test main function, we see that duplicate keys are not added, just as we'd like. Cool!</p>
              
              <br/>
              <h3>Hash Table Complexities</h3>
              <p>So it might be clear how we're able to find a bucket in constant time (random access of vector + hash function), but why is searching the bucket list considered average case constant?</p>
              <p>Well let's look at a certain property of hash tables:</p>
              <p class='definition'>The <strong>load factor</strong> of a hash table is the ratio of the number of items stored in total divided by the number of buckets.</p>
              <br/>
              <p>So, the lower the load factor, and assuming our hash function is doing a good job of evenly distributing keys across buckets, the faster our lookup in each list is going to be!</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/hash-1.png' />
              </div>
              <hr/>
              <p>We see that a hash table with a ton of items and few buckets will have a large load factor and nearing linear lookup and insertion time.</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/hash-2.png' />
              </div>
              <p>The solution that modern hash tables use: create more buckets whenever the load factor gets too high!</p>
              <p>Assuming that our hash function is uniformly distributing keys, this puts a *constant upper bound* on the number of items in any given bucket list. Thus the O(1).</p>
              
              <br/>
              <h3>Hash Table Sorting</h3>
              <p>With binary search trees, obtaining a sorted list of the items was trivial: an inorder traversal...</p>
              <p>With hash tables, we don't have the same luxury of structure since our hash function threw keys all over the place.</p>
              <p class='definition'>With hash tables, our concern is less about sorting values than it is about quickly storing and looking them up...</p>
              <br/>
              <p>Just like STL lists don't have a find function because it's a rather wonky operation taking O(n), so is a sort operation somewhat auxiliary to the hash table purpose.</p>
              <p>So what's a viable work-around for implementing a hash table sort?</p>
              <p class='question' name='hash-q2'>Assume we have iterators for our hash tables... how might we use these to sort our keys?</p>
              <p class='answer' name='hash-q2'>
                You could, upon a sort function call, simply create some other data structure (like a BST) comprised of pointers to the values in the hash table, which could then give a nice
                ordering for the values currently in the hash table.
              </p>
              
              <br/>
              <h3>#include &lt;unordered_set&gt;</h3>
              <p>The STL version of a hash table is an unordered_set. You can use it in the following way:</p>
<pre class='prettyprint'>
  int main () {
      unordered_set&lt;int&gt; ui;
      
      // You can insert keys
      ui.insert(1);
      ui.insert(17);
      ui.insert(12);
      ui.insert(20);
  
      // You can define iterators and look for values
      unordered_set&lt;int&gt;::iterator it = ui.find(1);
  
      // [!] WARNING: Will the following necessarily print
      // out 1, 12, 17, 20 in order?
      it = ui.begin();
      while (it != ui.end()) {
          cout &lt;&lt; *it++ &lt;&lt; endl;
      }
  
      // You can even print out how many buckets it has!
      cout &lt;&lt; "Buckets: " &lt;&lt; ui.bucket_count() &lt;&lt; endl;
  
      // And the load factor!
      cout &lt;&lt; "Load factor: " &lt;&lt; ui.load_factor() &lt;&lt; endl;
  
      // And of course, clear it
      ui.clear();
  }
</pre>
              <br/>
              <p>So those are hash tables!</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='heaps' class='scrollspy-element' scrollspy-title='Heaps'></div>
            <h1>Heaps</h1>
            <div>
              <p>Let's talk about a new tree data structure. The heap!</p>
              <p class='debug'>WARNING: The heap data structure is on no way related to the heap where dynamically allocated variables are stored!</p>
              <p>Such unfortunate naming schemas in computer science... it's not like humans have infinite generative language capacities or anything...</p>
              <p>To break the ice, here's another topical XKCD because you guys seem to love these as much as I do:</p>
              <a href='https://xkcd.com/835/' target='_blank'>
                <div class='text-center fit-pres'>
                  <img src='http://imgs.xkcd.com/comics/tree.png' />
                </div>
              </a>
              <br/>
              <p class='definition'>A <strong>heap</strong> (generally referring to a max heap) is a special type of tree where all subtrees of a given Node have values less than or equal to that Node's.</p>
              <br/>
              <p>In the above comic, we see that the heap of presents at the base has the largest at the top with children decreasing in size with greater depth.</p>
              <p>Our discussion, however, will be restricted to binary heaps, which have some additional restrictions.</p>
              <p class='definition'>A <strong>binary heap</strong> is a complete binary tree where all subtrees of a given Node have values less than or equal to that Node's.</p>
              <br/>
              <p>So we're restricting the number of children any Node can have to 2, AND requiring the binary tree be complete.</p>
              <p class='definition'>
                A <strong>complete</strong> binary tree is a binary tree with all full levels, except for possibly the last level, in which case it is required that the Nodes be filled from left to right without
                any spaces.
              </p>
              <br/>
              <p class='example'>Is the following binary tree complete? Is it a heap?</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-0.png' />
              </div>
              <hr/>
              <p class='example'>Is the following binary tree complete? Is it a heap?</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-1.png' />
              </div>
              <hr/>
              <p class='example'>Is the following binary tree complete? Is it a heap?</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-2.png' />
              </div>
              <hr/>
              <p class='example'>Is the following binary tree complete? Is it a heap?</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-3.png' />
              </div>
              <br/>
              <p class='question' name='heap-q0'>Is a single-node tree a heap?</p>
              <p class='answer' name='heap-q0'>
                Yes! It must be complete because the last (and only) level is full, and its value must be larger than its subtrees because it has no subtrees!
              </p>
              <br/>
              <p class='question' name='heap-q1'>How many unique structural configurations (ignoring node values) are there for a complete binary tree with N nodes?</p>
              <p class='answer' name='heap-q1'>
                Just 1! If you were to change the position of any node in the structure, it would cease to be complete.
              </p>
              
              <br/>
              <h3>Heap Properties</h3>
              <p>Heaps have some nice properties, for example:</p>
              <p class='definition'>The largest value of a (max)heap is always at the root, and therefore accessible with constant time!</p>
              <br/>
              <p>One of the most useful aspects of heaps is that, because they are complete trees, we can represent them as arrays to enable random access!</p>
              <p>This is nice, as we'll see in a moment, because we can access any &quot;node&quot; in constant time, a distinct advantage over the traditionally linked Binary Tree Nodes.</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-4.png' />
              </div>
              <br/>
              <p>&quot;Nice colors in that graph, Andrew, do you also design children's play equipment?&quot;</p>
              <p>Shhh! It was illustrative!</p>
              
              <br/>
              <p class='definition'>We know that in the array representation of a heap, the root must always be at index 0.</p>
              <br/>
              <p>But how do we determine the children and parent of any given index in an array?</p>
              <p>Well, since it's a complete tree, we have a simple computational way of finding these indexes...</p>
              <p class='question' name='heap-q2'>Given the index n of a &quot;Node&quot; in our conceptual tree structure, how can I get the index of the parent?</p>
              <p class='answer' name='heap-q2'>
                Index of parent: (n - 1) / 2; (NOTE: this is integer division, so we ignore the decimal of the quotient)
              </p>
              <br/>
              <p>So, we can define a simple functional mapping:</p>
<pre class='prettyprint'>
  int getParent (int index) {
      return (index - 1) / 2;
  }
</pre>
              <br/>
              <p>Getting the left and right children is a similar mechanical exercise:</p>
<pre class='prettyprint'>
  // Child is either 'L' or 'R'
  int getChild (int index, char child) {
      int result = (index * 2) + 1;
      if (child == 'R') {
          result++;
      }
      return result;
  }
</pre>
              <br/>
              <p class='example'>Draw the binary tree representation of the following heap:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-5.png' />
              </div>
              <br/>
              <p>Now that we have the basic tools down, we're ready to go over some heap algorithms!</p>
              
              <br/>
              <h3>Insertion</h3>
              <p>After every operation on a heap, we have some general steps: perform the operation and then &quot;reheapify&quot; the binary tree.</p>
              <p>For insertion, that looks like this:</p>
              <ol class='indent-1'>
                <li><p>Create a complete binary tree with the newly inserted node in its proper location as the right-most vacant leaf position on the last level of the tree.</p></li>
                <li><p>Starting at that newly inserted node, bubble upwards ensuring that each node is less than its parent.</p></li>
                <li><p>As soon as a parent is greater than the node we're bubbling, stop--your array is now reheapified! (assuming it was a heap before the insertion).</p></li>
              </ol>
              <p>Let's try an example where we're inserting the node 50 into the heap below:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-6.png' />
              </div>
              <hr/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-7.png' />
              </div>
              <hr/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-8.png' />
              </div>
              <hr/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-9.png' />
              </div>
              <br/>
              <p>Got that?</p>
              <p>Let's make a simple BinaryHeap class with this algorithm!</p>
              <p>I'll start you off...</p>
              <p class='example'>Complete the insert function and its helper, bubbleUp, in our BinaryHeap below:</p>
              <br/>
<pre class='prettyprint'>
  template &lt;typename T&gt;
  class BinaryHeap {
      private:
          vector&lt;T&gt; heap;
  
          // Traversal helpers
          int getParent (int index) {
              return (index - 1) / 2;
          }
          int getChild (int index, char child) {
              int result = (index * 2) + 1;
              if (child == 'R') {
                  result++;
              }
              return result;
          }
  
          // Continues to bubble values up the
          // tree until we find a node that is
          // greater than it
          void bubbleUp (int index) {
              // [!] If we're at the root, then
              // we're done
              if ( ??? ) {return;}
  
              // [!] Get parent index and store it
              int parent = ???;
  
              // [!] If the parent's value is less than
              // the current one's...
              if ( ??? ) {
                  // [!] ...then we swap them...
                  ???
  
                  // [!] ...and recurse on the new parent!
                  bubbleUp(parent);
              }
  
          }
  
      public:
          void print () {
              for (int i = 0; i &lt; heap.size(); i++) {
                  cout &lt;&lt; heap[i] &lt;&lt; endl;
              }
          }
  
          void insert (T toInsert) {
              // [!] Add new element to next available
              // slot in the binary tree
              ???
  
              // [!] Start bubbling values up from
              // the newly added value
              ???
          }
  };
</pre>
              <br/>
              <p>Now let's test it using our example from before!</p>
              <br/>
<pre class='prettyprint'>
  int main () {
      BinaryHeap&lt;int&gt; b;
      b.insert(25);
      b.insert(10);
      b.insert(20);
      b.insert(8);
  
      cout &lt;&lt; "BEFORE adding 50:" &lt;&lt; endl;
      b.print();
  
      b.insert(50);
      cout &lt;&lt; "AFTER adding 50:" &lt;&lt; endl;
      b.print();
  }
</pre>
              <br/>
              <p>Great! On to deletion.</p>
              
              <br/>
              <h3>Deletion</h3>
              <p>Nothing particularly surprising about deletion; it's essentially the same algorithm as insertion, in reverse!</p>
              <ol class='indent-1'>
                <li><p>Remove the target node from the heap</p></li>
                <li><p>Promote the bottom-right-most leaf of the last level to the position of the removed node</p></li>
                <li><p>Trickle down the promoted item such that if either of its two children are greater than it, then it trades places with the greatest of its children.</p></li>
                <li><p>Continue trickling down until no child is greater than the trickling node.</p></li>
              </ol>
              <br/>
              <p>Let's try removing the 50 node at the root from the heap below:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-10.png' />
              </div>
              <hr/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-11.png' />
              </div>
              <hr/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-12.png' />
              </div>
              <hr/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-13.png' />
              </div>
              <br/>
              <p class='example'>I shall leave it as an exercise to implement the deletion function into our BinaryHeap class!</p>
              
              <br/>
              <p class='definition'>As a quick, final note; insertion and deletion into a heap can be done with log(n) time complexity.</p>
              
              <br/>
              <h3>Applications</h3>
              <p>Heaps are nice for a variety of applications; we'll discuss two right now!</p>
              <p class='definition'><strong>Priority queues</strong> are a data structure that use heaps for container with the restriction that removing elements from the heap can only be done at the root.</p>
              <br/>
              <p>Because we know the root of a heap is always the greatest element in that heap, we say that we're always removing the item with the highest priority before we get to the others.</p>
              <p class='question' name='priQ-q0'>
                Is the standard queue data structure that we know a special case of a priority queue? What property of items in a standard queue would cause them to behave like a priority queue?
              </p>
              <p class='answer' name='priQ-q0'>
                Yes! Standard queue items are simply removed in the FIFO order of their insertion; we could mimic this behavior with a priority queue by simply time stamping the time of insertion and
                always removing the one with the earliest time stamp first.
              </p>
              
              <br/>
              <p class='definition'><strong>Heap sort</strong> is a way to retrieve a sorted list of a heap's elements.</p>
              <p>Its algorithm goes something like this:</p>
<pre class='prettyprint'>
  count = size of heap
  while count > 1
      heapify the heap
      swap the root with the farthest leaf
        to the right
      count--
</pre>
              <br/>
              <p>Let's do some heap sorting.</p>
              <br/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-sort-0.png' />
              </div>
              <hr/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-sort-1.png' />
              </div>
              <hr/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-sort-2.png' />
              </div>
              <hr/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-sort-3.png' />
              </div>
              <hr/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-sort-4.png' />
              </div>
              <hr/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/heap-sort-5.png' />
              </div>
              <br/>
              <p class='definition'>Heap sort has time complexity O(n*log(n)), like most other gold standard sorts.</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='graphs' class='scrollspy-element' scrollspy-title='Graphs'></div>
            <h1>Graphs</h1>
            <div>
              <p>Graphs are about as fun as a data structure can get (if you ask me).</p>
              <p class='definition'>A <strong>graph</strong> is an abstract data type consisting of some number of Nodes connected by some number of edges, which may be directed or not.</p>
              <br/>
              <p>Such a loose definition! Let's look at a graph...</p>
              <br/>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/graph-0.png' />
              </div>
              <br/>
              <p>Seeing how a graph is just any collection of nodes and edges, let's think for a second...</p>
              <p class='question' name='graph-q0'>Are all trees also graphs?</p>
              <p class='answer' name='graph-q0'>Yes! Trees are just graphs with some additional constraints (which we'll see in a moment).</p>
              <br/>
              <p class='question' name='graph-q1'>Are all graphs also trees?</p>
              <p class='answer' name='graph-q1'>No! Graphs can have a variety of properties that violate the constraints of trees; let's see those in the following table.</p>
              <br/>
              <table class='table table-bordered'>
                <caption>Graphs vs. Trees</caption>
                <thead>
                  <th><p>Property</p></th>
                  <th><p>Trees</p></th>
                  <th><p>Graphs</p></th>
                </thead>
                <tbody>
                  <tr>
                    <th><p>Notion of root</p></th>
                    <td class='success'><p>Yes</p></td>
                    <td class='danger'><p>Not necessarily</p></td>
                  </tr>
                  <tr>
                    <th><p>One path from root to any node</p></th>
                    <td class='success'><p>Yes</p></td>
                    <td class='danger'><p>Not necessarily</p></td>
                  </tr>
                  <tr>
                    <th><p>Can contain cycles</p></th>
                    <td class='danger'><p>No</p></td>
                    <td class='success'><p>Yes</p></td>
                  </tr>
                  <tr>
                    <th><p>Nodes can have multiple inbound arrows</p></th>
                    <td class='danger'><p>No</p></td>
                    <td class='success'><p>Yes</p></td>
                  </tr>
                  <tr>
                    <th><p>Have methods of traversing nodes</p></th>
                    <td class='success'><p>Yes</p></td>
                    <td class='success'><p>Yes*</p></td>
                  </tr>
                </tbody>
              </table>
              <br/>
              <p>
                I put a star next to the graph capacity for traversal simply because, unlike with, say, a binary tree, in which we have defined traversal methods like left-to-right postorder, graphs
                can be traversed starting at any node and following a variety of different traversal schemas.
              </p>
              <p>Additionally, we're not guaranteed that we could traverse all elements of a graph, even if we have a systematic algorithm for doing so. Take the following graph, for example:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/graph-1.png' />
              </div>
              <br/>
              <p>Starting at any one of these nodes, we're not guaranteed that we'll visit every other node in the graph! (in fact, in this case it's not possible)</p>
              <p>Long story short, there are a variety of niceties we had with trees that are lost with the loose constraints of graphs... but we also gain some cool stuff too.</p>
              
              <br/>
              <h3>Graph Properties</h3>
              <p class='definition'>A graph is said to be <strong>directed</strong> if every edge has at least one directed arrowhead.</p>
              <p>This might even mean <strong>bidirected</strong> arrows with arrows on either end!</p>
              <br/>
              <p class='definition'>A graph is said to be <strong>acyclic</strong> if it contains no cycles.</p>
              <p>A <strong>cycle</strong> exists in a graph whenever it is possible, by simply following some path of directed edges, to visit a node twice.</p>
              <br/>
              <p>A very common graph representation involves the case where both of these properties are combined:</p>
              <p class='definition'>A <strong>directed, acyclic graph</strong> (also known as a DAG) is a directed graph with no directed cycles.</p>
              <br/>
              <p class='example'>Is the following graph a DAG?</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/graph-2.png' />
              </div>
              <br/>
              <p class='example'>Is the following graph a DAG?</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/graph-0.png' />
              </div>
              
              <br/>
              <h3>Graph Algorithms</h3>
              <p>There are a variety of graph algorithms for different applications, but for our introduction, let's just examine 1 or 2:</p>
              <p class='definition'>
                A <strong>depth-first traversal</strong> of a graph will visit every descendant of a given node, exploring the entirety of one outbound edge's subgraph before backtracking to explore another.
              </p>
              <p>A depth first traversal that remembers the nodes that it's already visited will not repeat them.</p>
              <p>Depth first traversals are not necessarily unique!</p>
              <p class='example'>Show a couple of depth-first traversals starting with node 1 in the following DAG:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/graph-3.png' />
              </div>
              <br/>
              <p>Some viable depth-first traversals:</p>
              <ul class='indent-1'>
                <li><p>1, 2, 4, 64, 16, 8, 32</p></li>
                <li><p>1, 16, 32, 8, 4, 64, 2</p></li>
              </ul>
              <br/>
              <p class='debug'>The following are NOT viable depth-first traversals starting at node 1. Why?</p>
              <ul class='indent-1'>
                <li><p>1, 2, 16, 4, 8, 32, 64</p></li>
                <li><p>1, 2, 4, 8, 64, 16, 32</p></li>
              </ul>
              
              <br/>
              <p class='indent-1'>A <strong>topological sort</strong> provides an ordering of nodes such that no node appears in the sequence before any of its parents.</p>
              <p>This is useful for tracing dependencies where we have to resolve the parents before the children!</p>
              <p class='example'>What are some viable topological sorts of the following graph?</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/graph-3.png' />
              </div>
              
              <br/>
              <p>OK cool, but how do we store these graphs?</p>
              <p class='definition'>An <strong>adjacency matrix</strong> is a 2D array with a row / column for every node, and an indication at index [i][j] of whether node i is connected to node j.</p>
              <p>Usually we indicate adjacencies with the number 1 to represent an edge going from node i to node j, and a 0 if there is no edge between them.</p>
              <p>Problem: this matrix can have a lot of 0s and waste space.</p>
              <p class='example'>Can you think of another data structure we've learned of to more efficiently store these associations?</p>
            </div>
            <hr/>
              
              
            <br/>
            <div id='theRightStuff' class='scrollspy-element' scrollspy-title='The Right Stuff'></div>
            <h1>Having the Right Stuff</h1>
            <div>
              <p>The whole point about learning all of these different data structures and algorithms is so that we can choose the right candidate for the right job.</p>
              <p>As we've seen, some data structures are better suited for some scenarios than others... let's examine a couple of those scenarios below.</p>
              
              <br/>
              <h3>Sorts and Data Structures</h3>
              <p><strong>Scenario 1:</strong>
                You are in charge of the M.E.R.I.C.A-S.T.A.R-S.P.A.N.G.L.E missile defense system (no one knows what the acronym stands for) that must assess which, out of some
                collection of missiles, is the closest, and target that first. Your simulations suggest that as long as you're able to sort the missile distances for destruction
                in n*log(n) time or less, the nation will be safe.
              </p>
              <p class='example'>Of the O(n*log(n)) average case sorts, which would you *not* want to pick for this task? Why?</p>
              
              <br/>
              <p><strong>Scenario 2:</strong>
                In the year 3000 (following the fall of mankind to the great Forney Industries Fembot Malfunction), you (who have somehow survived until then) are tasked with
                developing tracking chips to emplant in the loyal subjects of your dystopian hegemony (OK, so I might be writing a book on this). These tracking chips have very
                little storage, and must be able to able to look for and possibly add a new contact for an individual in log(n) time.
              </p>
              <p class='example'>Can you suggest a data structure to be used for this purpose? Fun fact, the c++ STL collections made it to the year 3000, which of them might you employ?</p>
              
              <br/>
              <p class='example'>Generate the heap that would be formed with the insertion ordering: <code class='prettyprint'>5, 22, 19, 10, 10, 10, 3, 2</code>. Express your final answer in array form.</p>
              
              <br/>
              <p class='example'>Design a hash function that elicits the following behavior:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-10/hash-3.png' />
              </div>
            </div>
            <hr/>
            
            
            <br/>
            <div id='final' class='scrollspy-element' scrollspy-title='Final'></div>
            <h1>Final</h1>
            <div>
              <p class='definition'>Open notes! Open everything!</p>
              <p>I suggest you bring along the following <a href='http://bigocheatsheet.com/' target='_blank'>computational complexity cheat sheet!</a></p>
              <p>You're going to do fine, breathe deep, focus on your problems, and try not to look at the giant, ticking, countdown clock unless absolutely necessary.</p>
              
              <br/>
              <h3>Goodbye but not Farewell</h3>
              <p>I just wanted to make a special thank-you to all of you who made my first couple of quarters teaching so rewarding. It was an honor and a privilege to get to know you all.</p>
              <p>Don't be a stranger; you'll probably see me in the office hours room for awhile to come!</p>
              <p class='definition'>Now... have you filled out your TA evals yet? :)</p>
            </div>
            <hr/>
            
              
            <a class='btn btn-default pull-right hidden-print' href='javascript:window.print();'>
              <span class='glyphicon glyphicon-print'></span>
              &nbsp; PDF / Print
            </a>
            
          </div>
          <!-- END PRESENTATION CONTENT -->
          
          <!-- MATERIALS FROM CLASS: -->
          
          <!-- TODO: Review -->
            <!-- TODO: Design a hash function that takes this input and sticks it in these buckets -->
            <!-- TODO: Heapification -->
          
          <!-- TODO: Summary table of data structures and their different complexities? -->
          
          
        </div>
      </div>
      <!-- END MAIN CONTENT -->
      
          
    </div>
    <!-- END WRAPPER -->
    
    <!-- BEGIN FOOTER -->
    <div id="footer">
      <div class="container">
        <div class="col-md-12 text-center">
          
        </div>
      </div>
    </div>
    <!-- END FOOTER -->
    
  </body>
</html>
