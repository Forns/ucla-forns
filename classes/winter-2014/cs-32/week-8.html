
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <title>Andrew Forney - UCLA CS</title>
    <link href="../../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../../../css/magic-bootstrap.css" rel="stylesheet" type="text/css">
    <link href="../../../css/main.css" rel="stylesheet" type="text/css">
    <script src="../../../js/lib/jquery-2.0.3.min.js"></script>
    <script src="../../../js/lib/bootstrap.min.js"></script>
    <script src="../../../js/lib/expanding.js"></script>
    <script src="../../../js/lib/chart.min.js"></script>
    <script src="../../../js/display/general/general-display.js"></script>
    <script src="week-7-display.js"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
  </head>
  
  <body data-spy="scroll" data-target="#scrollspy">
    
    <!-- BEGIN WRAP -->
    <div id="wrap">
      
      <!-- BEGIN NAVIGATION -->
      <nav class='navbar navbar-default' role='navigation'>
        <div class='nav-accent'></div>
        <div class='container'>
          <div class='row'>
            <div class='col-md-12'>
              <div class='navbar-header'>
                <button class='navbar-toggle' type='button' data-toggle='collapse' data-target='.navbar-main-collapse'>
                  <span class='sr-only'>Toggle Navigation</span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                </button>
                <a class='navbar-brand' href='/~forns/'>
                  <span id='brand-text'>
                    Andrew Forney
                  </span>
                </a>
              </div>
              
              <div id='nav-main' class='collapse navbar-collapse navbar-main-collapse'>
                <ul class='nav navbar-nav navbar-right'>
                  
                  <li>
                    <a href='/~forns/about.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-user'></span>
                      </div>
                      <p class='text-center'>About</p>
                    </a>
                  </li>
                  
                  <li class='active'>
                    <a href='/~forns/classes.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-book'></span>
                      </div>
                      <p class='text-center'>Classes</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/contact.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-comment'></span>
                      </div>
                      <p class='text-center'>Contact</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/publications.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-file'></span>
                      </div>
                      <p class='text-center'>Publications</p>
                    </a>
                  </li>
                  
                </ul>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <!-- END NAVIGATION -->
      
      <!-- BEGIN MAIN CONTENT -->
      <div id="main-content" class="container">
        <div class="row">
          
          <!-- BEGIN SCROLLSPY -->
          <div class='col-md-2 hidden-sm hidden-xs'>
            <div class="bs-sidebar hidden-print affix" role="complementary">
              <ul id='scrollspy' class="nav bs-sidenav">
              </ul>
            </div>
          </div>
          <!-- END SCROLLSPY -->
          
          <!-- BEGIN PRESENTATION CONTENT -->
          <div class='col-md-10 presentation-content' role='main'>
            
            <ol class="breadcrumb hidden-print">
              <li><a href="../../../classes.html">Classes</a></li>
              <li><a href="./cs-32.html">Winter14 CS32</a></li>
              <li class="active">Week 8</li>
            </ol>
            
            
            <div id='review' class='scrollspy-element' scrollspy-title='Review'></div>
            <h1>Questions from Last Week</h1>
            <div>
              <p>HELP! Project 3 is due tomorrow! Why am I even at discussion / reading these notes?!</p>
              <p><strong>Q: Whenever I try to delete an Actor, everything goes to hell... why?!</strong></p>
              <p>You should check to make sure you're not committing any of the following offenses:</p>
              <ul class='indent-1'>
                <li><p>
                  Your <code class='prettyprint'>getWorld()</code> function isn't returning a vector / list of Actors by reference, but is instead returning by value, meaning that your modifications
                  to the copy are not making it to the one in your StudentWorld.
                </p></li>
                <li><p>You're successfully deleting an Actor in your vector / list but forgetting to update the iterator appropriately.</p></li>
                <li><p>You're successfully deleting an Actor but attempting to delete it a second time later in some other check for Actors being dead.</p></li>
              </ul>
              <br/>
              <p><strong>I don't know where to start with the ComplexZumi's pathfinding... any tips?</strong></p>
              <p>You've done a recent homework or two that might involve a useful algorithm...</p>
              
              <br/>
              <h3>Challenge</h3>
              <p class='example'>What is the time complexity of the following algorithm?</p>
<pre class='prettyprint'>
  int main () {
      int N = 100;
      list&lt;int&gt; s;
      for (int k = 1; k &lt;= N; k++) {
          s.push_back(10*k);
      }
  
      vector&lt;int&gt; t;
      for (list&lt;int&gt;::iterator p = s.begin(); p != s.end(); p = s.erase(p)) {
          t.insert(t.begin(), *p);
      }
  }
</pre>
              <p>Let's provide a solution to this now...</p>
            </div>
            <hr/>
            
            
            <div id='sorting' class='scrollspy-element' scrollspy-title='Sorting'></div>
            <h1>Sorting</h1>
            <div>
              <p>Now that we can judge the algorithmic complexity of code, it's time to look at a very common and applicable subject in computing: sorting!</p>
              <p class='definition'><strong>Sorting</strong> involves the act of ordering items in a collection systematically.</p>
              <p>The systematic aspect of sorting has been of research interest for computer scientists since the dawn of the digital age, and many algorithms have sprung forth from such endeavors.</p>
              <p>Just as we know that not all algorithms were created equal, so must we observe that not all sorting methods are equally good for certain sorting tasks.</p>
              <p>We'll now examine several sorting algorithms, see how they work, what they're good at, and what they're horrible at, all to avoid producing sorting algorithms like the following:</p>
              <div class='text-center fit-pres'>
                <a href='http://xkcd.com/1185/' target='_blank'>
                  <img src='../../../assets/images/winter-2014/cs-32/week-8/sorting-0.PNG' />
                  <br/>
                  <small>(credit of course to the great XKCD)</small>
                </a>
              </div>
              
             <br/>
             <h3>Quadratic Sorts</h3>
             <p>The quadratic sorts are those that perform with O(n^2) time complexity... they're not that great, and there's rarely a good reason to use them.</p>
             <p>Now let's study a couple :)</p>
             
             <br/>
             <h3>Bubble Sort</h3>
             <p>Perhaps the cliche first-sorting-lesson algorithm, bubble sort operates with the following steps:</p>
<pre class='prettyprint'>
  for each item i in the array of n items:
      for each item j from n to i+1:
          if the item at a[j] is less than the item at a[j-1]
              swap those two items
      stop if you didn't swap any items on this iteration
</pre>
              <p>
                So essentially, just compare two adjacent numbers from the back to the front of the array, arranging the two with the lesser on the left and greater on the right (assuming ascending order),
                and continue to do so until the smallest numbers have "bubbled" to the front, and the largest have bubbled to the back.
              </p>
              <br/>
              <p class='example'>Use Bubblesort to sort the following list of ints:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-8/sorting-1.PNG' />
              </div>
              <p class='question' name='sorting-q1'>Click here for the steps the algorithm would take.</p>
              <div class='answer' name='sorting-q1'>
                <div class='text-center fit-pres'>
                  <img src='../../../assets/images/winter-2014/cs-32/week-8/sorting-2.PNG' />
                </div>
              </div>
              <br/>
              <p>Now that we've seen how it's done, let's look at how to implement it in code:</p>
              <p class='example'>Complete the shell for BubbleSort described below:</p>
<pre class='prettyprint'>
  // Helper to print out array elements
  void printIntArr (int arr[], int size) {
      for (int i = 0; i &lt; size; i++) {
          cout &lt;&lt; arr[i] &lt;&lt; " ";
      }
      cout &lt;&lt; endl;
  }
  
  // Helper function; swaps two array elements via
  // the input pointers
  void swapInts (int* i1, int* i2) {
      int temp = *i1;
      *i1 = *i2;
      *i2 = temp;
  }
  
  // Not to be confused with BubleSort, which
  // just replaces your array elements with lyrics
  // from Haven't Met You Yet
  void bubbleSort (int arr[], int size) {
      // [!] Iterate through each element of the
      // list
      for ( ??? ) {
          // Track if a swap has been made
          bool swapped = false;
          // [!] Iterate through all elements of the list
          // starting at the end element and up to the
          // i + 1 element
          for ( ??? ) {
              // [!] Swap if the two currently adjacent
              // in the 2nd loop iteration are out of order
              if ( ??? ) {
                  swapInts( ??? );
                  // Mark that you've swapped
                  swapped = true;
              }
          }
          // [!] Return if you made no swaps
          if (!swapped) {return;}
      }
  }
  
  int main () {
      int i[] = {0, -5, 4, 2, -2, 0, 1, 6, 9, 3};
      bubbleSort(i, 10);
      printIntArr(i, 10);
  }
</pre>
              <br/>
              <p class='question' name='sorting-q2'>Bubble sort can &quot;sort&quot; a list in linear time if the list has what property?</p>
              <p class='answer' name='sorting-q2'>It's already almost sorted :P</p>
              <p class='question' name='sorting-q3'>What list property will cause BubbleSort the most inconvenience?</p>
              <p class='answer' name='sorting-q3'>Reversed order of elements.</p>
              <br/>
              <p class='definition'>There are some good BubbleSort animations <a href='http://www.sorting-algorithms.com/bubble-sort' target='_blank'>located here</a>.</p>
              <p>OK nice! Got a simple sort down... here's another one that you should avoid writing on a midterm:</p>
              <div class='text-center fit-pres'>
                <a href='http://xkcd.com/1185/' target='_blank'>
                  <img src='../../../assets/images/winter-2014/cs-32/week-8/sorting-3.PNG' />
                  <br/>
                  <small>(credit to XKCD)</small>
                </a>
              </div>
              
              <br/>
              <h3>Insertion Sort</h3>
              <p>The second most cliche sorting algorithm, insertion sort operates with the following steps:</p>
<pre class='prettyprint'>
  for each element i in the array, starting with the 2nd:
      for each element k = i down to k = 0 where arr[k] &lt; arr[k-1]:
          swap a[k] and a[k-1]
</pre>
              <p>So, the idea is that we continue to lock items at the front of the array into their proper place, assuming everything to the left of the current one is sorted already.</p>
              <p class='example'>Use Insertion Sort to sort the following list of ints:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-8/sorting-1.PNG' />
              </div>
              <p class='question' name='sorting-q4'>Click here for the steps the algorithm would take.</p>
              <div class='answer' name='sorting-q4'>
                <div class='text-center fit-pres'>
                  <img src='../../../assets/images/winter-2014/cs-32/week-8/sorting-4.PNG' />
                  <img src='../../../assets/images/winter-2014/cs-32/week-8/sorting-5.PNG' />
                </div>
              </div>
              <p>(maybe if I don't say anything, they won't notice that the illustration is actually two different images because I couldn't fit it all into one slide...)</p>
              <p>Any who, let's implement this now; it won't take long!</p>
              <p class='example'>Implement the insertionSort skeleton begun below.</p>
<pre class='prettyprint'>
  void insertionSort (int arr[], int size) {
      // [!] Iterate through each element of the array
      // starting with the second
      for ( ??? ) {
          // [!] Iterate through the first i elements
          // of the array, except the first
          for ( ??? ) {
              // [!] If the currently examined
              // element is greater than the one
              // before it in the list, stop
              if ( ??? ) {
                  break;
              }
              // [!] Otherwise, swap the two
              swapInts( ??? );
          }
      }
  }
</pre>
              <p class='question' name='sorting-q5'>Insertion sort can &quot;sort&quot; a list in linear time if the list has what property?</p>
              <p class='answer' name='sorting-q5'>It's already almost sorted... same as BubbleSort, but insertion sort has less overhead</p>
              <p class='question' name='sorting-q6'>What list property will cause Insertion Sort the most inconvenience?</p>
              <p class='answer' name='sorting-q6'>Reversed order of elements.</p>
              <br/>
              <p class='definition'>There are some good Insertion animations <a href='http://www.sorting-algorithms.com/insertion-sort' target='_blank'>located here</a>.</p>
              <p>I think that's it for covering quadratic sorts... remember that these have O(n^2) and are generally not preferred on their own in the general case.</p>
              <p>Let's take a quick review of merge sort, unlike the following half-hearted implementation:</p>
              <div class='text-center fit-pres'>
                <a href='http://xkcd.com/1185/' target='_blank'>
                  <img src='../../../assets/images/winter-2014/cs-32/week-8/sorting-6.PNG' />
                  <br/>
                  <small>(credit to XKCD)</small>
                </a>
              </div>
              
              <h3>Better Sort Algorithms</h3>
              <p>We can do much better than quadratic sorting time; let's look at some alternatives below:</p>
              
              <br/>
              <h3>Merge Sort</h3>
              <p>We remember merge sort but let's review:</p>
<pre class='prettyprint'>
  void mergeSort (int a[], int b, int e) {
      if (e - b >= 2) {
          int mid = (b + e) / 2;
          
          // Recursive call on first half of a
          mergeSort(a, b, mid);
          // Recursive call on other half of a
          mergeSort(a, mid, e);
          
          // Merge those sorted subpropblems!
          merge(a, b, mid, e);
      }
  }
  
  int main () {
      int arr[] = {4, 3, 1, 2};
      sort(arr, 0, 4);
      // arr will now be {1, 2, 3, 4}
  }
</pre>
              <p>Here, the merge function combines the two sublists into a single, ordered sublist.</p>
              <p>Let's take another look at it in action (gif shamelessly stolen from <a href='http://en.wikipedia.org/wiki/Merge_sort' target='_blank'>Wikipedia</a>):</p>
              <a href='../../../assets/images/winter-2014/cs-32/week-5/mergesort.gif' target='_blank'>
                <div class='text-center fit-pres'>
                  <img src='../../../assets/images/winter-2014/cs-32/week-5/mergesort.gif' />
                </div>
              </a>
              <p class='question' name='sorting-q7'>What is the time complexity of MergeSort?</p>
              <p class='answer' name='sorting-q7'>
                O(n*log(n)) because it continuously splits the array into smaller subarrays [O(log(n))], and then merges them [O(n)]
              </p>
              <p class='question' name='sorting-q8'>Taking into account its splitting and merging behavior, are there any properties of lists that MergeSort struggles with?</p>
              <p class='answer' name='sorting-q8'>
                MergeSort actually handles input of any type pretty much the same; because of the splits down to small, managable sub-arrays, the format of the larger array is not relevant to its performance.
              </p>
              <br/>
              <p class='definition'>There are some good MergeSort animations <a href='http://www.sorting-algorithms.com/merge-sort' target='_blank'>located here</a>.</p>
              
              <br/>
              <h3>Quick Sort</h3>
              <p>The sort of choice for the discerning programmer, Quick Sort (or some variant of it) is used in many modern sorting applications.</p>
              <p>It goes something like this:</p>
<pre class='prettyprint'>
  Choose a pivot value (randomly, for now) in the current subarray
  Swap the value at the front of the array with that pivot
  Track the position of the pivot with an index var
  For each element i in the array starting at the 2nd:
      If arr[i] is less than a[0],
          Swap a[i] with the item to the right of the pivot
          Increment the pivot index
  Swap a[0] with the pivot index
  Recurse on a[0, pivot index - 1]
  Recurse on a[pivot index + 1, size of the array]
</pre>
              <br/>
              
              <!-- TODO: EXAMPLE OF QUICKSORT -->
              
              <p>Now that you're accustomed to QuickSort, this won't be you in a job interview:</p>
              <div class='text-center fit-pres'>
                <a href='http://xkcd.com/1185/' target='_blank'>
                  <img src='../../../assets/images/winter-2014/cs-32/week-8/sorting-7.PNG' />
                  <br/>
                  <small>(credit to XKCD)</small>
                </a>
              </div>
            </div>
            <hr/>
            
              
            <a class='btn btn-default pull-right hidden-print' href='javascript:window.print();'>
              <span class='glyphicon glyphicon-print'></span>
              &nbsp; PDF / Print
            </a>
            
          </div>
          <!-- END PRESENTATION CONTENT -->
          
          <!-- MATERIALS FROM CLASS: -->
          
          
        </div>
      </div>
      <!-- END MAIN CONTENT -->
      
      <!-- TODO: Sorting -->
          <!-- TODO: Quick sort: the order function that everyone did for homework -->
            <!-- TODO: We split into everything smaller than a pivot and then everything larger than it -->
              <!-- TODO: Recurse on sub-splits -->
            <!-- TODO: Performs really well when the piles are about even; poorly when one pile is small and the other large -->
            <!-- TODO: Example: 5 3 7 6 1 8 2 4 -->
            <!-- TODO: *5 3 7 6 1 8 2 4 -->
            <!-- TODO: 1 3 4 2 (5) 8 6 7 -->
              <!-- TODO: LHS: *1 3 4 2 => (1) 3 4 2 -->
                <!-- TODO: *3 4 2 => 2 (3) 4 -->
              <!-- TODO: RHS: *8 6 7 => 6 7 (8) -->
            <!-- TODO: Degenerates to n^2 if pivot choices are poor -->
            <!-- TODO: On average, order n*log(n) -->
            <!-- TODO: One improvement: when your split gets down to k items, just leave them alone and go over the list with insertion sort because everything will be close to its destination -->
              <!-- TODO: What is k? Well, a PhD dissertation by Sedgewick found that k is about 9 -->
          <!-- TODO: Intro sort: is quicksort but monitors its own sorting and determines if it's headed towards the n^2 degeneration; if it is, it switches to another sorting algorithm -->
            <!-- TODO: Intro sort: "introspection" quicksort -->
            
          <!-- TODO: Trees -->
            <!-- TODO: Tree has a bunch of nodes -->
            <!-- TODO: Nodes are connected by edges -->
              <!-- TODO: They can be represented by some data component and then a vector of pointers to other nodes representing its children -->
            <!-- TODO: Notion of a path whereby we follow edges from one node to another -->
            <!-- TODO: The node at the "top" is the root -->
            <!-- TODO: Leaves are nodes at the bottom that do not have any descendants -->
              <!-- TODO: Leaves have a vector of children with no elements -->
            <!-- TODO: Any node not a leaf is called an interior node -->
            <!-- TODO: The node directly above a node is its parent -->
            <!-- TODO: The nodes that come before a node between it and the root are its ancestors, including the root -->
            <!-- TODO: The depth of a node is the number of edges between it and the root -->
            <!-- TODO: The depth of a tree is the MAXIMUM depth of any node -->
            <!-- TODO: What makes it a tree is that: for every node, there is *exactly* one path to the root -->
            
            <!-- TODO: Algorithm for how many nodes are in the tree -->
              <!-- TODO: Recurse to each child -->
              <!-- TODO: Count each node as its visited, adding to a total, and then combines each count from the children -->
            <!-- TODO: [!] Example for max value in tree? -->
        
            <!-- TODO: Tips for designing tree algorithms -->
              <!-- TODO: Does it work for the null pointer? (not break) -->
              <!-- TODO: Does it work for the root? -->
              <!-- TODO: Does it work for an internal node? -->
              <!-- TODO: Does it work for a leaf? -->
            
            <!-- TODO: Algorithm for how to print tree structure in text output -->
              <!-- TODO: Write out the data of the current node, then recurse on the children -->
            <!-- TODO: [!] Breadth first printout -->
            
            <!-- TODO: Traversal methods: -->
              <!-- TODO: Preorder: (breadth first???) do something with the current node before dealing with any of the children -->
                <!-- TODO: Ex: if-else conditional in C++ via tree structure -->
              <!-- TODO: Postorder: (depth first???) do something with the current node after dealing with any of the children -->
                <!-- TODO: Ex: evaluating arithmetic operations -->
                
            <!-- TODO: N-ary trees -->
              <!-- TODO: Any tree can be converted into an n-ary tree of n maximum children per node -->
              <!-- TODO: Binary trees: -->
                <!-- TODO: Binary trees are either empty or a node with a left binary subtree and/or a right binary subtree -->
                  <!-- TODO: Base case: empty tree -->
                  <!-- TODO: Recursive case: left and right subtrees -->
                <!-- TODO: Applications: binary search tree -->
                  <!-- TODO: All nodes less than the current on the left, and all nodes greater than the current are on the right -->
      
    </div>
    <!-- END WRAPPER -->
    
    <!-- BEGIN FOOTER -->
    <div id="footer">
      <div class="container">
        <div class="col-md-12 text-center">
          
        </div>
      </div>
    </div>
    <!-- END FOOTER -->
    
  </body>
</html>
