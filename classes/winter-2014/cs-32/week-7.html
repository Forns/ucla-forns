
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <title>Andrew Forney - UCLA CS</title>
    <link href="../../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../../../css/magic-bootstrap.css" rel="stylesheet" type="text/css">
    <link href="../../../css/main.css" rel="stylesheet" type="text/css">
    <script src="../../../js/lib/jquery-2.0.3.min.js"></script>
    <script src="../../../js/lib/bootstrap.min.js"></script>
    <script src="../../../js/lib/expanding.js"></script>
    <script src="../../../js/display/general/general-display.js"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
  </head>
  
  <body data-spy="scroll" data-target="#scrollspy">
    
    <!-- BEGIN WRAP -->
    <div id="wrap">
      
      <!-- BEGIN NAVIGATION -->
      <nav class='navbar navbar-default' role='navigation'>
        <div class='nav-accent'></div>
        <div class='container'>
          <div class='row'>
            <div class='col-md-12'>
              <div class='navbar-header'>
                <button class='navbar-toggle' type='button' data-toggle='collapse' data-target='.navbar-main-collapse'>
                  <span class='sr-only'>Toggle Navigation</span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                </button>
                <a class='navbar-brand' href='/~forns/'>
                  <span id='brand-text'>
                    Andrew Forney
                  </span>
                </a>
              </div>
              
              <div id='nav-main' class='collapse navbar-collapse navbar-main-collapse'>
                <ul class='nav navbar-nav navbar-right'>
                  
                  <li>
                    <a href='/~forns/about.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-user'></span>
                      </div>
                      <p class='text-center'>About</p>
                    </a>
                  </li>
                  
                  <li class='active'>
                    <a href='/~forns/classes.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-book'></span>
                      </div>
                      <p class='text-center'>Classes</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/contact.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-comment'></span>
                      </div>
                      <p class='text-center'>Contact</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/publications.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-file'></span>
                      </div>
                      <p class='text-center'>Publications</p>
                    </a>
                  </li>
                  
                </ul>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <!-- END NAVIGATION -->
      
      <!-- BEGIN MAIN CONTENT -->
      <div id="main-content" class="container">
        <div class="row">
          
          <!-- BEGIN SCROLLSPY -->
          <div class='col-md-2 hidden-sm hidden-xs'>
            <div class="bs-sidebar hidden-print affix" role="complementary">
              <ul id='scrollspy' class="nav bs-sidenav">
              </ul>
            </div>
          </div>
          <!-- END SCROLLSPY -->
          
          <!-- BEGIN PRESENTATION CONTENT -->
          <div class='col-md-10 presentation-content' role='main'>
            
            <ol class="breadcrumb hidden-print">
              <li><a href="../../../classes.html">Classes</a></li>
              <li><a href="./cs-32.html">Winter14 CS32</a></li>
              <li class="active">Week 7</li>
            </ol>
            
            
            <div id='stl' class='scrollspy-element' scrollspy-title='STL'></div>
            <h1>The Standard Template Library</h1>
            <div>
              <p>Oh right, we've been talking about templates...</p>
              <p>In fact, we've actually been using templates without knowing much about them!</p>
              <p>When we've used a stack of ints from the STL stack, we've said something like <code class='prettyprint'>stack&lt;int&gt; si;</code></p>
              <p class='definition'>The <strong>standard template library</strong> is a template-driven code base with 4 main components: containers, iterators, algorithms, and functors.</p>
              <br/>
              <p>We'll see examples of each of those momentarily!</p>
              <p>The impetus for the STL was that programmers witnessed commonalities in many of their data structures and algorithms that differed only in the types they were using them with.</p>
              <p>Sorry for ending that sentence in a preposition.</p>
              <p>I'll make it up to you by starting with the exciting STL world of containers.</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='containers' class='scrollspy-element' scrollspy-title='Containers'></div>
            <h1>STL Containers</h1>
            <div>
              <p>Just when you thought things would get dull, we get to tackle containers!... which are basically what we've been covering...</p>
              <p class='definition'><strong>Containers</strong> are simply means by which we refer to groups of objects while abiding by the &quot;rules&quot; of a given container.</p>
              <br/>
              <p>So what are the rules of a container?</p>
              <p class='question' name='containers-q0'>What are some containers we've discussed in class and by what rules should each abide?</p>
              <div class='answer' name='containers-q0'>
                <ul class='indent-1'>
                  <li><p>A <code class='prettyprint'>stack</code> is a container that follows the last-in, first-out (LIFO) interface with pushing and popping from the top of the stack.</p></li>
                  <li><p>A <code class='prettyprint'>queue</code> is a container that follows the first-in, first-out (FIFO) interface with pushing to the back and popping from the front.</p></li>
                  <li><p>A <code class='prettyprint'>vector</code> is a dynamic array with random index access and dynamic resizing. (contiguous elements)</p></li>
                  <li><p>A <code class='prettyprint'>list</code> is the STL implementation of a doubly linked list without random index access, but no need for dynamic resizing. (non-contiguous elements)</p></li>
                </ul>
              </div>
              <br/>
              <p>So none of this is particularly new... in fact, it's kinda what we've been doign this whole quarter...</p>
              <p>That said, we haven't closely examined the intricacies of some STL containers, so let's use vectors and lists as our examples for the next section or two:</p>
              
              <br/>
              <h3>#include &lt;vector&gt;</h3>
              <p class='definition'>The <strong>vector</strong> container is just a dynamic array, which means we have random access to its elements plus the ability to resize it as we need.</p>
              <p class='question' name='container-q1'>What does it mean for a container to have random access?</p>
              <p class='answer' name='container-q1'>
                It means that at any time, we can access elements at an arbitrary offset, similar to how pointers operate with random access (we can talk about pointers with any offset).
              </p>
              <br/>
              <p>Let's look at some vector operations and see how they're similar and different from what we know:</p>
              
              <br/>
              <p class='toolkit'><strong>push_back( ... )</strong> appends an element to the end of the vector. <strong>pop_back()</strong> removes the last element (and does NOT return it).</p>
<pre class='prettyprint'>
  int main () {
      // Anyone catch this reference?
      // *tumbleweed*
      vector&lt;int&gt; victor;
      victor.push_back(5);
      victor.push_back(10);
      victor.push_back(15);
      victor.pop_back();
      // Victor is now just: {5, 10}
  }
</pre>
              <p>Nothing surprising there...</p>
              
              <br/>
              <p class='toolkit'>The <strong>front(), back()</strong> member functions return the items at the front and back of the vector, respectively.</p>
<pre class='prettyprint'>
  int main () {
      vector&lt;int&gt; victor;
      victor.push_back(5);
      victor.push_back(10);
      victor.push_back(15);
      cout &lt;&lt; victor.front() &lt;&lt; endl;
      cout &lt;&lt; victor.back() &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>We also said that vectors enjoy random access, so we have the following accessor functions at our disposal as well:</p>
              <p class='toolkit'>The <strong>at(n)</strong> accessor returns the element at index n in the vector.</p>
<pre class='prettyprint'>
  int main () {
      vector&lt;int&gt; victor;
      victor.push_back(5);
      victor.push_back(10);
      victor.push_back(15);
      // victor = {5, 10, 15}
  
      cout &lt;&lt; victor.at(1) &lt;&lt; endl;
      victor.at(1) = 20;
      // victor = {5, 20, 15}
  }
</pre>
              <br/>
              <p>Vectors also overload the pointer offset notation, so we can replicate the above code by saying:</p>
<pre class='prettyprint'>
  int main () {
      vector&lt;int&gt; victor;
      victor.push_back(5);
      victor.push_back(10);
      victor.push_back(15);
      // victor = {5, 10, 15}
  
      cout &lt;&lt; victor[1] &lt;&lt; endl;
      victor[1] = 20;
      // victor = {5, 20, 15}
      cout &lt;&lt; victor[1] &lt;&lt; endl;
  }
</pre>
              <br/>
              <p class='toolkit'>
                The <strong>size()</strong> function returns how many elements are currently in the vector. The <strong>capacity</strong> function returns how much space the vector has reserved.
              </p>
              <p class='question' name='vector-q0'>Remembering that vectors are dynamic arrays, will size() and capacity() always be equivalent? What can we say about their relationship?</p>
              <p class='answer' name='vector-q0'>No, they may not be equivalent, but we know that size() &lt;= capacity()</p>
<pre class='prettyprint'>
  int main() {
      vector&lt;int&gt; victor;
      for (int i = 0; i &lt; 100; i++) {
          victor.push_back(i);
      }
      cout &lt;&lt; victor.size() &lt;&lt; endl;
      cout &lt;&lt; victor.capacity() &lt;&lt; endl;
  }
</pre>
              <br/>
              <p class='debug'>[!] WARNING: Accessing or assigning to vector (let's say vector v) elements using v.at(n) or v[n] is only defined if n is currently less than v.size().</p>
              <p class='debug'>Does the following code exhibit any undefined behavior? If not, what will it print out?</p>
<pre class='prettyprint'>
  int main() {
      vector&lt;int&gt; victor;
      for (int i = 0; i &lt; 100; i++) {
          victor.push_back(i);
      }
      cout &lt;&lt; victor.size() &lt;&lt; endl;
      cout &lt;&lt; victor.capacity() &lt;&lt; endl;
      victor[100] = 1;
      victor.push_back(2);
      cout &lt;&lt; victor[100] &lt;&lt; endl;
      cout &lt;&lt; victor.size() &lt;&lt; endl;
      cout &lt;&lt; victor.capacity() &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>So, remember, we can only reliably use the at and [] functions for indexes less than the size, not the capacity!</p>
              
              <br/>
              <h3>#include &lt;list&gt;</h3>
              <p>So, whereas vectors are the STL dynamic array container, lists are the STL doubly linked list.</p>
              <p>There are some key differences between the interfaces of vectors and lists; let's look at some below:</p>
              <p class='toolkit'>We can add items to the front and back of a list using the <strong>push_front(...)</strong> and <strong>push_back(...)</strong> functions, respectively.</p>
              <p class='question' name='lists-q0'>Why do we have the ability to push_front() with lists but not with vectors?</p>
              <p class='answer' name='lists-q0'>Insertion to the front of a linked list is easy and performed in constant time; it is non-trivial with arrays because we need to shift everything down!</p>
              <br/>
              <p class='toolkit'>Similarly, we can pop items from the front or back of a list using <strong>pop_front()</strong> and <strong>pop_back()</strong> respectively.</p>
<pre class='prettyprint'>
  int main () {
      list&lt;string&gt; less;
      less.push_back("playing");
      less.push_back("BugBlast");
      less.push_front("Busy");
      less.pop_front();
      less.push_front("NOT");
  }
</pre>
              <br/>
              <p class='toolkit'>
                We have a variety of accessor strategies for lists, two of which are to get references to the front and back via functions <strong>front()</strong> and <strong>back()</strong>
                respectively.
              </p>
<pre class='prettyprint'>
  int main () {
      list&lt;string&gt; less;
      less.push_back("DAMN");
      less.push_back("BUG");
      less.push_back("SPRAY");
      less.back() = "SMALLBERG!";
      cout &lt;&lt; less.front() &lt;&lt; endl;
      cout &lt;&lt; less.back() &lt;&lt; endl;
  }
</pre>
              <p class='definition'>Remember! We *cannot* perform random access with linked lists. This means that lists do NOT have the at and [] functions.</p>
              <p>So how can we access elements that aren't at the back or the front? Let's shift our discussion to iterators...</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='iterators' class='scrollspy-element' scrollspy-title='Iterators'></div>
            <h1>Iterators</h1>
            <div>
              <p>
                When we dealt with linked lists in the past, the way we would iterate through elements was through a Node pointer on which we could successively look at 
                <code class='prettyprint'>n-&gt;next;</code>
              </p>
              <p>With the STL list, however, we no longer have access to the internal representation of the Node, so how do we iterate?!</p>
              <p class='toolkit'>Iterators are STL *objects* (not pointers, necessarily) that refer to a position in some sort of sequential collection.</p>
              <p>Iterators are objects specific to a particular collection, so lists have their own iterators, vectors have their own iterators, etc.</p>
              <p>For the purposes of lists, iterators are somewhat analogous to our familiar Node pointers, but with several key differences.</p>
              <p>Let's look at the specifics next:</p>
              
              <br/>
              <h3>Construction &amp; Assignment</h3>
              <p class='toolkit'>We can construct new Iterators for a collection via the syntax: <code class='prettyprint'>collection&lt;type&gt;::iterator name;</code></p>
              <p>So, to define a string iterator for a list, we'd say:</p>
<pre class='prettyprint'>
  list&lt;string&gt;::iterator iter;
</pre>
              <p>Not very useful yet...</p>
              <br/>
              <p class='toolkit'>
                For *both vectors and lists* we can get an iterator at the position of the first or last element via the functions <strong>begin()</strong> and <strong>end()</strong>
                respectively.
              </p>
              <p>So, let's make a couple iterators:</p>
<pre class='prettyprint'>
  int main () {
      list&lt;string&gt; less;
      less.push_back("Hey");
      less.push_back("Iterate");
      less.push_back("THIS!");
      list&lt;string&gt;::iterator b = less.begin();
      list&lt;string&gt;::iterator e = less.end();
  }
</pre>
              <p class='debug'>[!] WARNING: the end() iterator refers to the theoretical position *just past* the last element. Keep this in mind for the next sections.</p>
              <p>So, the current picture we have is:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-7/iterators-0.PNG' />
              </div>
              
              <br/>
              <h3>Dereference</h3>
              <p class='toolkit'>Iterators support the dereference operation (*), which functions just like pointer dereference, returning the value that the iterator points to in the container.</p>
              <br/>
              <p class='debug'>Will the following code compile? If so, what will it print?</p>
<pre class='prettyprint'>
  int main () {
      list&lt;string&gt; less;
      less.push_back("Hey");
      less.push_back("Iterate");
      less.push_back("THIS!");
      list&lt;string&gt;::iterator b = less.begin();
      list&lt;string&gt;::iterator e = less.end();
      cout &lt;&lt; *b &lt;&lt; endl;
  }
</pre>
              <br/>
              <p class='debug'>Will the following code compile? If so, what will it print?</p>
<pre class='prettyprint'>
  int main () {
      list&lt;string&gt; less;
      less.push_back("Hey");
      less.push_back("Iterate");
      less.push_back("THIS!");
      list&lt;string&gt;::iterator b = less.begin();
      list&lt;string&gt;::iterator e = less.end();
      cout &lt;&lt; *e &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>Always be careful with the iterator returned by end()!</p>
              <p>Now, let's see how we can use iterators for something useful...</p>
              
              <br/>
              <h3>Increment &amp; Decrement</h3>
              <p class='toolkit'>Iterators support the increment (++) and decrement (--) operations when there is a legitimate position to iterate to in that direction.</p>
              <p>
                So, just like we could never call n-&gt;next on a Node pointer that is equal to the nullptr, we can't perform decrement on the iterator equivalent with begin() nor increment on the iterator
                equivalent with end().
              </p>
              <p class='debug'>Will the following code compile? If so, what will it print?</p>
<pre class='prettyprint'>
  int main () {
      list&lt;string&gt; less;
      less.push_back("Hey");
      less.push_back("Iterate");
      less.push_back("THIS!");
      list&lt;string&gt;::iterator b = less.begin();
      list&lt;string&gt;::iterator e = less.end();
      
      // b--; BAD! Iterates off the beginning of the list
      // e++; BAD! Iterates off the end of the list
  
      b++;
      e--;
      cout &lt;&lt; *b &lt;&lt; endl;
      cout &lt;&lt; *e &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>We're almost done looking at the basic operations of iterators... I kinda promise...</p>
              
              <br/>
              <h3>Equivalence &amp; Nonequivalence</h3>
              <p class='toolkit'>We can compare two iterators to see if they refer to the same container element via the familiar equivalence (==) and nonequivalence (!=) operators.</p>
              <p>This allows us to use iterators in loops!</p>
<pre class='prettyprint'>
  int main () {
      list&lt;string&gt; less;
      less.push_back("Hey");
      less.push_back("Iterate");
      less.push_back("THIS!");
      list&lt;string&gt;::iterator b = less.begin();
      list&lt;string&gt;::iterator e = less.end();
      
      // Print out the data at b, then increment
      // it until we reach the end of the list!
      while (b != e) {
          cout &lt;&lt; *b++ &lt;&lt; endl;
      }
  }
</pre>

              <br/>
              <h3>Iterator Trickz</h3>
              <p class='toolkit'>You can use iterators as ranges for copying between collections.</p>
              <p>Here, I'll choose to copy all of the contents of my list into a new vector, specifying the begin and end copy range as the full list (less.begin(), less.end())</p>
<pre class='prettyprint'>
  int main () {
      list&lt;string&gt; less;
      less.push_back("Cool");
      less.push_back("Copy");
      less.push_back("Bro");
  
      vector&lt;string&gt; v(less.begin(), less.end());
      vector&lt;string&gt;::iterator b = v.begin();
      vector&lt;string&gt;::iterator e = v.end();
  
      while (b != e) {
          cout &lt;&lt; *b++ &lt;&lt; endl;
      }
  }
</pre>
              <br/>
              <p class='toolkit'>Use the <strong>insert(iterator, value);</strong> function to insert a value at the position *just before* the given iterator.</p>
<pre class='prettyprint'>
  int main () {
      list&lt;string&gt; less;
      less.push_back("Cool");
      less.push_back("Insertion");
      less.push_back("Bro");
  
      list&lt;string&gt;::iterator b = less.begin();
      list&lt;string&gt;::iterator e = less.end();
  
      list&lt;string&gt;::iterator iter = less.begin();
      iter++;
      less.insert(iter, "HELP I'M TRAPPED IN A LIST");
  
      while (b != e) {
          cout &lt;&lt; *b++ &lt;&lt; endl;
      }
  }
</pre>
              <br/>
              <p class='toolkit'>Use the <strong>erase(iter)</strong> to erase a single iterator item, or <strong>erase(begin, end)</strong> to delete a range of items.</p>
<pre class='prettyprint'>
  int main () {
      list&lt;string&gt; less;
      less.push_back("Cool");
      less.push_back("Insertion");
      less.push_back("Bro");
  
      list&lt;string&gt;::iterator b = less.begin();
      list&lt;string&gt;::iterator e = less.end();
  
      list&lt;string&gt;::iterator iter = less.begin();
      iter++;
      less.erase(iter, e);
  
      while (b != e) {
          cout &lt;&lt; *b++ &lt;&lt; endl;
      }
  }
</pre>
              
              <br/>
              <h3>Dangers &amp; Caveats</h3>
              <p class='definition'>*VECTOR* iterators support random access because of the dynamic array indexing. *LIST* iterators do NOT!</p>
              <p>This means that (++) and (--) are the only ways to traverse lists, but we can perform additions and subtractions to iterators in vectors:</p>
<pre class='prettyprint'>
  int main () {
      vector&lt;string&gt; v;
      v.push_back("Cool");
      v.push_back("Insertion");
      v.push_back("Bro");
  
      vector&lt;string&gt;::iterator b = v.begin();
      b += 2;
      cout &lt;&lt; *b &lt;&lt; endl;
  }
</pre>
              <br/>
              <p class='debug'>For this same reason, &gt;, &gt;=, &lt;, and &lt;= comparisons are valid for vector iterators but NOT list iterators!</p>
              <br/>
              <p>One final warning before we move on from iterators...</p>
              <p class='debug'>Insertions and deletions on *vectors*, but not lists, will INVALIDATE any iterators defined on that vector.</p>
              <p class='debug'>Will the following code have any undefined behavior? If not, what will it print?</p>
<pre class='prettyprint'>
  int main () {
      vector&lt;int&gt; v;
      v.push_back(50);
      v.push_back(22);
      v.push_back(10);
  
      vector&lt;int&gt;::iterator b = v.begin();
      vector&lt;int&gt;::iterator e = v.end();
      for (int i = 0; i &lt; 100; i++) {
          v.push_back(i);
      }
      while (b != e) {
          cout &lt;&lt; *b++ &lt;&lt; endl;
      }
  }
</pre>
              <br/>
              <p class='question' name='iterator-q1'>Why is this a problem?</p>
              <p class='answer' name='iterator-q1'>
                Vectors are dynamic arrays, which means they might resize themselves as needed. Whenever this happens, the old array is deleted in favor of a new one, but the old iterators
                are not also updated, and so they refer to deallocated memory.
              </p>
              <br/>
              <p>Alright you can wake up now! Time to move on to some kinda interesting stuffs.</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='algorithms' class='scrollspy-element' scrollspy-title='Algorithms'></div>
            <h1>STL Algorithms</h1>
            <div>
            </div>
            <hr/>
            
            
            <a class='btn btn-default pull-right hidden-print' href='javascript:window.print();'>
              <span class='glyphicon glyphicon-print'></span>
              &nbsp; PDF / Print
            </a>
            
          </div>
          <!-- END PRESENTATION CONTENT -->
          
          <!-- MATERIALS FROM CLASS: -->
          
          
          <!-- TODO: We can use templates in unison with iterators and collections in order to form *algorithms* -->
            <!-- TODO: Library of <algorithm> can be used to perform type-agnostic operations like a linear search: template<typename Iter, typename T> Iter find(Iter b, Iter e, const T& target) -->
            <!-- TODO: We can even use templates where we include functions for arguments to template functions -->
              <!-- TODO: template<typename Iter, typename Func> Iter find_if(Iter b, Iter e, Func f) { ... } -->
              <!-- TODO: We can pass in a *pointer to a function* which is just the name of that function -->
              <!-- TODO: e.g. find_if(b, e, isNegative); // where isNegative takes in a single int and returns true if it's negative -->
              <!-- TODO: dangers of sorting with <=, >= because on one pass, a >= b is true but b >= a could also be true -->
              
          <!-- TODO: Algorithm analysis -->
            <!-- TODO: Interested in time and space requirements of a given algorithm -->
              <!-- TODO: Useful for comparing algorithms for the best -->
              <!-- TODO: Useful for seeing how well an algorithm scales; growth of complexity with the more items an algorithm operates on -->
            <!-- TODO: Needed because we can't count time of operation due to hardware differences between test machines -->
            <!-- TODO: Instead, we'll measure the number of steps that the algorithm takes -->
              <!-- TODO: When expressions grow in number of inputs N, the higher-order terms are the biggest contributors, until as N->infinity, the lower-order terms are ignored -->
              <!-- TODO: We really only care about large N, because if N is small, usually computers are so fast it won't matter -->
              <!-- TODO: As N->infinity, we really don't care about highest-order coefficients; we're interested in growth patterns -->
              <!-- TODO: So, we only focus on the highest order N term -->
              <!-- TODO: We say that the Big O notation for a function f(n) is O(f(n)) if there exists N_o and k such that for all N >= N_o, |f(n)| <= k*g(n) -->
                <!-- TODO: We want to find a simple function that f(n) is always less than for large N -->
                <!-- TODO: We say that N_o is the point where O(n) is always bigger than f(n) -->
                <!-- TODO: We also want O(n) to be a tight bound to f(n) -->
            <!-- TODO: Common growth patterns: -->
              <!-- TODO: Constant time O(1): array element access, linked list deletion (when you know the address of the Node) -->
              <!-- TODO: Linear time O(n): linked list element access; any list "find" mechanism -->
              <!-- TODO: Quadratic time O(n^2): is each element in one array found somewhere in another? -->
                <!-- TODO: Even if we're examining one element fewer with each iteration, still O(n^2) -->
                <!-- TODO: Sum(N - 1) from 0 to N = N(N-1)/2 = 1/2*N^2 - N/2 ~~ O(n^2) -->
              <!-- TODO: Logarithmic time O(log(n)): we can omit the base because log functions are proportional, though usually base 2 -->
              <!-- TODO: O(n*log(n)): common with sorting -->
              <!-- TODO: Exponential time O(2^n): very bad; adding one more item doubles the time it takes; complete outcome analysis--chess? -->
            <!-- TODO: How to trace algorithmic steps -->
              <!-- TODO: Leave off lower order terms: statements that are only done once are ignored -->
              <!-- TODO: Easiest strategy: work from the inside->out, at each step asking if each statement depends on the size of the input -->
                <!-- TODO: Loop body constant time? OK -->
                <!-- TODO: Loop executes N times? OK that's constant (1) * linear (N) = N times -->
              <!-- TODO: What if loops are nested and both iterate N times? O(n^2) -->
              <!-- TODO: What if loops are nested and inner loop iterates i times where i = the outer loop's iterator? -->
                <!-- TODO: We can add i, N times, which is N(N-1)/2, giving us quadratic time: O(n^2) -->
              <!-- TODO: Pitfall: calling functions is not necessarily constant time if that function call involves a loop or something other than constant time -->
              <!-- TODO: Binary search: log(n) -->
            <!-- TODO: Example comparing our linked list circularity function -->
            
          <!-- TODO: Sorting -->
            <!-- TODO: Selection sort: -->
              <!-- TODO: | 1 8 2 3 4 7 5 6 -->
              <!-- TODO: 1 | 8 2 3 4 7 5 6 -->
              <!-- TODO: 1 2 | 8 3 4 7 5 6 -->
              <!-- TODO: 1 2 3 | 8 4 7 5 6 -->
              <!-- TODO: 1 2 3 4 | 8 7 5 6 -->
              <!-- TODO: 1 2 3 4 5 | 7 8 6 -->
              <!-- TODO: 1 2 3 4 5 6 | 8 7 -->
              <!-- TODO: 1 2 3 4 5 6 7 | 8 -->
              <!-- TODO: 1 2 3 4 5 6 7 8 | -->
              <!-- TODO: Terrible algorithm: only learning one thing per iteration: where 1 thing is meant to be; complexity of O(n^2) -->
            <!-- TODO: XKCD sort -->
              
          <!-- TODO: Project 3 -->
            <!-- TODO: enums? -->
            <!-- TODO: String streams -->
          
          
        </div>
      </div>
      <!-- END MAIN CONTENT -->
      
      
      
    </div>
    <!-- END WRAPPER -->
    
    <!-- BEGIN FOOTER -->
    <div id="footer">
      <div class="container">
        <div class="col-md-12 text-center">
          
        </div>
      </div>
    </div>
    <!-- END FOOTER -->
    
  </body>
</html>
