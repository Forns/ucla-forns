
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <title>Andrew Forney - UCLA CS</title>
    <link href="../../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../../../css/magic-bootstrap.css" rel="stylesheet" type="text/css">
    <link href="../../../css/main.css" rel="stylesheet" type="text/css">
    <script src="../../../js/lib/jquery-2.0.3.min.js"></script>
    <script src="../../../js/lib/bootstrap.min.js"></script>
    <script src="../../../js/lib/expanding.js"></script>
    <script src="../../../js/display/general/general-display.js"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
  </head>
  
  <body data-spy="scroll" data-target="#scrollspy">
    
    <!-- BEGIN WRAP -->
    <div id="wrap">
      
      <!-- BEGIN NAVIGATION -->
      <nav class='navbar navbar-default' role='navigation'>
        <div class='nav-accent'></div>
        <div class='container'>
          <div class='row'>
            <div class='col-md-12'>
              <div class='navbar-header'>
                <button class='navbar-toggle' type='button' data-toggle='collapse' data-target='.navbar-main-collapse'>
                  <span class='sr-only'>Toggle Navigation</span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                </button>
                <a class='navbar-brand' href='/~forns/'>
                  <span id='brand-text'>
                    Andrew Forney
                  </span>
                </a>
              </div>
              
              <div id='nav-main' class='collapse navbar-collapse navbar-main-collapse'>
                <ul class='nav navbar-nav navbar-right'>
                  
                  <li>
                    <a href='/~forns/about.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-user'></span>
                      </div>
                      <p class='text-center'>About</p>
                    </a>
                  </li>
                  
                  <li class='active'>
                    <a href='/~forns/classes.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-book'></span>
                      </div>
                      <p class='text-center'>Classes</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/contact.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-comment'></span>
                      </div>
                      <p class='text-center'>Contact</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/publications.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-file'></span>
                      </div>
                      <p class='text-center'>Publications</p>
                    </a>
                  </li>
                  
                </ul>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <!-- END NAVIGATION -->
      
      <!-- BEGIN MAIN CONTENT -->
      <div id="main-content" class="container">
        <div class="row">
          
          <!-- BEGIN SCROLLSPY -->
          <div class='col-md-2'>
            <div class="bs-sidebar hidden-print affix" role="complementary">
              <ul id='scrollspy' class="nav bs-sidenav">
              </ul>
            </div>
          </div>
          <!-- END SCROLLSPY -->
          
          <!-- BEGIN PRESENTATION CONTENT -->
          <div class='col-md-10 presentation-content' role='main'>
            <ol class="breadcrumb">
              <li><a href="../../../classes.html">Classes</a></li>
              <li><a href="./cs-31.html">Fall13 CS31</a></li>
              <li class="active">Week 8</li>
            </ol>
            
            <div id='review' class='scrollspy-element' scrollspy-title='Questions from Week 7'></div>
            <h1>Questions from Week 6</h1>
            <div>
              <p><strong>Q: Will using <code class='prettyprint'>strcat</code> append the null terminator at the end of the concatonated string for me?</strong></p>
              <p>A: As it turns out, yes! You're fine assuming null termination after using strcat, assuming of course that both your concatonating and concatonated cstrings are both valid and null-terminated
                themselves!</p>
              
              <br/>
              <p><strong>Q: What is a string literal and how is it treated in C++?</strong></p>
              <p>A: A string literal is simply a sequence of null-terminated characters that we can write in-line in our code. It is essentially a cstring, but with one major difference: we cannot modify
                the memory it occupies once we use it.</p>
              <p>So, for example:</p>
<pre class='prettyprint'>
  // [!] "testing" is a string literal
  // So, the following is OK:
  char c[] = "testing";
  
  // [!] We can even do the following, although
  // we never would:
  cout &lt;&lt; "test"[0] &lt;&lt; endl;
  
  // [X] "testing" is a string literal,
  // which occupies no writable memory,
  // so the following is NOT OK:
  "test"[0] = 'b';
</pre>
              <br/>
              <p>You can therefore think of string literals as read-only cstrings, which also explains why we can use them with the C++ string library.</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='introMem' class='scrollspy-element' scrollspy-title='Main Memory'></div>
            <h1>Remember Main Memory?</h1>
            <div>
              <p>Pointers put us closer to the memory than we've seen in the past, so let's start with a review of how our code and variables are stored in memory.</p>
              <p class='definition'><strong>Main Memory</strong> consists of a contiguous sequence of bytes (8 bits) that each have a memory address associated with them.</p>
              <p class='definition'><strong>Memory Addresses</strong> are just like indexes in an array; they are a sequential numbering of the memory cells.</p>
              <br/>
              
              <p>Pictorially, we think of main memory looking like the following, with each cell being 1 byte:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/fall-2013/cs-31/week-8/pointers0.PNG' />
              </div>
              <br/>
              
              <p>Now, the problem is that whenever I declare a variable on different computers with different types and possibly different compilers, I allocate a certain amount of memory.</p>
              <p>Because the amount of memory allocated might be different depending on these distinctions, I want an easy way of &quot;moving around&quot; memory and its contents (pointers!).</p>
              <p>Take the following simple statement for example: <code class='prettyprint'>int x = 16;</code></p>
              <p class='question' name='intro-q0'>Do I, as the programmer, know where the compiler is going to reserve space for x in memory?</p>
              <p class='answer' name='intro-q0'>No! The compiler will allocate space for x somewhere that is big enough to hold an int, and then place the value 16 inside.</p>
              <br/>
              
              <p>So imagine that on some computer, an int takes up 4 bytes of memory (WARNING: We are NOT guaranteed this!), and our compiler sticks it at memory address 1000, then in memory we have:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/fall-2013/cs-31/week-8/pointers1.PNG' />
              </div>
              <br/>
              
              <p>We'll leave the specifics of how x is stored in memory to an architecture class, but because we know it took up 4 bytes on our system, we know that it spans addresses 1000 - 1003.</p>
              <p>Similarly, when we declare an array of some type, we know a couple of things about how it gets represented in memory.</p>
              <p>Take the following initialization for example: <code class='prettyprint'>char c[] = &quot;cat&quot;;</code></p>
              <p>We are guaranteed a couple of things:</p>
              <ul class='indent-1'>
                <li><p>We know that each cell holding a character of the cstring &quot;cat&quot; will take up the same amount of space on any given system.</p></li>
                <li><p>
                  Each character in the cstring &quot;cat&quot; will be located contiguously in memory, meaning that if a <code class='prettyprint'>char</code> takes up 1 byte on our system, 
                  then above, c will take up 4 bytes of space in a row in memory (don't forget about the null terminator!).
                </p></li>
              </ul>
              <br/>
              <p>Pictorially, if our compiler decided to stick c starting at memory location 1000:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/fall-2013/cs-31/week-8/pointers2.PNG' />
              </div>
            </div>
            <hr/>
            
            
            <br/>
            <div id='introPointers' class='scrollspy-element' scrollspy-title='Pointers: Intro'></div>
            <h1>Pointers: You'll Love Them or You'll Hate Them</h1>
            <br/>
            <div>
              <p>And no, there's no middle ground... But first, a relevant <a href='http://xkcd.com/138/' target='_blank'>XKCD</a>:</p>
              <div class='text-center fit-pres'>
                <img src='http://imgs.xkcd.com/comics/pointers.png' />
              </div>
              <br/>
              <p class='question' name='intro-q1'>Let's start off small... what is a pointer?</p>
              <p class='answer' name='intro-q1'>A variable that stores a reference (memory address) to another variable, or more generally, to some location in memory.</p>
              <p class='question' name='intro-q2'>So, Andrew... why do we even have pointers (i.e., what's the point?)</p>
              <div class='answer' name='intro-q2'>
                <p>To make you suffer! Just kidding (kinda, but really):</p>
                <ul class='indent-1'>
                  <li><p>Interfacing with C libraries and other low-level programming requires that we deal with pointers a lot to access the memory more directly.</p></li>
                  <li><p>Pointers can be used to talk about types and classes (as we'll see later) in terms of other types and classes, which is useful for typecasting.</p></li>
                  <li><p>They can conveniently traverse a variety of collections like linked-lists and trees (both useful data structures introduced in CS32).</p></li>
                </ul>
              </div>
              <br/>
              <p>Alright, well why do men have nipples?</p>
              <p>I don't have *all* the answers...</p>
              <p>But what I *do* have are some programmatic tools to help us with pointers in C++:</p>
              
              <br/>
              <h3>Basics: Declaration and Initialization</h3>
              <p class='toolkit'><strong>The address-of operator (&amp;)</strong>: The address-of operator says &quot;give me the memory address of my rvalue,&quot; or the expression to the right of the ampersand.</p>
              <br/>
              <p>Specifically, in the case where the item we're requesting spans multiple bytes, the address-of operator returns the memory address of the first byte of that object.</p>
              <p>We can look at our previous examples from the memory section:</p>
              <p class='example'>Say we made the following variable initialization and our compiler gave us this picture:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/fall-2013/cs-31/week-8/pointers1.PNG' />
              </div>
              <br/>
              <p class='question' name='intro-q3'>What, then, is the value of <code class='prettyprint'>&amp;x</code>?</p>
              <p class='answer' name='intro-q3'>1000, because <code class='prettyprint'>&amp;x</code> says, &quot;Give me the memory address of x, my rvalue.&quot; Here, 1000 is the memory address of the start of x, so that's what we return.</p>
              <br/>
              
              <p>But now we should talk about pointers... I guess...</p>
              <p class='toolkit'>
                <strong>Pointers</strong> store memory addresses and are assigned a type corresponding to the type of variable that they point to.<br/><br/>
                We declare and initialize pointers using the * symbol:<br/>
                <code class='prettyprint'>&lt;type&gt;* &lt;name&gt;; // Declares a pointer of the given &lt;type&gt; and calls it &lt;name&gt;</code>.
              </p>
              <br/>
              <p>So, here are some legal pointer declarations:</p>
<pre class='prettyprint'>
  int* pointy;
  bool* sharp;
  char* thorny;
</pre>
              <br/>
              <p class='toolkit'>To <strong>initialize</strong> pointers, we give them memory addresses corresponding to locations of variables.</p>
<pre class='prettyprint'>
  // The variable being pointed at
  int pointedAt = 16;
  
  // The pointer that saves the memory location
  // of pointedAt, and so now effectively, points
  // at pointedAt
  int* pointer = &amp;pointedAt;
</pre>
              <br/>
              
              <p>Alright, great, so we've stored the memory addresses of some variables, how can pointers access the values that they point to?</p>
              <p class='toolkit'><strong>The dereference operator (*)</strong>: The dereference operator says &quot;Give me the value of whatever's at the address my rvalue is pointing to.&quot; NOTE: This means the rvalue must be a pointer, i.e., a memory address!</p>
              <br/>
              <p class='example'>What will the following code print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
    
  int main () {
      int pointedAt = -100;
      int* pointer = &amp;pointedAt;
      cout &lt;&lt; *pointer &lt;&lt; endl;
  }
</pre>
              <p>Assuming our system is representing ints with 4 bytes and the compiler reserved memory for pointedAt at address 1000, then:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/fall-2013/cs-31/week-8/pointers3.PNG' />
              </div>
              <br/>
              
              <p>Alright, so how about some nifty memory tricks for these operators?</p>
              <p class='toolkit'>To remember when to use &amp; and when to use *, think:<br/>
                <strong>Ampersand:</strong> Address<br/>
                <strong>Star:</strong> Substance
              </p>
              <br/>
              
              <p>But Andrew, * is technically an Aster--well fine then! Make your own damn memory trick!</p>
              <p>So let's see some information about the pointer we've constructed:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
      
  int main () {
      int pointedAt = -100;
      int* pointy = &amp;pointedAt;
  
      cout &lt;&lt; "The value of what pointy points at: " 
           &lt;&lt; *pointy &lt;&lt; endl;
      cout &lt;&lt; "The address of what pointy points at: " 
           &lt;&lt; pointy &lt;&lt; endl;
      cout &lt;&lt; "The address of where pointy is stored: " 
           &lt;&lt; &amp;pointy &lt;&lt; endl;
      // Will the above two be the same?
  }
</pre>
              <br/>
              <p>How about some examples?</p>
              <p class='debug'>Will the following code compile? Will it have any undefined behavior? If &quot;No&quot; to both questions, what will it print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
    
  int main () {
      int ruhRoh;
      int* pointy = &amp;ruhRoh;
      cout &lt;&lt; *pointy &lt;&lt; endl;
  }
</pre>
              <br/>
              <p class='debug'>Will the following code compile? Will it have any undefined behavior? If &quot;No&quot; to both questions, what will it print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
    
  int main () {
      int imAnInt = -100;
      int* pointy = imAnInt;
      cout &lt;&lt; *pointy &lt;&lt; endl;
  }
</pre>
              <br/>
              <p class='debug'>WARNING: Unlike with types such as int, double, bool, and char, which, when given another type can sometimes convert to the other, pointers have their own conversion rules.<br/>
                In this class, be aware that pointers should point to objects of their own type, or you'll likely get an error.
              </p>
              <p class='debug'>Will the following code compile? Will it have any undefined behavior? If &quot;No&quot; to both questions, what will it print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
    
  int main () {
      int imAnInt = 2;
      double imADouble = 2.2;
      int* pointy = &amp;imAnInt;
      cout &lt;&lt; *pointy &lt;&lt; endl;
      pointy = &amp;imADouble;
      cout &lt;&lt; *pointy &lt;&lt; endl;
  }
</pre>
              <p>We'll see why we have this type rigidity for pointers in a later section, and the issue is explored more in CS32.</p>
              <br/>
              
              <p class='definition'>Note: Reference and dereference operators could be considered inverses of one another, i.e., they &quot;undo&quot; each other.</p>
              <p class='debug'>Will the following code compile? Will it have any undefined behavior? If &quot;No&quot; to both questions, what will it print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
    
  int main () {
      int imAnInt = -100;
      int* pointy = &amp;*&amp;imAnInt;
      cout &lt;&lt; *pointy &lt;&lt; endl;
  }
</pre>
              <br/>
              <p class='debug'>Will the following code compile? Will it have any undefined behavior? If &quot;No&quot; to both questions, what will it print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
    
  int main () {
      int imAnInt = 2;
      int* pointy = &amp;imAnInt;
      cout &lt;&lt; *(&amp;(*pointy)) &lt;&lt; endl;
  }
</pre>

              <br/>
              <h3>Basics: Assigning to Pointers</h3>
              <p>Knowing when to use the reference and dereference operators is a bit tricky, and so the best thing to do is to translate your intent into English first.</p>
              <p class='toolkit'>Whenever we want to assign a value to the memory location that a pointer is pointing to, we use the following syntax:<br/><br/>*ptr = value;</p>
              <br/>
              <p class='example'>Translate the following pointer statements into English analyses of what they're doing. The first is done for you:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
    
  int main () {
      // Variables to be pointed at
      int i = 0;
      double d = 3.3;
      bool b;
  
      // Pointers
  
      // An integer pointer that points to the memory address
      // at which int i is located
      int* iPtr = &amp;i;
  
      // What's happening here?
      double* dPtr = &amp;*&amp;d;
  
      // Is this going to be a problem? If so, when?
      bool* bPtr = &amp;b;
  
      // What's happening here?
      *iPtr = 20;
  
      // What's happening here?
      *&amp;*dPtr = 3.33;
  
      b = (*iPtr % 2 == 0) || (*dPtr &gt; 4);
  
      cout &lt;&lt; i &lt;&lt; endl;
      cout &lt;&lt; *iPtr &lt;&lt; endl;
      cout &lt;&lt; d &lt;&lt; endl;
      cout &lt;&lt; *dPtr &lt;&lt; endl;
      cout &lt;&lt; b &lt;&lt; endl;
      cout &lt;&lt; *bPtr &lt;&lt; endl;
  }
</pre>
              <br/>
              <p class='toolkit'>It's also perfectly legal to assign pointers to each other (i.e., store the same memory address in two pointers), so long as the types agree:</p>
              <p class='example'>What will the following code print out? Answer the questions in the comments below.</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
      
  int main () {
      int pointedAt = 1;
      int* pointy = &pointedAt;
      // ditto used point!
      int* ditto = pointy;
  
      // Will these 2 be equal?
      cout &lt;&lt; *pointy &lt;&lt; endl;
      cout &lt;&lt; *ditto &lt;&lt; endl;
  
      // Will these 2 be equal?
      cout &lt;&lt; pointy &lt;&lt; endl;
      cout &lt;&lt; ditto &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>But what about uninitialized pointers?</p>
              <p class='debug'>Will the following code compile? Will it have any undefined behavior? If &quot;No&quot; to both questions, what will it print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
    
  int main () {
      // To what is lamePointz pointing after this line?
      int* lamePointz;
      // To what address are we making this assignment?
      *lamePointz = 5;
  
      cout &lt;&lt; *lamePointz &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>So be careful! Uninitialized pointers can lead to undefined behavior or illegal memory accesses when they haven't been assigned somewhere first.</p>
              <p>What can we do to be safe about uninitialized pointers?</p>
              <p>There is a special keyword called <code class='prettyprint'>nullptr</code> that represents &quot;the pointer that points at nothing.&quot;</p>
              <p>Andrew, that's very zen, we should stop and ponder life.</p>
              <p>Nonsense! There are pointers to discuss!</p>
              <br/>
              <p class='toolkit'>The <strong>nullptr</strong> keyword is a pointer literal that indicates a pointer that isn't pointing anywhere. We use it for safety (to not dereference an undefined pointer) and clarity.</p>
              <p class='debug'>WARNING: attempting to dereference a nullptr will result in undefined behavior, though many compilers are optimzed to spot dereference of nullptrs and handle them appropriately.</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
      
  int main () {
      // lamePointz is now safely pointing at nothing
      int* lamePointz = nullptr;
      
      // ...so later when we try to dereference and assign...
      *lamePointz = 5;
      
      // ...our code will break, but it will break reliably,
      // indicating that we have an error in the code, rather
      // than continuing blissfully unaware of our mistake
      // as we may have possibly done in the example above
    
      cout &lt;&lt; *lamePointz &lt;&lt; endl;
  }
</pre>
              <br/>
              <p class='toolkit'>Just because dereference is undefined for nullptrs, we can still check to make sure a pointer is or is not the null pointer (test for equivalence):</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
      
  int main () {
      int i = 50;
      int* latePointer = nullptr;
  
      if (latePointer == nullptr) {
          latePointer = &amp;i;
      } else {
          cout &lt;&lt; "&lt;_&lt; &gt;_&gt;" &lt;&lt; endl;
      }
      cout &lt;&lt; *latePointer &lt;&lt; endl;
  }
</pre>
              <br/>
              <p class='debug'>Will the following code compile? Will it have any undefined behavior? If &quot;No&quot; to both questions, what will it print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
    
  int main () {
      int* possiblyLame;
      int x = 50;
      possiblyLame = &amp;x;
  
      cout &lt;&lt; *possiblyLame &lt;&lt; endl;
  }
</pre>
              <br/>
              <p class='example'>What will the following code print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
        
  int main () {
      int i[][3] = {
          {1, 2, 3},
          {4, 5, 6}
      };
  
      int*  pointy = &amp;i[1][1];
      int*  copyPointy = pointy;
  
      // [!] This is a pointer reference! i.e., refPointy
      // is just another name for pointy
      int*&amp; refPointy = pointy;
  
      *pointy = 100;
      pointy = &amp;i[0][2];
  
      cout &lt;&lt; *pointy &lt;&lt; endl;
      cout &lt;&lt; *copyPointy &lt;&lt; endl;
      cout &lt;&lt; *refPointy &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>This example segues into our discussion of pointers and arrays quite nicely...</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='arrayPointers' class='scrollspy-element' scrollspy-title='Pointers &amp; Arrays'></div>
            <h1>Pointers &amp; Arrays</h1>
            <br/>
            <div>
              <p>Pointers may have felt like an exercise in futility before now, but they make a little more sense when it comes to arrays.</p>
              <p>Let's return with our simple example from before, this time, assuming the compiler has placed the array c at index 4000, but still treats characters as 1 byte a piece:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/fall-2013/cs-31/week-8/pointers4.PNG' />
              </div>
              <br/>
              
              <p>But wait a second... I drew an arrow from c to the start of the array in memory... could it be?</p>
              <p>Could our array identifiers actually be... pointers?!</p>
              <p>In a twist more dramatic than the conclusion of Survivor XXI, the answer is: yes, with one difference: once we've declared an array to an identifier (i.e., using the [] notation and reserving memory for it), 
                we can't reassign it (seen later).</p>
              <br/>
                
              <p>So what has our bracket notation for array indecies meant this whole time?</p>
              <p class='toolkit'>The bracket notation of pointers can be thought of as &quot;dereference with offset,&quot; meaning that, if ptr is a pointer:<br/><br/>
                <code class='prettyprint'>ptr[offset]</code> is equivalent to saying <code class='prettyprint'>*(ptr + offset)</code>, meaning &quot;Give me the value at offset locations away from memory address ptr.&quot;
              </p>
              <p class='toolkit'>A <strong>pointer offset</strong> is a number indicating how many x bytes away the next or previous value is, depending on the type of the pointer.<br/><br/>
                For example, if an int is treated as 4 bytes, and I want to access the int directly following the int at address 1000 (as in an int array starting at address 1000), then 
                an int pointer offset of 1 tells me to look 4 bytes later, at memory address 1004. Similarly, an int pointer offset of -2 tells me to look 8 bytes before, at memory address 992, etc.
              </p>
              <br/>
              <p>So let's look at our example again in terms of offsets:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/fall-2013/cs-31/week-8/pointers5.PNG' />
              </div>
              <br/>
              
              <p>A couple things to note above:</p>
              <ul class='indent-1'>
                <li><p>Notice how c is an array of chars, and so c is a char pointer, meaning that its offsets assume the next char is 1 byte away.</p></li>
                <li><p>The bracket c[i] notation is equivalent to the offset *(c + i) notation.</p></li>
                <li><p>Although we could generate a pointer to c[4] by saying &amp;c[4], it would be unsafe to assign anything to c[4] (overflow).</p></li>
              </ul>
              <br/>
              <div class='question' name='arrays-q0'>OK, so if I had an array of ints where ints were treated as 4 bytes a piece, then fill in the blanks below:<br/>
                <div class='text-center fit-pres'>
                <img src='../../../assets/images/fall-2013/cs-31/week-8/pointers6q.PNG' />
              </div>
              </div>
              <div class='answer' name='arrays-q0'>
                <div class='text-center fit-pres'>
                <img src='../../../assets/images/fall-2013/cs-31/week-8/pointers6a.PNG' />
              </div>
              </div>
              <br/>
              <p class='definition'>Takeaway message: Every time I use an offset with a pointer, it automatically scales to how large its type is in memory.</p>
              <p>Alright, back to our character array example...</p>
              <p>Although c is still an identifier used as a pointer, because it was declared as an array, we cannot change its value...</p>
              <p class='debug'>WARNING: Remember that, although an identifier bound to an array upon declaration points to that arrays first element, unlike other pointers, it cannot change to where it points.
                <br/><br/>For example:<br/><code class='prettyprint'>char c[] = "cat"; // we can never change what c points to</code><br/><code class='prettyprint'>char* c2 = c; // c2 can change what it points to</code></p>
              <p class='toolkit'>We can modify a pointer's memory address through increment and decrement whenever that pointer is modifiable, for example:<br/>
                <code class='prettyprint'>char* ptr = c; ptr++; // ptr now points to the address one char-length (1 byte) after c</code></p>
              
              <br/>
              <p class='debug'>Will the following code compile? If so, what will it print?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
      
  int main () {
      char c[] = "cat";
      int len = strlen(c);
  
      for (int i = 0; i &lt; len; i++) {
          cout &lt;&lt; c[0] &lt;&lt; endl;
          c++; // hey! that's this language!
      }
  }
</pre>
              <br/>
              <p>So how could we do what the above is trying to do? Well, we can use another pointer to refer to where c starts:</p>
              <p class='debug'>Will the following code compile? If so, what will it print?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
      
  int main () {
      char c[] = "cat";
      char* helper = c;
      int len = strlen(c);
  
      for (int i = 0; i &lt; len; i++) {
          cout &lt;&lt; helper[0] &lt;&lt; endl;
          helper++;
      }
  }
</pre>
              <br/>
              <p>I could even condense the above using some pointer dereferences:</p>
              <p class='debug'>Will the following code compile? If so, what will it print?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
      
  int main () {
      char c[] = "cat";
  
      for (char* helper = c; *helper != '\0'; helper++) {
          cout &lt;&lt; helper[0] &lt;&lt; endl;
      }
  }
</pre>
              <br/>
              <p class='debug'>Will the following code compile? If so, what will it print?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
      
  int main () {
      char c[] = "cat";
  
      for (char* helper = c; *helper != '\0'; helper++) {
          // What happens when we just print out c?
          cout &lt;&lt; helper &lt;&lt; endl;
      }
  }
</pre>
              <br/>
              <p class='debug'>Will the following code compile? If so, what will it print?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
      
  int main () {
      char c[] = "cat";
      
      // Notice our new iterator increment...
      for (char* helper = c; *helper != '\0'; helper = &amp;helper[1]) {
          cout &lt;&lt; helper[0] &lt;&lt; endl;
      }
  }
</pre>
              
              <br/>
              <h3>Pointer Arithmetic and Operators</h3>
              <p>We've seen a couple of pointer operations already, but some are not well defined.</p>
              <p class='toolkit'>Subtraction and addition to pointers is well defined, such that if I say (ptr + i), it means &quot;refer to the address i times x bytes away from ptr,&quot; where x is the size of the type of ptr.</p>
              <p class='example'>What will the following code output?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
      
  int main () {
      double d[] = {1.1, 2.2, 3.3, 4.4, 5.5};
      double* ptr = d;
  
      // Here, I'm referencing offsets from ptr
      cout &lt;&lt; *ptr &lt;&lt; endl;
      cout &lt;&lt; *(ptr + 1) &lt;&lt; endl;
      cout &lt;&lt; ptr[2] &lt;&lt; endl;
  
      // Note where ptr points now that I've
      // reassigned it
      ptr += 2;
      cout &lt;&lt; ptr[2] &lt;&lt; endl;
  }
</pre>
              <br/>
              <p class='debug'>WARNING: Be wary of using the postfix increment operator with pointers; remember that they increment the lvalue after everything else is done...</p>
              <p class='debug'>Will the following code compile? Will it have any undefined behavior? If &quot;No&quot; to both questions, what will it print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
      
  int main () {
      int pointedAt = 1;
      int* pointy = &pointedAt;
  
      *pointy++;
  
      cout &lt;&lt; *pointy &lt;&lt; endl;
      cout &lt;&lt; pointedAt &lt;&lt; endl;
  }
</pre>
              <p class='toolkit'>Pointers are NOT defined on multiplication or division; why would you do that to a memory address? :(</p>
              <p class='debug'>Will the following code compile? If so, what will it print?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
      
  int main () {
      double d[] = {1.1, 2.2, 3.3, 4.4, 5.5};
      double* ptr = d;
  
      // Derp!
      cout &lt;&lt; *(ptr * 2) &lt;&lt; endl;
  }
</pre>
              <p class='toolkit'><strong>Pointer Comparisons</strong><br/>Pointers can always be compared for equivalence (do they point to the same address), but we must be careful... we still don't know where variables will be placed in memory at runtime.</p>
              <p>A consequence of not knowing where our variables live in memory can be undefined behavior:</p>
              <p class='debug'>Will the following code compile? Is there any undefined behavior possible? If &quot;No&quot; to both, what will it print?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
      
  int main () {
      char c[] = "cat";
      char t[] = "dog";
      char* cPtr = c;
      char* tPtr = t;
      int len = strlen(c);
  
      for (int i = 0; i &lt; len; i++) {
          if (cPtr &lt; tPtr) {
              cout &lt;&lt; "cPtr: " &lt;&lt; cPtr &lt;&lt; endl;
          } else {
              cout &lt;&lt; "tPtr: " &lt;&lt; tPtr &lt;&lt; endl;
          }
      }
  }
</pre>
              <p>Thus, there is no *guarantee* that tPtr will always be greater than cPtr, even though it might appear to work. Unpredictable behavior!</p>
              <p>That said...</p>
              <p class='toolkit'>Pointers *within* the same array are always guaranteed to be comparable using &lt;, &gt;, etc. because array elements are located contiguously in memory.</p>
              <p class='debug'>Will the following code compile? Is there any undefined behavior possible? If &quot;No&quot; to both, what will it print?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
      
  int main () {
      char c[] = "catdog";
      char* cPtr = c;
      int len = strlen(c);
  
      for (int i = 0; i &lt; len; i++) {
          if (cPtr &lt; &amp;c[3]) {
              cout &lt;&lt; *cPtr &lt;&lt; endl;
              cPtr++;
          }
      }
  }
</pre>
              <br/>
              <p class='toolkit'>When two pointers are operating in the same array, we can even subtract them to learn their *offsets,* not their difference in bytes.</p>
              <br/>
              <p>For example:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
        
  int main () {
      int i[] = {1, 2, 3, 4};
      int* p1 = i;
      int* p2 = (i + 2);
  
      // [?] What gets printed below?
      cout &lt;&lt; (p1 - p2) &lt;&lt; endl;
      cout &lt;&lt; (p2 - p1) &lt;&lt; endl;
  }
</pre>
              <br/>
              <p class='debug'>Will the following code compile? Is there any undefined behavior possible? If &quot;No&quot; to both, what will it print?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
      
  int main () {
      int i[] = {5, 6, 7, 8, 9};
      int* iPtr = i;
      int len = 3;
  
      for (int j = 0; j &lt; len; j++) {
          if (iPtr &lt; &amp;i[3]) {
              // What will print here?
              cout &lt;&lt; (&amp;i[3] - iPtr) &lt;&lt; endl;
              iPtr++;
          }
      }
  }
</pre>
              <br/>
              <p class='debug'>WARNING: While it is perfectly legal to subtract two pointers, and well defined when they are in the same array, it is NOT legal to add two pointers.</p>
              <p>Alright, see if you can get THIS:</p>
              <p class='example'>What does the following code print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cctype&gt;
  using namespace std;
  
  int main () {
      char c[] = "testing";
      int len = strlen(c);
      
      for (int i = 0; i &lt; len / 2; i++) {
          char* front = &amp;c[i];
          char* back = &amp;c[len - i - 1];
          char stuff = *front;
          *front = *back;
          *back = stuff;
      }
      
      cout &lt;&lt; c &lt;&lt; endl;
  }
</pre>
            </div>
            <hr/>
            
            
            <br/>
            <div id='pointerFuncs' class='scrollspy-element' scrollspy-title='Pointers &amp; Functions'></div>
            <h1>Pointers &amp; Functions</h1>
            <br/>
            <div>
              <p>So let's talk about using functions with pointers... we've unlocked a whole new world of return and parameter types.</p>
              <div class='toolkit'><p>We can accept pointer parameters using a variety of notations:<br/><br/></p>
<pre class='prettyprint'>
  void pointerFunc (int* i, int p[]) {
      ...
  }
</pre>
              <p>Above, both i and p refer to int pointer parameters.</p>
              </div>
              <br/>
              <p class='example'>What does the following code print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  int* findInt (int arr[], int len, int match) {
      for (int i = 0; i &lt; len; i++) {
          if (arr[i] == match) {
              return &amp;arr[i];
          }
      }
      // Case where there is no match!
      return nullptr;
  };
  
  int main () {
      int i[] = {5, 6, 7, 8, 9};
      int* ptr = findInt(i, 5, 7);
  
      if (ptr != nullptr) {
          cout &lt;&lt; *ptr &lt;&lt; endl;
      } else {
          cout &lt;&lt; "null!" &lt;&lt; endl;
      }
  }
</pre>
              <br/>
              <p>Note, I could have just as easily written the following parameter definition for the input array:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  // See the difference?
  int* findInt (int* arr, int len, int match) {
      for (int i = 0; i &lt; len; i++) {
          if (arr[i] == match) {
              return &amp;arr[i];
          }
      }
      // Case where there is no match!
      return nullptr;
  };
  
  int main () {
      int i[] = {5, 6, 7, 8, 9};
      int* ptr = findInt(i, 5, 7);
  
      if (ptr != nullptr) {
          cout &lt;&lt; *ptr &lt;&lt; endl;
      } else {
          cout &lt;&lt; "null!" &lt;&lt; endl;
      }
  }
</pre>
              <br/>
              <p>Perhaps the most important thing to know about pointer parameters:</p>
              <p class='toolkit'>Pointer parameters are <strong>passed by value,</strong> meaning a copy of the address is made and is named by the parameter. The values that pointer can dereference and change are NOT copied.</p>
              <br/>
              
              <p>This explains why we can pass arrays using the pointer notation and still change the individual array elements without changing the pointer itself.</p>
              <p class='example'>What will the ptr in main point to after the function call to findInt?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  void findInt (int arr[], int len, int match, int* ptr) {
      for (int i = 0; i &lt; len; i++) {
          if (arr[i] == match) {
              ptr = &amp;arr[i];
              return;
          }
      }
      ptr = nullptr;
  };
  
  int main () {
      int i[] = {5, 6, 7, 8, 9};
      int* ptr = i;
      findInt(i, 5, 7, ptr);
  
      if (ptr != nullptr) {
          cout &lt;&lt; *ptr &lt;&lt; endl;
      } else {
          cout &lt;&lt; "null!" &lt;&lt; endl;
      }
  }
</pre>
              
              <br/>
              <h3>Side-Notes about Functions</h3>
              <p>If we wanted to set the ptr in main to what was changed in findInt, we'd just make sure to pass by reference via: <code class='prettyprint'>int* &amp;ptr</code></p>
              <br/>
              <p>One might ask, then, what the difference is between pointers and references, and the answer is a subtle one (great discussion found <a href='http://stackoverflow.com/questions/57483/what-are-the-differences-between-pointer-variable-and-reference-variable-in-c' target='_blank'>here</a>):</p>
              <ul class='indent-1'>
                <li><p>A pointer can be reassigned any number of times while a reference can not be after initialization.</p></li>
                <li><p>A pointer can be set to the nullptr while references can never point to null (they are just names for other variables).</p></li>
                <li><p>You can not generate the address of a reference like you can with pointers.</p></li>
                <li><p>There are no &quot;reference arithmetics&quot; like we do with pointers (e.g., *(ptr + 1) or &amp;ptr + 4)</p></li>
              </ul>
              <br/>
              <p class='debug'>WARNING: What happens to local variables in a function once we return from that function?</p>
              <p>They are no longer safely allocated in memory! This means that I cannot guarantee that any variable local to a function will still be there after I've returned.</p>
              <p>Take the following for example:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cctype&gt;
  using namespace std;
  
  void naughtyFunc (int*&amp; n) {
      // What happens to i after naughtyFunc returns?
      int i[] = {5, 6, 7};
      n = i;
  }
  
  int main () {
      int* n;
      naughtyFunc(n);
      for (int i = 0; i &lt; 3; i++) {
          cout &lt;&lt; n[i] &lt;&lt; endl;
      }
  }
</pre>
              <p>The above code has unpredictable behavior because we do not know what has happened to i after naughtyFunc has returned, as i is no longer allocated space in memory (remnants may still remain as junk).</p>
              <br/>
              <p>Finally, a couple of examples and exercises:</p>
              <p class='example'>What will the following code print out? Warning, maturity levels are reaching 0...</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cctype&gt;
  using namespace std;
  
  char* secretDecoder (char c[], int i[], int n) {
      for (int j = 0; j &lt; n; j++) {
          c[j] = c[*(i+j)];
      }
      c[n] = '\0';
      return c;
  }
  
  int main () {
      char c[] = "disproportionate";
      int i[] = {3, 5, 1, 0};
      // :D
      char* d = secretDecoder(c, i, 4);
      
      cout &lt;&lt; d &lt;&lt; endl;
  }
</pre>
              <br/>
              <p class='example'>Define a function, ptrsToMinMax that takes in an arrays of ints, the size of that array, and two int pointers, and then sets each pointer equal to the address holding the minimum and maximum values
                within that array.</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cassert&gt;
  using namespace std;
  
  void ptrToMinMax (int arr[], int*&amp; min, int*&amp; max, int n);
  
  int main () {
      int arr[] = {1, 5, 0, 2, 4};
      int* min;
      int* max;
  
      ptrToMinMax(arr, min, max, 5);
  
      assert(*min == 0);
      assert(*max == 5);
  
      cerr &lt;&lt; "[!] ALL TESTS PASSED!" &lt;&lt; endl;
  }
  
  void ptrToMinMax (int arr[], int*&amp; min, int*&amp; max, int n) {
      // Simply return if n is 0 or below
      if (n &lt;= 0) {
          return;
      }
      
      // [!] We'll start off both of our min max pointers
      // at the first element
      min = ???
      max = ???
      
      // Iterate through all n elements of arr
      for (int i = 0; i &lt; n; i++) {
        
          // [!] If the current element is less than the min
          // we'll set the min to that element
          if ( ??? ) {
              min = ???
          }
          
          // [!] If the current element is greater than the
          // max, we'll set the max to that element
          if ( ??? ) {
              max = ???
          }
      }
  }
</pre>
            </div>
            <hr/>
            <br/>
            
            
            <div id='midterm' class='scrollspy-element' scrollspy-title='Midterm'></div>
            <h1>Midterm</h1>
            <div>
              <p>Note: although I've seen the format of the past midterms, that may or may not be indicative of future formats!</p>
              <div class='debug'><p>Studying tips:</p>
                <ul class='indent-1'>
                  <li><p>Know your syntax, know your syntax, know your syntax. Don't know how to specify arrays and cstrings? Hit the books!</p></li>
                  <li><p>Arrays, cstrings, and functions are the largest portions of the exam.</p></li>
                  <li><p>Try to do the practice examples by hand... you won't have an IDE to tell you that you missed a semi-colon!</p></li>
                  <li><p>Be comfortable spotting bugs! Pay careful attention to uninitialized variables and syntax errors!</p></li>
                </ul>
              </div>
              <br/>
              <p class='debug'>You MUST sign up for a midterm time on the course website under "Announcements."</p>
              <p class='definition'>
                The midterm covers everything in the past weeks up until pointers (pointers will NOT be on the exam). Reviewing my lecture notes and doing the practice examples will set you on the right path.
              </p>
              <p class='definition'>
                You are allowed to bring a single 8.5&quot; x 11&quot; sheet of notes, double sided, printed or hand-written into the midterm exam. (double check on this -- it's been true in previous years)
              </p>
              <p class='definition'>I have launched a practice midterm II on my course site, though if you'd like practice on anything more that isn't listed there, let me know and I'll make something up!</p>
            </div>
            
          </div>
          <!-- END PRESENTATION CONTENT -->
          
          
        </div>
      </div>
      <!-- END MAIN CONTENT -->
      
      
    </div>
    <!-- END WRAPPER -->
    
    <!-- BEGIN FOOTER -->
    <div id="footer">
      <div class="container">
        <div class="col-md-12 text-center">
          
        </div>
      </div>
    </div>
    <!-- END FOOTER -->
    
  </body>
</html>
