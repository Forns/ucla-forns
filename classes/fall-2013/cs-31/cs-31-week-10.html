
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <title>Andrew Forney - UCLA CS</title>
    <link href="../../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../../../css/magic-bootstrap.css" rel="stylesheet" type="text/css">
    <link href="../../../css/main.css" rel="stylesheet" type="text/css">
    <script src="../../../js/lib/jquery-2.0.3.min.js"></script>
    <script src="../../../js/lib/bootstrap.min.js"></script>
    <script src="../../../js/display/general/general-display.js"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
  </head>
  
  <body data-spy="scroll" data-target="#scrollspy">
    
    <!-- BEGIN WRAP -->
    <div id="wrap">
      
      <!-- BEGIN NAVIGATION -->
      <nav class='navbar navbar-default' role='navigation'>
        <div class='nav-accent'></div>
        <div class='container'>
          <div class='row'>
            <div class='col-md-12'>
              <div class='navbar-header'>
                <button class='navbar-toggle' type='button' data-toggle='collapse' data-target='.navbar-main-collapse'>
                  <span class='sr-only'>Toggle Navigation</span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                </button>
                <a class='navbar-brand' href='/~forns/'>
                  <span id='brand-text'>
                    Andrew Forney
                  </span>
                </a>
              </div>
              
              <div id='nav-main' class='collapse navbar-collapse navbar-main-collapse'>
                <ul class='nav navbar-nav navbar-right'>
                  
                  <li>
                    <a href='/~forns/about.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-user'></span>
                      </div>
                      <p class='text-center'>About</p>
                    </a>
                  </li>
                  
                  <li class='active'>
                    <a href='/~forns/classes.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-book'></span>
                      </div>
                      <p class='text-center'>Classes</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/contact.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-comment'></span>
                      </div>
                      <p class='text-center'>Contact</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/publications.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-file'></span>
                      </div>
                      <p class='text-center'>Publications</p>
                    </a>
                  </li>
                  
                </ul>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <!-- END NAVIGATION -->
      
      <!-- BEGIN MAIN CONTENT -->
      <div id="main-content" class="container">
        <div class="row">
          
          <!-- BEGIN SCROLLSPY -->
          <div class='col-md-2'>
            <div class="bs-sidebar hidden-print affix" role="complementary">
              <ul id='scrollspy' class="nav bs-sidenav">
              </ul>
            </div>
          </div>
          <!-- END SCROLLSPY -->
          
          <!-- BEGIN PRESENTATION CONTENT -->
          <div class='col-md-10 presentation-content' role='main'>
            <ol class="breadcrumb">
              <li><a href="../../../classes.html">Classes</a></li>
              <li><a href="./cs-31.html">Fall13 CS31</a></li>
              <li class="active">Week 10</li>
            </ol>
            
            <div id='announcements' class='scrollspy-element' scrollspy-title='Announcements'></div>
            <h1>Announcements</h1>
            <div>
              <p>Just a few notes before we start today's section:</p>
              <p>
                ...starting with candy! I grant unto you more of my inexhaustible Halloween reserve in an effort to thank you for filling out the study survey, completing my evaluations, 
                and to keep you <span class='strike'>bribed</span> energized with sugar for class.
              </p>
              <p class='definition'>Sooo Saturday Final everybody! Make sure you know which room you're in as follows:</p>
              <ul class='indent-1'>
                <li><p>From 11:30 AM to 2:00 PM in <strong>Broad 2160E</strong> if you are officially enrolled in lecture 1 and your last name does not begin with Z, O, M, B, I, or E</p></li>
                <li><p>From 11:40 AM to 2:10 PM in <strong>Dodd 147</strong> if your last name begins with Z, O, M, B, I, or E, or if you are officially enrolled in lecture 2</p></li>
              </ul>
              <p class='definition'>You are allowed TWO, count them, TWO cheat sheets for the final... double sided!</p>
              <p></p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='dynamicMem' class='scrollspy-element' scrollspy-title='Dynamic Memory'></div>
            <h1>Dynamic Memory</h1>
            <div>
              <p>Just when you thought you could forget about memory (fact: that pun is inexaustible), we start talking about dynamic memory...</p>
              <p>So what's the big deal about this <code class='prettyprint'>new</code> craze called dynamic memory?</p>
              <p>Well, let's think about the memory we've been using in the recent past...</p>
              <p class='question' name='dyn-q0'>When we wanted to create an array of ints, do we always have to somehow specify its size? Could this be done at runtime?</p>
              <div class='answer' name='dyn-q0'><p>In our experience, we needed to specify the size of an array; sometimes this could be inferred via syntax: 
                <code class='prettyprint'>int i[] = {1, 2, 3};</code> but size allocations like the following could not be done at runtime:</p>
<pre class='prettyprint'>
  ...
  int count;
  cin &gt;&gt; count;
  
  // Would this be legal?
  int i[count];
  ...
</pre>
              </div>
              <p>But Andrew... does that mean we are forever bound to specifying our memory allocations at runtime?</p>
              <p>Will we ever be free of these shackles?</p>
              <p>Fear not, for now we turn to Dynamic Memory.</p>
              <p class='question' name='dyn-q1'>So for starters... what is dynamic memory?</p>
              <p class='answer' name='dyn-q1'>Dynamic Memory is the runtime-capable allocation of memory that is managed by the programmer. It is used for allocating some amount of memory unknown at compile time.</p>
              <p>We should discuss a couple of topics to see the big difference between dynamic memory and local allocations.</p>
              <p>For starters, the memory location in which we've previously been storing variables is called the stack.</p>
              <p class='definition'>The <strong>stack</strong>, more formally known as the call stack, pushes local variables onto its top as they are declared, and then &quot;pops&quot; them from the top when they fall out of scope.</p>
              <p>
                The big difference between this act of &quot;popping&quot; a variable from memory is done automatically with scope when variables are stored in the stack, but is NOT done without programmer 
                intervention with dynamic memory.
              </p>
              <p>So if dynamic variables aren't kept in the stack like with our previously experienced variables, where are they kept?</p>
              <p class='definition'>The <strong>heap</strong>, by contrast, is where dynamic memory is allocated, and does not operate in the same &quot;stacked&quot; fashion that the... well... stack does.</p>
              <p>So let's just review some key differences between the two:</p>
              <table class='table table-striped table-bordered'>
                <thead>
                  <tr>
                    <th></th>
                    <th><p>Stack</p></th>
                    <th><p>Heap</p></th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <th><p>What variables live here?</p></th>
                    <td>
                      <p>Local variables, functions, function arguments, etc.</p>
                    </td>
                    <td>
                      <p>Dynamically allocated memory reserved by the programmer</p>
                    </td>
                  </tr>
                  <tr>
                    <th><p>How can variables be accessed?</p></th>
                    <td>
                      <p>By any type of identifier defined in scope</p>
                    </td>
                    <td>
                      <p>Only through pointers!</p>
                    </td>
                  </tr>
                  <tr>
                    <th><p>Best for storing:</p></th>
                    <td>
                      <p>Local variables that are specific to limited scopes</p>
                    </td>
                    <td>
                      <p>Variables whose size is not known at compile-time</p>
                    </td>
                  </tr>
                  <tr>
                    <th><p>Memory is allocated:</p></th>
                    <td>
                      <p>Whenever a variable is declared in scope</p>
                    </td>
                    <td>
                      <p>Whenever the <code class='prettyprint'>new</code> keyword is used to initialize a variable and call a constructor</p>
                    </td>
                  </tr>
                  <tr>
                    <th><p>Memory is freed / deallocated:</p></th>
                    <td>
                      <p>Whenever a variable disappears from scope (e.g., local variables in a function after returning from that function)</p>
                    </td>
                    <td>
                      <p>Only after the delete keyword is used!</p>
                    </td>
                  </tr>
                </tbody>
              </table>
              <br/>
              <p>So in brief: dynamic memory gives us the luxury of allocating memory on-the-fly during runtime, but at the cost of some performance and the necessity to keep track of deallocating memory ourselves.</p>
              <p class='question' name='dyn-q2'>So why do we need to deallocate the memory we've dynamically reserved?</p>
              <p class='answer' name='dyn-q2'>Well, we allocated it on our own so we must also deallocate it on our own, or else the compiler won't know if it's still needed or not!</p>
              <p>Now that we have the background in place, let's take a look at the specifics of using dynamic memory in C++:</p>
              <br/>
              
              <h3>Memory Allocation Syntax</h3>
              <div class='definition'>
                <p>To dynamically allocate memory for a given object, we use the <code class='prettyprint'>new</code> keyword. The new keyword invokes a constructor for a given object
                based on that constructor's expected parameters:</p><br/><br/>
<pre class='prettyprint'>
  // For any number of expected constructor
  // parameters (including none)
  &lt;type&gt;* &lt;name&gt; = new &lt;type&gt;(parameter1, parameter2, ...);
</pre>
              </div>
              <p>Why not some examples?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct dullExample {
      int i;
      string s;
  
      // Default constructor
      dullExample () {
          i = 5;
          s = "wow!";
      }
  
      // Constructor 2
      dullExample (int j, string str) {
          i = j;
          s = str;
      }
  };
  
  int main () {
      // Note two things:
        // laaame is a POINTER
        // We're calling the default constructor here
      dullExample* laaame = new dullExample();
      cout &lt;&lt; laaame-&gt;i &lt;&lt; endl;
      cout &lt;&lt; laaame-&gt;s &lt;&lt; endl;
  
      // HERE, we're using constructor 2 in our dynamic allocation
      dullExample* uuugh = new dullExample(3, ":(");
      cout &lt;&lt; uuugh-&gt;i &lt;&lt; endl;
      cout &lt;&lt; uuugh-&gt;s &lt;&lt; endl;
  
      // WARNING: We should deallocate the memory here so as not to have
      // a leak, but we haven't learned how to do that yet...
  }
</pre>
              <br/>
              <p>You should know that, although it's rather silly in most cases to do so, we can even dynamically allocate memory for primitive types:</p>
<pre class='prettyprint'>
  // Stick i on the heap and initialize it to 2
  int* i = new int(2);
  cout &lt;&lt; *i &lt;&lt; endl;
  
  // Of course, would need to deallocate here still... derp
</pre>
              <p>So what is proper syntax for dynamic allocation? Well, let's look at some examples that might clarify that:</p>
              <p class='example'>Using the struct definition from above, will the following code compile? Also, is <code class='prettyprint'>bore</code> on the stack or heap?</p>
<pre class='prettyprint'>
  int main () {
      dullExample bore(5, "&gt;_&gt; &lt;_&lt;");
      cout &lt;&lt; bore.i &lt;&lt; endl;
      cout &lt;&lt; bore.s &lt;&lt; endl;
  
      // Also, do we need to deallocate bore here?
  }
</pre>
              <br/>
              <p class='debug'>Will the following code compile? If so, what will it print out?</p>
<pre class='prettyprint'>
  int main () {
      dullExample dynamic = new dullExample();
      dullExample duo = dynamic;
  
      cout &lt;&lt; dynamic.i &lt;&lt; endl;
      cout &lt;&lt; duo.i &lt;&lt; endl;
      // TODO: Deallocation here
  }
</pre>
              <br/>
              <p class='debug'>Will the following code compile? If so, what will it print out?</p>
<pre class='prettyprint'>
  int main () {
      dullExample* dynamic = new dullExample();
      dullExample* duo = dynamic;
  
      cout &lt;&lt; dynamic-&gt;i &lt;&lt; endl;
      duo-&gt;i = 5;
      cout &lt;&lt; dynamic-&gt;i &lt;&lt; endl;
      // TODO: Deallocation here
  }
</pre>
              <br/>
              <p class='toolkit'>Dynamic Memory can even be used to specify arrays of variable size at runtime!</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct inStructive {
      inStructive() {
          i = 5;
      }
  
      double d;
      int i;
      char c;
  };
  
  int main () {
      int count;
      cout &lt;&lt; "Enter the size:" &lt;&lt; endl;
      cin &gt;&gt; count;
  
      int* i = new int[count];
  
      for (int j = 0; j &lt; count; j++) {
          i[j] = j;
          cout &lt;&lt; i[j] &lt;&lt; endl;
      }
      
      // Will need to see how to prevent a memory leak here...
      // i.e., how to delete arrays of objects... stay tuned!
  }
</pre>
              <p class='question' name='dyn-q3'>
                Say we had a class called A with a member that was a 1,000,000 element array, and we needed to make an array of these objects that is at most 10,000 elements long. 
                Would you prefer to use a local variable or dynamic allocation for this array, and what type should the elements of this array be?
              </p>
              <p class='answer' name='dyn-q3'>
                Because these A objects take up a lot of space, we might consider making our array an array of Pointers to A objects, such that we don't start off with all
                10,000 A objects constructed with their 1,000,000 element array members each, but instead have the capacity to be later allocated so we don't waste space.
              </p>
              <p>Alright, grand... so let's look at the messy part... deallocating memory.</p>
              <br/>
              
              
              <h3>Memory Deallocation Syntax</h3>
              <p>So to recap, whenever we dynamically allocate memory using the <code class='prettyprint'>new</code> keyword, we must later release it using the <code class='prettyprint'>delete</code> keyword.</p>
              <p>If we fail to do so, we get a memory leak:</p>
              <p class='definition'>A <strong>memory leak</strong> is defined as a failure in a program to release discarded memory, causing impaired performance or failure.</p>
              <p>Memory leaks become problems when we repeatedly forget to free dynamically allocated memory, and we have large, discarded objects that are still allocated but can no longer be reached.</p>
              <p>These memory leaks add up until our code may not have enough dynamic memory left to allocate, or doing so slows it substantially.</p>
              <div class='definition'>
                <p>Here are some properties of the <strong>delete</strong> keyword:</p>
                <ul class='indent-1'>
                  <li><p>delete effectively says, &quot;I'm done with this object's dynamically allocated memory; feel free to do with it what you please!&quot;</p></li>
                  <li><p>NOTE: This does NOT say, &quot;Zero out the memory it was pointing to&quot; nor does it say &quot;Set the pointer that was pointing there to NULL or nullptr.&quot;</p></li>
                  <li><p>delete called on an object that was already deleted is undefined behavior!</p></li>
                  <li><p>delete called on a <code class='prettyprint'>nullptr</code> is fine, and does nothing.</p></li>
                  <li><p>delete only NEEDS to be called on objects that were initialized using the <code class='prettyprint'>new</code> operator.</p></li>
                </ul>
              </div>
              <div class='toolkit'>
                <p>There are two separate forms of <code class='prettyprint'>delete</code> used as follows:</p><br/>
<pre class='prettyprint'>
  delete &lt;name_Of_SINGLE_Object&gt;;
  delete[] &lt;name_Of_ARRAY_Of_Objects&gt;;
</pre>
              </div>
              <p>In the first case, <code class='prettyprint'>delete</code> only frees the memory of a single object. Here's an example from earlier:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct dullExample {
      int i;
      string s;
  
      // Default constructor
      dullExample () {
          i = 5;
          s = "wow!";
      }
  
      // Constructor 2
      dullExample (int j, string str) {
          i = j;
          s = str;
      }
  };
  
  int main () {
      dullExample* laaame = new dullExample();
      cout &lt;&lt; laaame-&gt;i &lt;&lt; endl;
      cout &lt;&lt; laaame-&gt;s &lt;&lt; endl;

      dullExample* uuugh = new dullExample(3, ":(");
      cout &lt;&lt; uuugh-&gt;i &lt;&lt; endl;
      cout &lt;&lt; uuugh-&gt;s &lt;&lt; endl;
  
      // Be free memory! Be free!
      delete laaame;
      delete uuugh;
  }
</pre>
              <p class='question' name='dyn-q4'>Where will laaame and uuugh point <strong>after</strong> we call delete on them above?</p>
              <p class='answer' name='dyn-q4'>Exactly where they were beforehand! That is, they'll point to the same memory address as they did before, but that memory will now be deallocated.</p>
              <br/>
              <p>
                The second version of delete, <code class='prettyprint'>delete[]</code>, says, &quot;Release the memory for this array, and call the destructor of every element for it, if it exists.&quot; 
                (We'll talk about destructors momentarily).
              </p>
              <p>NOTE: You only need to use <code class='prettyprint'>delete[]</code> if you have used <code class='prettyprint'>new[]</code> to dynamically allocate an array of objects.</p>
              <p>This is beyond the scope of CS31, so we'll wave our hands over it now... see you in CS32 for more on that discussion.</p>
              <p>Shall we look at some examples?</p>
              <p class='debug'>Find the memory leak!</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct dullExample {
      int i;
      string s;
  
      // Default constructor
      dullExample () {
          i = 5;
          s = "wow!";
      }
  
      // Constructor 2
      dullExample (int j, string str) {
          i = j;
          s = str;
      }
  };
  
  int main () {
      dullExample* onion[5];
      
      for (int i = 0; i &lt; 5; i++) {
          onion[i] = new dullExample(i, "get it? onion leek?");
          // Aren't you glad this is the last day?
      }

      // Done! :DDDDD
      delete onion;
  }
</pre>
              <br/>
              <p class='debug'>Find the memory leak!</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct superDull {
      int lame;
      double doubleLame;
  
      superDull () {
          lame = -100;
      }
  };
  
  struct dullExample {
      int i;
      string s;
      // or is it evenMoreDull?
      superDull* evenDuller;
  
      dullExample () {
          i = 5;
          s = "wow!";
          evenDuller = new superDull();
      }
  };
    
  int main () {
      dullExample* faucet = new dullExample();
      cout &lt;&lt; faucet-&gt;evenDuller-&gt;lame &lt;&lt; endl;
  
      // Done... :|
      delete faucet;
  }
</pre>
              <p class='debug'>Will the following code compile? If so, what will it print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct dullExample {
      int i;
      string s;
  
      dullExample () {
          i = 5;
          s = "wow!";
      }
  };
    
  int main () {
      dullExample dullAgain;
      cout &lt;&lt; dullAgain.i &lt;&lt; endl;
  
      delete dullAgain;
  }
</pre>
              <br/>
              <p class='debug'>Will the following code compile? If so, will it experience any undefined behavior?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct dullExample {
      int i;
      string s;
  
      dullExample () {
          i = 5;
          s = "wow!";
      }
  };
    
  int main () {
      dullExample* dullAgain = new dullExample();
      dullExample* dittoDull = dullAgain;
      
      delete dullAgain;
      delete dittoDull;
      cout &lt;&lt; (dullAgain == dittoDull) &lt;&lt; endl;
  }
</pre>
              <br/>
              <p class='question' name='dyn-q5'>Assuming we removed one of the two delete statements in the above example, what would the program print out?</p>
              <p class='answer' name='dyn-q5'>1 (true) because although we've deallocated the memory that the two pointers point to, they still point to the same spot!</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='structs' class='scrollspy-element' scrollspy-title='More on Structs'></div>
            <h1>More on Structs</h1>
            <div>
              <p>...because I didn't say enough about structs last week... or this week for that matter...</p>
              <p>Mostly, we need to talk about some special member functions. Let's start by adding some details about the constructor.</p>
              <p>We can define multiple constructors for a given type as long as we follow certain rules. Starting with the basics:</p>
              <p class='definition'>The <strong>Default Constructor</strong> is the constructor that expects no arguments.</p>
              <p>There are some special properties about the default constructor:</p>
              <ul class='indent-1'>
                <li><p>If you do not specify one, the compiler will generate one for you... this generated default will initialize NO primitive members, but will call the default constructors of all other object members.</p></li>
                <li><p>You cannot define more than one default constructor</p></li>
                <li><p>If YOU do not define a default constructor, but instead define another constructor (expecting some number of arguments), you can no longer call the default.</p></li>
              </ul>
              <p>Returning to our running example, we see the default constructor:</p>
<pre class='prettyprint'>
  struct dullExample {
      int i;
      string s;
      
      // Default constructor
      dullExample () {
          i = 5;
          s = "wow!";
      }
  };
</pre>
              <p class='debug'>Will the following code compile?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct dullExample {
      int i;
      string s;
  
      dullExample (int j, string s) {
          i = 5;
          s = "wow!";
      }
  };
    
  int main () {
      dullExample* oopsies = new dullExample();
  
      cout &lt;&lt; oopsies-&gt;i &lt;&lt; endl;
      cout &lt;&lt; oopsies-&gt;s &lt;&lt; endl;
  
      delete oopsies;
  }
</pre>
              <p>In fact, this last rule is a special case of a more general one:</p>
              <p class='debug'>WARNING: You cannot have two constructors that expect the same number and type of arguments <strong>in the same order</strong>.</p>
              <p>For example, the following is OK because the parameters, although the same type between constructors, are in a different order.</p>
<pre class='prettyprint'>
  struct dullExample {
      int i;
      string s;
  
      dullExample (int j, string str) {
          i = j;
          s = str;
      }
  
      dullExample (string str, int j) {
          i = j;
          s = str;
      }
  };
</pre>
              <p>But the following is NOT OK:</p>
<pre class='prettyprint'>
  struct dullExample {
      int i;
      string s;
  
      dullExample (int j, string str) {
          i = j;
          s = str;
      }
  
      dullExample (int stuff, string derp) {
          i = stuff;
          s = derp;
      }
  };
</pre>
              <br/>
              <p>OK that's enough constructor trivia for now... let's address the following scenario:</p>
              <p>Say I had a struct with a bunch of dynamically allocated members...</p>
              <p>What would I need to do before I deallocated an instance of that object?</p>
              <p>I would have to individually deallocate each of the dynamically allocated members! Nobody got time for that!</p>
              <p class='toolkit'>
                Enter <strong>destructors</strong>, which are special functions defined on a struct / class that are called whenever (1) that object was locally defined and fell out of scope, 
                or (2) that object was dynamically defined and had a form of <code class='prettyprint'>delete</code> called upon it.
              </p>
              <p>Destructors use the following syntax:</p>
<pre class='prettyprint'>
  struct someStruct {
    ...
    // Constructor
    someStruct (...) {
      ...
    }
    
    // Destructor
    ~someStruct () {
      ...
    }
  };
</pre>
              <p>Notice that the destructor syntax has the following properties:</p>
              <ul class='indent-1'>
                <li><p>Shares the same name of the struct / class</p></li>
                <li><p>Starts with a tilde (~)</p></li>
                <li><p>Has no return type</p></li>
                <li><p>Expects no arguments</p></li>
              </ul>
              <p>So let's look at some correct destructor definitions and uses:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct superInterestingObject {
      string actuallyNotThatInteresting;
  
      superInterestingObject () {
          actuallyNotThatInteresting = "Meh...";
      }
  };
  
  struct superInterestingExample {
      int i;
      string s;
      superInterestingObject* ob;
  
      superInterestingExample () {
          i = 5;
          s = "wow that's interesting!";
          ob = new superInterestingObject();
      }
  
      // DESTRUCTOOOOOOR
      ~superInterestingExample () {
          delete ob;
      }
  };
  
  int main () {
      // NOTICE: sup is not a pointer, just an object declaration
      superInterestingExample sup;
    
      cout &lt;&lt; sup.ob-&gt;actuallyNotThatInteresting &lt;&lt; endl;
  }
</pre>
            <br/>
            <p>Now, what if we had a dynamic allocation?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct superInterestingObject {
      string actuallyNotThatInteresting;
  
      superInterestingObject () {
          actuallyNotThatInteresting = "Meh...";
      }
  };
  
  struct superInterestingExample {
      int i;
      string s;
      superInterestingObject* ob;
  
      superInterestingExample () {
          i = 5;
          s = "wow that's interesting!";
          ob = new superInterestingObject();
      }
  
      // DESTRUCTOOOOOOR
      ~superInterestingExample () {
          delete ob;
      }
  
  };
  
  int main () {
      // NOTICE: sup is now a dynamically allocated var
      superInterestingExample* sup = new superInterestingExample();
    
      cout &lt;&lt; sup-&gt;ob-&gt;actuallyNotThatInteresting &lt;&lt; endl;
    
      // Destructor will get called here so I
      // don't have to worry about releasing ob
      delete sup;
  }
</pre>
              <p>How nice that is!</p>
              <p>Alright, let's look at some crumby examples when some fools tried to use destructors:</p>
              <p class='debug'>Will the following code compile? If so, will it suffer any undefined behavior? Will it print something?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct superInterestingObject {
      string actuallyNotThatInteresting;
  
      superInterestingObject () {
          actuallyNotThatInteresting = "Meh...";
      }
  };
  
  struct superInterestingExample {
      int i;
      string s;
      superInterestingObject* ob;
  
      // NOTICE: change in the constructor...
      superInterestingExample () {
          i = 5;
          s = "wow that's interesting!";
      }
  
      ~superInterestingExample () {
          delete ob;
      }
  
  };
  
  int main () {
    superInterestingExample* sup = new superInterestingExample();
  
    cout &lt;&lt; sup-&gt;ob-&gt;actuallyNotThatInteresting &lt;&lt; endl;
  
    delete sup;
  }
</pre>
              <br/>
              <p class='question' name='con-q0'>So how can we avoid this issue of not initializing a member object (maybe we don't want to until we need it) and having our destructor try to clean it up?</p>
              <p class='answer' name='con-q0'>Initialize it to the nullptr in the constructor!</p>
              
            </div>
            <hr/>
            
            
            <!-- TODO: Example with dynamically allocated object in a function, then returned, with pointer still on it -->
            <br/>
            <div id='practice' class='scrollspy-element' scrollspy-title='Practice'></div>
            <h1>Practice</h1>
            <div>
              <p>Let's go through some examples that might just be tricky enough to make the final...</p>
              <p class='debug'>There's a rather insidious bug in this piece of code that will cause it to crash... where is it and why?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
    
  struct dullExample {
      int i;
      string s;
      // or is it evenMoreDull?
      dullExample* evenDuller;
  
      dullExample () {
          i = 5;
          s = "wow!";
          evenDuller = new dullExample();
      }
  };
    
  int main () {
      dullExample* faucet = new dullExample();
      cout &lt;&lt; faucet-&gt;evenDuller-&gt;i &lt;&lt; endl;
  
      // Done... :|
      delete faucet;
  }
</pre>
              <br/>
              <p class='debug'>Will the following code compile? If so, what will it print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct superEx {
      int i;
      double d;
  
      superEx (double iSetter, double dSetter) {
          cout &lt;&lt; "I'm in 1!" &lt;&lt; endl;
          i = iSetter;
          d = dSetter;
      }
  
      superEx (int iSetter, int dSetter) {
          cout &lt;&lt; "I'm in 2!" &lt;&lt; endl;
          i = iSetter;
          d = dSetter;
      }
  };
  
  int main () {
      superEx* sup = new superEx(5, 3);
      cout &lt;&lt; sup-&gt;i &lt;&lt; endl;
      cout &lt;&lt; sup-&gt;d &lt;&lt; endl;
  
      superEx* nice = new superEx(5.5, 3.3);
      cout &lt;&lt; nice-&gt;i &lt;&lt; endl;
      cout &lt;&lt; nice-&gt;d &lt;&lt; endl;
  
      // or is it? 0_o
      superEx* naughty = new superEx(5, 3.3);
      cout &lt;&lt; naughty-&gt;i &lt;&lt; endl;
      cout &lt;&lt; naughty-&gt;d &lt;&lt; endl;
  
      delete sup;
      delete nice;
      delete naughty;
  }
</pre>
              <br/>
              <p class='debug'>Find the memory leak!</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct superInterestingObject {
      string actuallyNotThatInteresting;
  
      superInterestingObject () {
          actuallyNotThatInteresting = "Meh...";
      }
  };
  
  struct superInterestingExample {
      int i;
      string s;
      superInterestingObject* ob;
  
      // NOTICE: change in the constructor...
      superInterestingExample () {
          i = 5;
          s = "wow that's interesting!";
          ob = new superInterestingObject();
      }
  
      ~superInterestingExample () {
          delete ob;
      }
  
  };
  
  int main () {
      superInterestingExample* sup = new superInterestingExample();
    
      cout &lt;&lt; sup-&gt;ob-&gt;actuallyNotThatInteresting &lt;&lt; endl;
  }
</pre>
              <br/>
              <p class='debug'>Find the memory leak!</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct superOb {
      int i[3];
  
      superOb () {
          for (int j = 0; j &lt; 3; j++) {
              i[j] = j;
          }
      }
  };
  
  struct superEx {
      int i;
      string s;
      superOb* ob;
  
      superEx () {
          i = 5;
          s = "wow that's interesting!";
          ob = new superOb();
      }
  
      ~superEx () {
          delete ob;
      }
  };
  
  superEx* generateCoolness () {
      superEx* coolness = new superEx();
      return coolness;
  }
  
  int main () {
    superEx* sup = generateCoolness();
  
    for (int j = 0; j &lt; 3; j++) {
        cout &lt;&lt; sup-&gt;ob-&gt;i[j] &lt;&lt; endl;
    }
  }
</pre>
              <br/>
              <p class='debug'>Will the following code compile? Will there be any undefined behavior? Will it print anything out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct superOb {
      string s;
  
      superOb () {
          string s = "watch out!";
      }
  };
  
  struct superEx {
      int i;
      string s;
      superOb* ob;
  
      superEx () {
          i = 5;
          s = "wow that's interesting!";
          ob = new superOb();
      }
  
      ~superEx () {
          delete ob;
      }
  };
  
  int main () {
      superEx* sup = new superEx();
  
      cout &lt;&lt; sup-&gt;ob-&gt;s &lt;&lt; endl;
  
      delete sup-&gt;ob;
      delete sup;
  }
</pre>
              <br/>
              <p>OK... are you ready? I don't know if you're ready... OK you're ready!</p>
              <p class='example'>What does the following code print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  const int MAX_SIZE = 3;
  
  struct superEx;
  
  struct superOb {
      int i[MAX_SIZE];
      double d[MAX_SIZE];
      superEx* ex;
  
      superOb () {
          for (int j = 0; j &lt; MAX_SIZE; j++) {
              i[j] = j;
              d[j] = i[j] - 0.1 * j;
          }
      }
  };
  
  struct superEx {
      int i[MAX_SIZE];
      double d[MAX_SIZE];
      superOb* ob;
  
      superEx () {
          for (int j = 0; j &lt; MAX_SIZE; j++) {
              i[j] = j;
              d[j] = i[j] + 0.1 * j;
          }
      }
  };
  
  double trickyFunc (superEx* ex, superOb* ob, int index) {
      ob-&gt;d[ex-&gt;i[index]] = ob-&gt;d[ex-&gt;i[index]] + 1;
      return ob-&gt;d[ex-&gt;i[index]];
  }
  
  int main () {
      superEx* ex = new superEx();
      superOb* ob = new superOb();
  
      cout &lt;&lt; trickyFunc(ex, ob, 0) &lt;&lt; endl;
      cout &lt;&lt; trickyFunc(ex, ob, 1) &lt;&lt; endl;
  }
</pre>
            </div>
            <hr/>
            
          </div>
          <!-- END PRESENTATION CONTENT -->
          
          
        </div>
      </div>
      <!-- END MAIN CONTENT -->
      
      
    </div>
    <!-- END WRAPPER -->
    
    <!-- BEGIN FOOTER -->
    <div id="footer">
      <div class="container">
        <div class="col-md-12 text-center">
          
        </div>
      </div>
    </div>
    <!-- END FOOTER -->
    
  </body>
</html>
