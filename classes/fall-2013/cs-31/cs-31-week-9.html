
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <title>Andrew Forney - UCLA CS</title>
    <link href="../../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../../../css/magic-bootstrap.css" rel="stylesheet" type="text/css">
    <link href="../../../css/main.css" rel="stylesheet" type="text/css">
    <script src="../../../js/lib/jquery-2.0.3.min.js"></script>
    <script src="../../../js/lib/bootstrap.min.js"></script>
    <script src="../../../js/display/general/general-display.js"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
  </head>
  
  <body data-spy="scroll" data-target="#scrollspy">
    
    <!-- BEGIN WRAP -->
    <div id="wrap">
      
      <!-- BEGIN NAVIGATION -->
      <nav class='navbar navbar-default' role='navigation'>
        <div class='nav-accent'></div>
        <div class='container'>
          <div class='row'>
            <div class='col-md-12'>
              <div class='navbar-header'>
                <button class='navbar-toggle' type='button' data-toggle='collapse' data-target='.navbar-main-collapse'>
                  <span class='sr-only'>Toggle Navigation</span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                </button>
                <a class='navbar-brand' href='/~forns/'>
                  <span id='brand-text'>
                    Andrew Forney
                  </span>
                </a>
              </div>
              
              <div id='nav-main' class='collapse navbar-collapse navbar-main-collapse'>
                <ul class='nav navbar-nav navbar-right'>
                  
                  <li>
                    <a href='/~forns/about.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-user'></span>
                      </div>
                      <p class='text-center'>About</p>
                    </a>
                  </li>
                  
                  <li class='active'>
                    <a href='/~forns/classes.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-book'></span>
                      </div>
                      <p class='text-center'>Classes</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/contact.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-comment'></span>
                      </div>
                      <p class='text-center'>Contact</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/publications.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-file'></span>
                      </div>
                      <p class='text-center'>Publications</p>
                    </a>
                  </li>
                  
                </ul>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <!-- END NAVIGATION -->
      
      <!-- BEGIN MAIN CONTENT -->
      <div id="main-content" class="container">
        <div class="row">
          
          <!-- BEGIN SCROLLSPY -->
          <div class='col-md-2'>
            <div class="bs-sidebar hidden-print affix" role="complementary">
              <ul id='scrollspy' class="nav bs-sidenav">
              </ul>
            </div>
          </div>
          <!-- END SCROLLSPY -->
          
          <!-- BEGIN PRESENTATION CONTENT -->
          <div class='col-md-10 presentation-content' role='main'>
            <ol class="breadcrumb">
              <li><a href="../../../classes.html">Classes</a></li>
              <li><a href="./cs-31.html">Fall13 CS31</a></li>
              <li class="active">Week 9</li>
            </ol>
            
            <div id='review' class='scrollspy-element' scrollspy-title='Review'></div>
            <h1>Questions from Week 8</h1>
            <div>
              <p><strong>Q:</strong> How do I print out the address of cstring? It always tries to print out the cstring instead!</p>
              <p>A: We can use our buddy the static cast and use the general &quot;cast to pointer&quot; notation via (void *) as follows:</p>
<pre class='prettyprint'>
  char c[] = "test";
  cout &lt;&lt; static_cast&lt;void *&gt;(&c) &lt;&lt; endl;
  cout &lt;&lt; static_cast&lt;void *&gt;(&c[1]) &lt;&lt; endl;
  cout &lt;&lt; static_cast&lt;void *&gt;(&c[2]) &lt;&lt; endl;
</pre>
              <p>This will tell cout that we want to print the address of the pointer c with various offsets, rather than treat it as a cstring to be printed character by character.</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='structs' class='scrollspy-element' scrollspy-title='Intro to Structs'></div>
            <h1>Introduction to Structs</h1>
            <div>
              <p class='toolkit'><strong>Structs</strong> are objects in C++ that represent &quot;data <strong>struct</strong>ures&quot;, or variables, functions, etc. that are organized under a categorizing identifier.</p>
              <p>Andrew, no one is impressed when you use lots of words.</p>
              <p>Fine... in other words, structs are ways of grouping variables and functions into single, cohesive objects.</p>
              <p>For example, instead of shipping you your TV piece by piece, the manufacturers send it as a completed, cohesive television.</p>
              <p>"Hey, nice screen, antenna, RF input, tuner, and speakers! Is it a Sony?"</p>
              <p>Don't be foolish, it's a television. We name it by its whole unit and worry less about its individual parts... yet, we still have names for those individual parts:</p>
              <p class='toolkit'><strong>Struct Members,</strong> are components of a given struct; they can be of any variable type.</p>
              <p>So, essentially, when we declare a struct, we are declaring a new type! All of the rules we're familiar with (when dealing with types) now similarly apply.</p>
              <p>For starters, we should look at how to declare a struct...</p>
              
              <div class='definition'><p>We declare structs using the following syntax:</p>
<pre class='prettyprint'>
  struct &lt;structName&gt; {
      &lt;member1_type&gt; &lt;member1_name&gt;;
      &lt;member2_type&gt; &lt;member2_name&gt;;
      // ...etc.
  }; // Remember the semicolon!
</pre>
              </div>
                <p>So how about an example? Let's declare a struct, as such:</p>
<pre class='prettyprint'>
  struct such {
      char soCstring[5];
      int muchNumber;
  };
</pre>
                <p>Here, I've defined a struct named such that has two members: (1) a 5 element cstring named soCstring, and (2) an int named muchNumber.</p>
                <p class='debug'>Warning! You cannot initialize members within the struct definition using the traditional notation! The following will NOT compile:</p>
<pre class='prettyprint'>
  struct such {
      char soCstring[5] = "test";
      int muchNumber = 5;
  };
</pre>
                <p>We'll talk about &quot;initializing&quot; structs later.</p>
                <p class='toolkit'>A struct <strong>instance</strong> is a particular variable that is of a particular type of struct.</p>
                <p>If we modeled the car company Ford as a struct, then an instance of Ford might be: <code class='prettyprint'>Ford myMustang;</code>.</p>
                <p>That said, if I wanted to declare an instance of a struct, I need the following notation:</p>
<pre class='prettyprint'>
  struct such {
      char soCstring[5] = "test";
      int muchNumber = 5;
  };
  
  // ...
  
  // [Primitive] "i" is of type "int"
  int i;
  
  // [Struct] "doge" is of type "such"
  such doge;
</pre>
                <p>Here, <code class='prettyprint'>doge</code> is an instance of struct <code class='prettyprint'>such</code>.</p>
                <p>Alright, so I've declared a struct... now what?</p>
                <p>The world is your oyster! Go forth and struct!</p>
                <p>But first... let's talk about how to talk about members of structs...</p>
                <p class='toolkit'>The <strong>Element / Member Selection Operator (.)</strong> says, &quot;Give me member &lt;rvalue&gt; of my &lt;lvalue&gt;...&quot; That is, we select the member on the right of the period from the struct instance on the left.</p>
                <p>Here's an example:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct such {
      char soCstring[5];
      int muchNumber;
  };
  
  int main () {
      such doge;
      strcpy(doge.soCstring, "wow");
      doge.muchNumber = 5;
  
      cout &lt;&lt; doge.soCstring &lt;&lt; endl;
      cout &lt;&lt; doge.muchNumber &lt;&lt; endl;
  }
</pre>
                <br/>
                <p class='debug'>Will the following code compile or have any unpredictable behavior? If &quot;No&quot; to both questions, what will it output?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct such {
      char soCstring[5];
      int muchNumber;
  };
  
  int main () {
      such doge;
      
      cout &lt;&lt; doge.soCstring &lt;&lt; endl;
      cout &lt;&lt; doge.muchNumber &lt;&lt; endl;
  }
</pre>
                <br/>
                <p class='debug'>Will the following code compile or have any unpredictable behavior? If &quot;No&quot; to both questions, what will it output?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct such {
      char soCstring[5];
      int muchNumber;
  };
  
  int main () {
      cout &lt;&lt; such.soCstring &lt;&lt; endl;
      cout &lt;&lt; such.muchNumber &lt;&lt; endl;
  }
</pre>
                <br/>
                <p class='definition'>Structs are defined within scope the same way variables are:</p>
                <p>This gives us a couple of implications... for instance, I can have two structs of the same name but in different scopes:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct such {
      char soCstring[5];
      int muchNumber;
  };
  
  int main () {
      struct such {
          double suchRepetition;
      };
  
      // See which representation of such we use?
      such doge;
      doge.suchRepetition = 2.2;
  
      // Remember :: selects from the global namespace!
      ::such doge2;
      doge2.muchNumber = 3;
  
      cout &lt;&lt; doge.suchRepetition &lt;&lt; endl;
      cout &lt;&lt; doge2.muchNumber &lt;&lt; endl;
  }
</pre>
              <p>Because we can treat struct definitions as entities of a particular scope, there is a shorthand to both define and declare variables of a struct type:</p>
<pre class='prettyprint'>
  struct such {
      char soCstring[5] = "test";
      int muchNumber = 5;
  };
  
  such doge;
  such doge2;
  such doge3;
  
  // ...
  // Is equivalent to saying
  // ...
  
  struct such {
      char soCstring[5] = "test";
      int muchNumber = 5;
  } doge, doge2, doge3;
</pre>
              <br/>
              <p class='debug'>Which of the following marked lines would I need to remove in order for the code to compile and run correctly?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct wow {
      int woah;
      char manyWords[11];
      char* greatWords;
  } otherDoge;
  
  int main () {
      struct such {
          double suchRepetition;
          char manyWords[10];
      } doge;
  
      // Which lines below break the code?
      // Which lead to undefined behavior?
      otherDoge.wow.woah = 3;
      strcpy(such.wow.manyWords, "suchPoetry");
      strcpy(doge.wow.manyWords, "suchPoetry");
      strcpy(otherDoge.manyWords, "suchPoetry");
      
      such.suchRepetition = 2.222222;
      otherDoge.greatWords = doge.manyWords;
      strcpy(otherDoge.greatWords, otherDoge.manyWords);
      cout &lt;&lt; doge.manyWords &lt;&lt; endl;
  }
</pre>
            </div>
            <hr/>
            
              
            <br/>
            <div id='constructors' class='scrollspy-element' scrollspy-title='Constructors'></div>
            <h1>Constructors and Initializing Structs</h1>
            <div>
              <p>Now, the next question you might be asking is: how do I initialize a struct?</p>
              <p>To give values to our struct members, we can use constructors:</p>
              <p class='toolkit'>A <strong>constructor</strong> is used to assign values to a newly created struct instance's members; it's how we &quot;initialize&quot; them. Constructors are called automatically at struct instance declaration.</p>
              <p>We define constructor behaviors by listing a function definition with the same name as the struct as a member function and NO return type.</p>
              <p class='definition'>A member function is a function defined on the struct that instances of the struct have access to.</p>
              <p>Take the following example for... example:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;cstring&gt;
  #include &lt;string&gt;
  using namespace std;
  
  struct Ford {
      int tires;
      string model;
      bool fourWheelDrive;
      
      // Constructor for Ford objects
      Ford () {
          // +One spare
          tires = 5;
          model = "Ranger";
          fourWheelDrive = false;
      }
  };
  
  int main () {
      Ford myCar;
  
      cout &lt;&lt; myCar.tires &lt;&lt; endl;
      cout &lt;&lt; myCar.model &lt;&lt; endl;
      cout &lt;&lt; myCar.fourWheelDrive &lt;&lt; endl;
  }
</pre>
              <p>See how when I declared a new instance of Ford called myCar in the main function, it attains the member values defined in the constructor.</p>
              <br/>
              <h3>Member Functions</h3>
              <p class='definition'>Member functions, sometimes called <strong>methods</strong>, are functions that are called by instances of a particular struct.</p>
              <p>Here's an example where I define a member function called <code class='prettyprint'>getFlat()</code> that returns the number of remaining tires on my Ford after decrementing how many it has.</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;cstring&gt;
  #include &lt;string&gt;
  using namespace std;
  
  struct Ford {
      int tires;
      string model;
      bool fourWheelDrive;
  
      int getFlat () {
          tires--;
          if (tires &lt; 0) {
              tires = 0;
          }
          return tires;
      }
  
      // Constructor
      Ford () {
          // +One spare
          tires = 5;
          model = "Ranger";
          fourWheelDrive = false;
      }
  };
  
  int main () {
      Ford myCar;
      Ford yourCar;
  
      myCar.getFlat();
      myCar.getFlat();
      yourCar.getFlat();
  
      cout &lt;&lt; myCar.tires &lt;&lt; endl;
      cout &lt;&lt; yourCar.tires &lt;&lt; endl;
  }
</pre>
              <p>Some things to notice:</p>
              <ul class='indent-1'>
                <li><p>The number of tires each instance of Ford has is specific to each object in main</p></li>
                <li><p>When I reference a member variable in a member function defined in a struct, it refers to the variable owned by the calling instance</p></li>
              </ul>
              <br/>
              <p>But what if I wanted to define a member function outside of the struct definition? I could use the following syntax:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;cstring&gt;
  #include &lt;string&gt;
  using namespace std;
  
  struct Ford {
      int tires;
      string model;
      bool fourWheelDrive;
  
      // Need function prototype
      int getFlat();
  
      // Constructor
      Ford () {
          // +One spare
          tires = 5;
          model = "Ranger";
          fourWheelDrive = false;
      }
  };
  
  // Member function definition
  int Ford::getFlat () {
      // this is a keyword for a pointer to the
      // calling Ford instance
      this-&gt;tires--;
      if (this-&gt;tires &lt; 0) {
          this-&gt;tires = 0;
      }
      return this-&gt;tires;
  }
  
  int main () {
      Ford myCar;
      Ford yourCar;
  
      myCar.getFlat();
      myCar.getFlat();
      yourCar.getFlat();
  
      cout &lt;&lt; myCar.tires &lt;&lt; endl;
      cout &lt;&lt; yourCar.tires &lt;&lt; endl;
  }
</pre>
              <p class='toolkit'>The <strong>this</strong> keyword is a special keyword usable within member functions that provides a pointer to the calling instance.</p>
              <p class='toolkit'>The <strong>-&gt;</strong> operator is just like the member selector (.) operator except that the lvalue of (-&gt;) is a pointer to an object rather than the object itself.</p>
              <p>A few things to note about this syntax:</p>
              <ul class='indent-1'>
                <li><p>Note how in the struct, I need to provide a function prototype for the member function that I've promised I'll later define.</p></li>
                <li><p>When I define the member function getFlat outside of the struct, I specify the function name within the struct scope by saying Ford::getFlat</p></li>
                <li><p>
                  Now that I've defined the member function outside of struct, I need a way to refer to the instance's members; towards this end, I can use the keyword <code class='prettyprint'>this</code> 
                  as a pointer to the calling instance of the struct.
                </p></li>
                <li><p>Since I'm talking about a pointer to the instance, in order to reference its members, I use the arrow operator (-&gt;) to get at the members when a pointer is the lvalue.</p></li>
              </ul>
              <br/>
              
              <h3/>Public &amp; Private Tags</h3>
              <p>What if we didn't want users of our structs to tamper with its internal data members? We could ask them nicely and be disappointed, or we could force them to obey our will!</p>
              <p class='toolkit'>The <strong>public</strong> tag, used in a struct, says &quot;Everything that comes after this (until you say otherwise) is publically accessible and modifiable.&quot;</p>
              <p class='toolkit'>The <strong>private</strong> tag, used in a struct, says &quot;Everything that comes after this (until you say otherwise) is ONLY accessible to member functions.&quot;</p>
              <p class='debug'>Will the following code compile? If so, what will it output?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;cstring&gt;
  #include &lt;string&gt;
  using namespace std;
  
  struct Ford {
      // Available to anyone!
      public:
          // Need function prototype
          int getFlat();
          // Constructor
          Ford () {
              // +One spare
              tires = 5;
              model = "Ranger";
              fourWheelDrive = false;
          }
  
      // Can't touch these!
      private:
          int tires;
          string model;
          bool fourWheelDrive;
  };
  
  // Member function definition
  int Ford::getFlat () {
      // this is a keyword for a pointer to the
      // calling Ford instance
      this-&gt;tires--;
      if (this-&gt;tires &lt; 0) {
        this-&gt;tires = 0;
      }
      return this-&gt;tires;
  }
  
  int main () {
      Ford myCar;
      Ford yourCar;
  
      myCar.getFlat();
      myCar.getFlat();
      yourCar.getFlat();
  
      // ...errrr, are tires private?
      cout &lt;&lt; myCar.tires &lt;&lt; endl;
      cout &lt;&lt; yourCar.tires &lt;&lt; endl;
  }
</pre>
            </div>
            <br/>
            <p>So how do I give users access to my private members? ...there's gotta be a better way to say that...</p>
            <p class='definition'>Member functions called <strong>getters</strong> are used to allow users access to viewing private member values.</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;cstring&gt;
  #include &lt;string&gt;
  using namespace std;
  
  struct Ford {
      // Available to anyone!
      public:
          // Need function prototypes
          int getFlat();
          int getTires();
  
          // Constructor
          Ford () {
              // +One spare
              tires = 5;
              model = "Ranger";
              fourWheelDrive = false;
          }
  
      // Can't touch these!
      private:
          int tires;
          string model;
          bool fourWheelDrive;
  };
  
  // Member function definition
  int Ford::getFlat () {
      // this is a keyword for a pointer to the
      // calling Ford instance
      this-&gt;tires--;
      if (this-&gt;tires &lt; 0) {
        this-&gt;tires = 0;
      }
      return this-&gt;tires;
  }
  
  int Ford::getTires () {
    return this-&gt;tires;
  }
  
  int main () {
      Ford myCar;
      Ford yourCar;
  
      myCar.getFlat();
      myCar.getFlat();
      yourCar.getFlat();
  
      // ...now I've provided an interface to see the number
      // of tires!
      cout &lt;&lt; myCar.getTires() &lt;&lt; endl;
      cout &lt;&lt; yourCar.getTires() &lt;&lt; endl;
  }
</pre>
            <hr/>
            
            
            <br/>
            <div id='structsMemory' class='scrollspy-element' scrollspy-title='Structs in Memory'></div>
            <h1>Structs in Memory</h1>
            <div>
              <p>Remember when we said that memory addresses are contiguous in the hardware? This is still true! But we didn't say the whole truth...</p>
              <p>(you couldn't handle the whole truth then, but now you can)</p>
              <p>Memory addresses are segmented into physical storage locations known as machine words, which we talked about at the beginning of class but as reminder:</p>
              <p class='definition'>A <strong>machine word</strong> in memory is the architecture-specific &quot;native&quot; data size that the CPU is capable of processing.</p>
              <p>So, for example, on a 32-bit processor, a machine word is 4 bytes long, because the processor can handle 32 bits at a time, which we know is = 4 bytes * 8 bits / 1 byte.</p>
              <p>Physical memory is therefore separated into whatever word size the current architecture and operating system can support.</p>
              <p>Think of a 32-bit machine with 4 byte machine words as having 4 byte &quot;chunks&quot; of memory indicies.</p>
              <p>If we had a 64-bit machine with 8 byte machine words, then we might envision the memory laid out as follows:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/fall-2013/cs-31/week-9/structs0.PNG' />
              </div>
              <p>A couple things to note here:</p>
              <ul class='indent-1'>
                <li><p>We still have sequential indecies of memory addresses; that hasn't changed</p></li>
                <li><p>We still have the same *amount* of memory</p></li>
                <li><p>BUT, the way different C++ types get stored in memory gets a tiny bit tricky</p></li>
              </ul>
              <p class='definition'>A <strong>word boundary</strong> is therefore the end address of a word in memory.</p>
              <p>So if a word started in memory at address 1000, then on a 32 bit machine, that word's boundary would be at the end of address 1003.</p>
              <p>Why is this important, Andrew? I've already eaten 5 pumpkin pies and the only reason I'm reading this is because I'm too tired to switch tabs.</p>
              <p>Glad you asked... my apologies in advance for being a bit handwavy here (the specifics are a bit out of this class' scope), but getting the general idea will help you to understand structs in memory.</p>
              <p class='definition'>A struct's individual members are guaranteed to be sequential in memory, but not necessarily contiguous. That said, we are also guaranteed that other variables (outside of the struct members) will not be stored in between the members.</p>
              <p>
                By sequential, I mean that if member <code class='prettyprint'>int i;</code> is declared before <code class='prettyprint'>char c;</code> in a given struct, then we are guaranteed that
                <code class='prettyprint'>&amp;i &lt; &amp;c</code> 
              </p>
              <p>
                That said, if <code class='prettyprint'>i</code> starts at memory address 1000 and extends to address 1003 on a 64-bit machine, then we are NOT guaranteed that <code class='prettyprint'>c</code>
                is located at address 1004.
              </p>
              <p>In brief, your compiler is free to add padding in memory between members to align things properly.</p>
              <p class='example'>
                Take, for example, the following two structs with the same numbers declared in two different orders. The main method will print different values out for you depending on where the
                members are put in memory at runtime, but you can still glean the padding that the compiler has added.
              </p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct inStructive {
      int i;
      double d;
      char c;
  };
  
  int main () {
      inStructive s;
  
      cout &lt;&lt; static_cast&lt;void *&gt;(&amp;s.i) &lt;&lt; endl;
      cout &lt;&lt; static_cast&lt;void *&gt;(&amp;s.d) &lt;&lt; endl;
      cout &lt;&lt; static_cast&lt;void *&gt;(&amp;s.c) &lt;&lt; endl;
  }
</pre>
              <p>Your compiler might have done the following allocation of this struct in memory:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/fall-2013/cs-31/week-9/structs1.PNG' />
              </div>
              <p>Andrew, that's pretty lame how you couldn't fit &quot;char c;&quot; into that box, it looks really asymmetrical.</p>
              <p>I will find you and ruin your Thanksgiving meal!</p>
              <p>Now, if I rearrange the member declarations as such:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  struct inStructive {
      double d;
      int i;
      char c;
  };
  
  int main () {
      inStructive s;
  
      cout &lt;&lt; static_cast&lt;void *&gt;(&amp;s.d) &lt;&lt; endl;
      cout &lt;&lt; static_cast&lt;void *&gt;(&amp;s.i) &lt;&lt; endl;
      cout &lt;&lt; static_cast&lt;void *&gt;(&amp;s.c) &lt;&lt; endl;
  }
</pre>
              <p>Then I *might* get some sort of spacing like the following:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/fall-2013/cs-31/week-9/structs2.PNG' />
              </div>
              <p>See how that works? Here are the take-away messages:</p>
              <ul class='indent-1'>
                <li><p>Struct members are guaranteed to be sequential (relatively positioned to each other) in memory</p></li>
                <li><p>Struct members are not guaranteed to be contiguous (absolutely positioned one after another) in memory</p></li>
                <li><p>Because of the above, the size of our struct types will depend on what members it has, what types those members are, and in what order they're declared.</p></li>
              </ul>
              <p>Just how these are arranged will be a topic for a future class, worry not!</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='structPointers' class='scrollspy-element' scrollspy-title='Struct Pointers'></div>
            <h1>Struct Pointers</h1>
            <div>
              <p>Struct pointers work pretty much exactly as you'd expect.</p>
              <p class='definition'>Pointers to struct instances must have the same type as the object to which they're pointing</p>
              <p>Remember our arrow operator to access the members of whatever struct a struct pointer points to:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;cstring&gt;
  #include &lt;string&gt;
  using namespace std;
  
  struct Stuff {
      int x;
      string s;
  
      Stuff () {
        x = 5;
        s = "hi :)";
      }
  };
  
  int main () {
      Stuff ing;
  
      // Pointer of type Stuff equal to the
      // location of the first member of ing
      Stuff* ptr = &ing;
  
      cout &lt;&lt; ptr-&gt;x &lt;&lt; endl;
      cout &lt;&lt; ptr-&gt;s &lt;&lt; endl;
  }
</pre>
              <p>Notice the addresses that the pointer points to and the address of the first declared member, x:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;cstring&gt;
  #include &lt;string&gt;
  using namespace std;
  
  struct Stuff {
      int x;
      string s;
  
      Stuff () {
        x = 5;
        s = "hi :)";
      }
  };
  
  int main () {
      Stuff ing;
  
      // Pointer of type Stuff equal to the
      // location of the first member of ing
      Stuff* ptr = &ing;
  
      cout &lt;&lt; ptr &lt;&lt; endl;
      cout &lt;&lt; &ptr-&gt;x &lt;&lt; endl;
  }
</pre>
              <p>What if we had an array as a member of a struct?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;cstring&gt;
  #include &lt;string&gt;
  using namespace std;
  
  struct Stuff {
      int x;
      string s;
      int i[3];
  
      Stuff () {
          x = 5;
          s = "hi :)";
          i[0] = 5;
          i[1] = 6;
          i[2] = 7;
      }
  };
  
  int main () {
      Stuff ing;
  
      // Pointer of type Stuff equal to the
      // location of the first member of ing
      Stuff* ptr = &ing;
  
      for (int j = 0; j &lt; 3; j++) {
          cout &lt;&lt; ptr-&gt;i[j] &lt;&lt; endl;
      }
  }
</pre>
            </div>
            <hr/>
            
            
            <br/>
            <div id='structArrays' class='scrollspy-element' scrollspy-title='Struct Arrays'></div>
            <h1>Arrays of Structs</h1>
            <div>
              <p>Now that we know how structs are arranged in memory, we can talk about sticking them into arrays!</p>
              <p class='toolkit'>To declare an array of structs, we use the notation we're all used to with other types:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;cstring&gt;
  #include &lt;string&gt;
  using namespace std;
  
  struct Stuff {
      int x;
      char c[6];
  
      Stuff () {
          x = 3;
          strcpy(c, "mine?");
      }
  };
  
  int main () {
      // An array of 5 Stuffs!
      Stuff ing[5];
  
      // Ways to access members and elements of
      // members, like arrays
      cout &lt;&lt; ing[0].c &lt;&lt; endl;
      cout &lt;&lt; ing[2].c &lt;&lt; endl;
      cout &lt;&lt; ing[2].c[4] &lt;&lt; endl;
  }
</pre>
            </div>
            <hr/>
            
            
            <br/>
            <div id='structFuncs' class='scrollspy-element' scrollspy-title='Functions &amp; Structs'></div>
            <h1>Functions &amp; Structs</h1>
            <div>
            </div>
            <hr/>
            
          </div>
          <!-- END PRESENTATION CONTENT -->
          
          
            <!-- TODO: Pointers to structs -->
              <!-- TODO: How is this represented in main memory? -->
                <!-- TODO: Sum of member size totals??? -->
                <!-- TODO: Are these located contiguously in memory? -->
                
            <!-- TODO: Arrays of struct types -->
              <!-- TODO: dynamic memory and why we use it for arrays of structs -->
                <!-- TODO: don't want to instantiate, say, 100 objects, so we'll only use the memory for however many variables we need -->
                <!-- TODO: thus, we'll have an array of pointers of type whatever, and we'll instantiate them as we need them -->
                <!-- TODO: Enter: the new operator, which allocates memory somewhere for a struct, and returns a pointer to the location it put it -->
                <!-- TODO: Whenever we want to reference an object at an index of an array of that object, we use, say, array[i]->move(); -->
                
            <!-- TODO: Functions with structs -->
              <!-- TODO: Passed by value!!! Not a pointer -->
                <!-- TODO: Copying can be expensive on large structs -->
                  <!-- TODO: Rule of thumb: pass by value structs that are small; typically primitive types -->
              <!-- TODO: Passing by reference -->
                <!-- TODO: Also with const keyword to forbid change to struct's fields -->
                <!-- TODO: For a member function to promise not to modify the object, we use the keyword placement: -->
                  <!-- TODO: int position () const; // in the struct -->
                  <!-- TODO: int position () const {} // at the implementation -->
                  <!-- TODO: if a const is missing from a member function, and you try to call it on a const struct variable, you'll get an error! -->
              <!-- TODO: Passing pointers to structs to funcs -->
                <!-- TODO: can't do dot member access on pointers to structs; e.g., e.age++; where e is a pointer to an employee won't work -->
                <!-- TODO: Instead, we use e->age++; to refer to a pointer's dereference -->
                  <!-- TODO: Not strictly necessary, can do *(e).age++; to override precedence -->
                  <!-- TODO: Arrow notation with arrays of structs -->
              <!-- TODO: Passing arrays of structs to funcs -- specifying dimensions if multiple -->
                <!-- TODO: Const arrays in parameters -->
            <!-- TODO: Structs within structs yo -->
            
            <!-- TODO: Struct vs Class -->
              <!-- TODO: Exactly the same (left around for legacy) EXCEPT: -->
                <!-- TODO: declaring something with the word struct defaults to its members being public -->
                <!-- TODO: declaring something with the word class defaults to its members being private -->
            
            
          
        </div>
      </div>
      <!-- END MAIN CONTENT -->
      
      
    </div>
    <!-- END WRAPPER -->
    
    <!-- BEGIN FOOTER -->
    <div id="footer">
      <div class="container">
        <div class="col-md-12 text-center">
          
        </div>
      </div>
    </div>
    <!-- END FOOTER -->
    
  </body>
</html>
