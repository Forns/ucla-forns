
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <title>Andrew Forney - UCLA CS</title>
    <link href="../../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../../../css/magic-bootstrap.css" rel="stylesheet" type="text/css">
    <link href="../../../css/main.css" rel="stylesheet" type="text/css">
    <script src="../../../js/lib/jquery-2.0.3.min.js"></script>
    <script src="../../../js/lib/bootstrap.min.js"></script>
    <script src="../../../js/lib/expanding.js"></script>
    <script src="../../../js/display/general/general-display.js"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
  </head>
  
  <body data-spy="scroll" data-target="#scrollspy">
    
    <!-- BEGIN WRAP -->
    <div id="wrap">
      
      <!-- BEGIN NAVIGATION -->
      <nav class='navbar navbar-default' role='navigation'>
        <div class='nav-accent'></div>
        <div class='container'>
          <div class='row'>
            <div class='col-md-12'>
              <div class='navbar-header'>
                <button class='navbar-toggle' type='button' data-toggle='collapse' data-target='.navbar-main-collapse'>
                  <span class='sr-only'>Toggle Navigation</span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                </button>
                <a class='navbar-brand' href='/~forns/'>
                  <span id='brand-text'>
                    Andrew Forney
                  </span>
                </a>
              </div>
              
              <div id='nav-main' class='collapse navbar-collapse navbar-main-collapse'>
                <ul class='nav navbar-nav navbar-right'>
                  
                  <li>
                    <a href='/~forns/about.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-user'></span>
                      </div>
                      <p class='text-center'>About</p>
                    </a>
                  </li>
                  
                  <li class='active'>
                    <a href='/~forns/classes.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-book'></span>
                      </div>
                      <p class='text-center'>Classes</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/contact.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-comment'></span>
                      </div>
                      <p class='text-center'>Contact</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/publications.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-file'></span>
                      </div>
                      <p class='text-center'>Publications</p>
                    </a>
                  </li>
                  
                </ul>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <!-- END NAVIGATION -->
      
      <!-- BEGIN MAIN CONTENT -->
      <div id="main-content" class="container">
        <div class="row">
          
          <!-- BEGIN SCROLLSPY -->
          <div class='col-md-2'>
            <div class="bs-sidebar hidden-print affix" role="complementary">
              <ul id='scrollspy' class="nav bs-sidenav">
              </ul>
            </div>
          </div>
          <!-- END SCROLLSPY -->
          
          <!-- BEGIN PRESENTATION CONTENT -->
          <div class='col-md-10 presentation-content' role='main'>
            <ol class="breadcrumb">
              <li><a href="../../../classes.html">Classes</a></li>
              <li><a href="./cs-31.html">Fall13 CS31</a></li>
              <li class="active">Week 8</li>
            </ol>
            
            <div id='review' class='scrollspy-element' scrollspy-title='Questions from Week 7'></div>
            <h1>dammitAndrew Revisited (for the last time)</h1>
            <div>
              <p>Sooo, turns out I'm dumb and have accepted that now. In the quest for diverse examples, I gave you this:</p>

<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cctype&gt;
  using namespace std;
  
  double dammitAndrew (double&amp; d);
  double trickz = 1.0;
  
  int main () {
      cout &lt;&lt; (dammitAndrew(trickz) + trickz) &lt;&lt; endl;
      trickz = 1.0;
      cout &lt;&lt; (trickz + dammitAndrew(trickz)) &lt;&lt; endl;
      trickz = 1.0;
      cout &lt;&lt; (dammitAndrew(trickz) + dammitAndrew(trickz)) &lt;&lt; endl;
  }
  
  double dammitAndrew (double&amp; d) {
      d += d;
      return d;
  }
</pre>
              <p>We got some strange results across compilers that appeared to disobey the laws of precedence. Well, you can put your worries to rest, it turns out this is undefined behavior.</p>
              <p>After consulting the C++ standard, asking 4 other TAs (the good news is they didn't know either so I feel less guilty), and finally Smallberg:</p>
              <p class='definition'>Calling a function that modifies a variable by reference in the same expression will have undefined behavior for the variable's value in the expression.</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='introMem' class='scrollspy-element' scrollspy-title='Main Memory'></div>
            <h1>Remember Main Memory?</h1>
            <div>
              <p>Pointers put us closer to the memory than we've seen in the past, so let's start with a review of how our code and variables are stored in memory.</p>
              <p class='definition'><strong>Main Memory</strong> consists of a contiguous sequence of bytes (8 bits) that each have a memory address associated with them.</p>
              <p class='definition'><strong>Memory Addresses</strong> are just like indexes in an array; they are a sequential numbering of the memory cells.</p>
              <p>Pictorially, we think of main memory looking like the following, with each cell being 1 byte:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/fall-2013/cs-31/week-8/pointers0.PNG' />
              </div>
              <p>Now, the problem is that whenever I declare a variable on different computers with different types and possibly different compilers, I allocate a certain amount of memory.</p>
              <p>Because the amount of memory allocated might be different depending on these distinctions, I want an easy way of &quot;moving around&quot; memory and its contents (pointers!).</p>
              <p>Take the following simple statement for example: <code class='prettyprint'>int x = 16;</code></p>
              <p class='question' name='intro-q0'>Do I, as the programmer, know where the compiler is going to reserve space for x in memory?</p>
              <p class='answer' name='intro-q0'>No! The compiler will allocate space for x somewhere that is big enough to hold an int, and then place the value 16 inside.</p>
              <p>So imagine that on some computer, an int takes up 4 bytes of memory (WARNING: We are NOT guaranteed this!), and our compiler sticks it at memory address 1000, then in memory we have:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/fall-2013/cs-31/week-8/pointers1.PNG' />
              </div>
              <p>We'll leave the specifics of how x is stored in memory to an architecture class, but because we know it took up 4 bytes on our system, we know that it spans addresses 1000 - 1003.</p>
              
              <p>Similarly, when we declare an array of some type, we know a couple of things about how it gets represented in memory.</p>
              <p>Take the following initialization for example: <code class='prettyprint'>char c[] = &quot;cat&quot;;</code></p>
              <p>We are guaranteed a couple of things:</p>
              <ul class='indent-1'>
                <li><p>We know that each cell holding a character of the cstring &quot;cat&quot; will take up the same amount of space on any given system.</p></li>
                <li><p>
                  Each character in the cstring &quot;cat&quot; will be located contiguously in memory, meaning that if a <code class='prettyprint'>char</code> takes up 1 byte on our system, 
                  then above, c will take up 4 bytes of space in a row in memory (don't forget about the null terminator!).
                </p></li>
              </ul>
              <p>Pictorially, if our compiler decided to stick c starting at memory location 1000:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/fall-2013/cs-31/week-8/pointers2.PNG' />
              </div>
            </div>
            <hr/>
            
            
            <br/>
            <div id='introPointers' class='scrollspy-element' scrollspy-title='Pointers: Intro'></div>
            <h1>Pointers: You'll Love Them or You'll Hate Them</h1>
            <br/>
            <div>
              <p>And no, there's no middle ground... But first, a relevant <a href='http://xkcd.com/138/' target='_blank'>XKCD</a>:</p>
              <div class='text-center fit-pres'>
                <img src='http://imgs.xkcd.com/comics/pointers.png' />
              </div>
              <p class='question' name='intro-q1'>Let's start off small... what is a pointer?</p>
              <p class='answer' name='intro-q1'>A variable that stores a reference (memory address) to another variable, or more generally, to some location in memory.</p>
              <p class='question' name='intro-q2'>So, Andrew... why do we even have pointers (i.e., what's the point?)</p>
              <div class='answer' name='intro-q2'>
                <p>To make you suffer! Just kidding (kinda, but really):</p>
                <ul class='indent-1'>
                  <li><p>Interfacing with C libraries and other low-level programming requires that we deal with pointers a lot.</p></li>
                  <li><p>Pointers bear similarities to other data structures (e.g. linked lists), which makes learning those more natural.</p></li>
                  <li><p>Any sort of memory management or study of computer architecture will benefit from knowledge of pointers.</p></li>
                </ul>
              </div>
              <p>Alright, well why do men have nipples?</p>
              <p>I don't have *all* the answers...</p>
              <p>But what I *do* have are some programmatic tools to help us with pointers in C++:</p>
              
              <br/>
              <h3>Basics: Declaration and Initialization</h3>
              <p class='toolkit'><strong>The reference operator (&amp;)</strong>: The reference operator says &quot;give me the memory address of my rvalue,&quot; or the expression to the right of the ampersand.</p>
              <p>We can look at our previous examples from the memory section:</p>
              <p class='example'>Say we made the following variable initialization and our compiler gave us this picture:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/fall-2013/cs-31/week-8/pointers1.PNG' />
              </div>
              <p class='question' name='intro-q3'>What, then, is the value of <code class='prettyprint'>&amp;x</code>?</p>
              <p class='answer' name='intro-q3'>1000, because <code class='prettyprint'>&amp;x</code> says, &quot;Give me the memory address of x, my rvalue.&quot; Here, 1000 is the memory address of the start of x, so that's what we return.</p>
              <p>But now we should talk about pointers... I guess...</p>
              <p class='toolkit'>
                <strong>Pointers</strong> store references (memory addresses) and are assigned a type corresponding to the type of variable that they point to.<br/><br/>
                We declare and initialize pointers using the * symbol:<br/>
                &lt;type&gt;* &lt;name&gt;; // Declares a pointer of the given &lt;type&gt; and calls it &lt;name&gt;.
              </p>
              <p>So, here are some legal pointer declarations:</p>
<pre class='prettyprint'>
  int* pointy;
  bool* sharp;
  char* thorny;
</pre>
              <p class='toolkit'>To <strong>initialize</strong> pointers, we give them memory addresses corresponding to locations of variables.</p>
<pre class='prettyprint'>
  // The variable being pointed at
  int pointedAt = 16;
  
  // The pointer that saves the memory location
  // of pointedAt, and so now effectively, points
  // at pointedAt
  int* pointer = &amp;pointedAt;
</pre>
              <p>Alright, great, so we've stored the memory addresses of some variables, how can pointers access the values that they point to?</p>
              <p class='toolkit'><strong>The dereference operator (*)</strong>: The dereference operator says &quot;Give me the value of whatever my rvalue is pointing to.&quot; NOTE: This means the rvalue must be a pointer, i.e., a memory address!</p>
              <p class='debug'>Will the following code compile? Will it have any undefined behavior? If &quot;No&quot; to both questions, what will it print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
    
  int main () {
      int pointedAt = -100;
      int* pointer = &amp;pointedAt;
      cout &lt;&lt; *pointer &lt;&lt; endl;
  }
</pre>
              <p>Assuming our system is representing ints with 4 bytes and the compiler reserved memory for pointedAt at address 1000, then:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/fall-2013/cs-31/week-8/pointers3.PNG' />
              </div>
              <p>Alright, so how about some nifty memory tricks for these operators?</p>
              <p class='toolkit'>To remember when to use &amp; and when to use *, think:<br/>
                <strong>Ampersand:</strong> Address<br/>
                <strong>Star:</strong> Substance
              </p>
              <p>But Andrew, * is technically an Aster--well fine then! Make your own damn memory trick!</p>
              <p>So let's see some information about the pointer we've constructed:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
      
  int main () {
      int pointedAt = -100;
      int* pointy = &amp;pointedAt;
  
      cout &lt;&lt; "The value of what pointy points at: " 
           &lt;&lt; *pointy &lt;&lt; endl;
      cout &lt;&lt; "The address of what pointy points at: " 
           &lt;&lt; pointy &lt;&lt; endl;
      cout &lt;&lt; "The address of where pointy is stored: " 
           &lt;&lt; &amp;pointy &lt;&lt; endl;
      // Will the above two be the same?
  }
</pre>

              <p>How about some examples?</p>
              <p class='debug'>Will the following code compile? Will it have any undefined behavior? If &quot;No&quot; to both questions, what will it print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
    
  int main () {
      int ruhRoh;
      int* pointy = &amp;ruhRoh;
      cout &lt;&lt; *pointy &lt;&lt; endl;
  }
</pre>
              <p class='debug'>Will the following code compile? Will it have any undefined behavior? If &quot;No&quot; to both questions, what will it print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
    
  int main () {
      int imAnInt = -100;
      int* pointy = imAnInt;
      cout &lt;&lt; *pointy &lt;&lt; endl;
  }
</pre>
              <p class='debug'>WARNING: Unlike with types such as int, double, bool, and char, which, when given another type can sometimes convert to the other, pointers MUST point to the same type as them.</p>
              <p class='debug'>Will the following code compile? Will it have any undefined behavior? If &quot;No&quot; to both questions, what will it print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
    
  int main () {
      int imAnInt = 2;
      double imADouble = 2.2;
      int* pointy = &amp;imAnInt;
      cout &lt;&lt; *pointy &lt;&lt; endl;
      pointy = &amp;imADouble;
      cout &lt;&lt; *pointy &lt;&lt; endl;
  }
</pre>
              <p>We'll see why we need type rigidity for pointers in a later section.</p>
                      
              <p class='definition'>Note: Reference and dereference operators could be considered inverses of one another, i.e., they &quot;undo&quot; each other.</p>
              <p class='debug'>Will the following code compile? Will it have any undefined behavior? If &quot;No&quot; to both questions, what will it print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
    
  int main () {
      int imAnInt = -100;
      int* pointy = &amp;*&amp;imAnInt;
      cout &lt;&lt; *pointy &lt;&lt; endl;
  }
</pre>
              <p class='debug'>Will the following code compile? Will it have any undefined behavior? If &quot;No&quot; to both questions, what will it print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
    
  int main () {
      int imAnInt = 2;
      int* pointy = &amp;imAnInt;
      cout &lt;&lt; *(&amp;(*pointy)) &lt;&lt; endl;
  }
</pre>

              <br/>
              <h3>Basics: Assigning to Pointers</h3>
              <p>Knowing when to use the reference and dereference operators is a bit tricky, and so the best thing to do is to translate your intent into English first.</p>
              <p class='toolkit'>Whenever we want to assign a value to the memory location that a pointer is pointing to, we use the following syntax:<br/><br/>*ptr = value;</p>
              <p class='example'>Translate the following pointer statements into English analyses of what they're doing. The first is done for you:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
    
  int main () {
      // Variables to be pointed at
      int i = 0;
      double d = 3.3;
      bool b;
  
      // Pointers
  
      // An integer pointer that points to the memory address
      // at which int i is located
      int* iPtr = &amp;i;
  
      // What's happening here?
      double* dPtr = &amp;*&amp;d;
  
      // Is this going to be a problem? If so, when?
      bool* bPtr = &amp;b;
  
      // What's happening here?
      *iPtr = 20;
  
      // What's happening here?
      *&amp;*dPtr = 3.33;
  
      b = (*iPtr % 2 == 0) || (*dPtr &gt; 4);
  
      cout &lt;&lt; i &lt;&lt; endl;
      cout &lt;&lt; *iPtr &lt;&lt; endl;
      cout &lt;&lt; d &lt;&lt; endl;
      cout &lt;&lt; *dPtr &lt;&lt; endl;
      cout &lt;&lt; b &lt;&lt; endl;
      cout &lt;&lt; *bPtr &lt;&lt; endl;
  }
</pre>
              <p>It's also perfectly legal to assign pointers to each other, so long as the types agree:</p>
              <p class='debug'>Will the following code compile? Will it have any undefined behavior? If &quot;No&quot; to both questions, what will it print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
      
  int main () {
      int pointedAt = 1;
      int* pointy = &pointedAt;
      // ditto used point!
      int* ditto = pointy;
  
      // Will these 2 be equal?
      cout &lt;&lt; *pointy &lt;&lt; endl;
      cout &lt;&lt; *ditto &lt;&lt; endl;
  
      // Will these 2 be equal?
      cout &lt;&lt; pointy &lt;&lt; endl;
      cout &lt;&lt; ditto &lt;&lt; endl;
  }
</pre>
              <p>But what about uninitialized pointers?</p>
              <p class='debug'>Will the following code compile? Will it have any undefined behavior? If &quot;No&quot; to both questions, what will it print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
    
  int main () {
      // To what is lamePointz pointing after this line?
      int* lamePointz;
      // To what address are we making this assignment?
      *lamePointz = 5;
  
      cout &lt;&lt; *lamePointz &lt;&lt; endl;
  }
</pre>
              <p>So be careful! Uninitialized pointers can lead to undefined behavior or illegal memory accesses when they haven't been assigned somewhere first.</p>
              <p>What can we do to be safe about uninitialized pointers?</p>
              <p>There is a special keyword called <code class='prettyprint'>nullptr</code> that represents &quot;the pointer that points at nothing.&quot;</p>
              <p>Andrew, that's very zen, we should stop and ponder life.</p>
              <p>Nonsense! There are pointers to discuss!</p>
              <p class='toolkit'>The <strong>nullptr</strong> keyword is a pointer literal that indicates a pointer that isn't pointing anywhere. We use it for safety (to not dereference a nullptr) and clarity.</p>
              <p class='debug'>WARNING: nullptr might not be supported in your compiler and may throw a compile error saying that nullptr is not defined in scope.</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
      
  int main () {
      // lamePointz is now safely pointing at nothing
      int* lamePointz = nullptr;
      // ...so later when we try to dereference and assign...
      *lamePointz = 5;
      // ...our code will break, but it will break reliably,
      // indicating that we have an error in the code, rather
      // than continuing blissfully unaware of our mistake
      // as we may have possibly done in the example above
    
      cout &lt;&lt; *lamePointz &lt;&lt; endl;
  }
</pre>
              <p>Note, we can check to make sure a pointer is or is not the null pointer (test for equivalence):</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
      
  int main () {
      int i = 50;
      int* latePointer = nullptr;
  
      if (latePointer == nullptr) {
          latePointer = &amp;i;
      } else {
          cout &lt;&lt; "&lt;_&lt; &gt;_&gt;" &lt;&lt; endl;
      }
      cout &lt;&lt; *latePointer &lt;&lt; endl;
  }
</pre>
              
              <p class='debug'>Will the following code compile? Will it have any undefined behavior? If &quot;No&quot; to both questions, what will it print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
    
  int main () {
      int* possiblyLame;
      int x = 50;
      possiblyLame = &amp;x;
  
      cout &lt;&lt; *possiblyLame &lt;&lt; endl;
  }
</pre>
              <p class='debug'>WARNING: Be wary of using the postfix increment operator with pointers; remember that they increment the lvalue after everything else is done...</p>
              <p class='debug'>Will the following code compile? Will it have any undefined behavior? If &quot;No&quot; to both questions, what will it print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
      
  int main () {
      int pointedAt = 1;
      int* pointy = &pointedAt;
  
      *pointy++;
  
      cout &lt;&lt; *pointy &lt;&lt; endl;
      cout &lt;&lt; pointedAt &lt;&lt; endl;
  }
</pre>
              <br/>
              <p class='example'>What will the following code print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cctype&gt;
  using namespace std;
  
  int main () {
      bool b = 0;
      int first = 1;
      double second = 2.2;
          
      int* fPtr = &first;
      int* fPtrRedux = fPtr;
      double* sPtr = &second;
      
      *fPtr += -1;
      *(sPtr + *fPtrRedux) = 2.222;
      b = *fPtr &amp;&amp; *sPtr;
      
      cout &lt;&lt; b &lt;&lt; endl;
      cout &lt;&lt; first &lt;&lt; endl;
      cout &lt;&lt; second &lt;&lt; endl;
  }
</pre>
            </div>
            <hr/>
            
            
            <br/>
            <div id='arrayPointers' class='scrollspy-element' scrollspy-title='Pointers &amp; Arrays'></div>
            <h1>Pointers &amp; Arrays</h1>
            <br/>
            <div>
              <p>Pointers may have felt like an exercise in futility before now, but they make a little more sense when it comes to arrays.</p>
              <p>Let's return with our simple example from before, this time, assuming the compiler has placed the array c at index 4000, but still treats characters as 1 byte a piece:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/fall-2013/cs-31/week-8/pointers4.PNG' />
              </div>
              <p>But wait a second... I drew an arrow from c to the start of the array in memory... could it be?</p>
              <p>Could our array identifiers actually be... pointers?!</p>
              <p>In a twist more dramatic than the conclusion of Survivor XXI, the answer is: yes, but once we've declared an array to an identifier, we can't reassign it (seen later).</p>
              <p>So what has our bracket notation for array indecies meant this whole time?</p>
              <p class='toolkit'>The bracket notation of pointers can be thought of as &quot;dereference with offset,&quot; meaning that, if ptr is a pointer:<br/><br/>
                <code class='prettyprint'>ptr[offset]</code> is equivalent to saying <code class='prettyprint'>*(ptr + offset)</code>, meaning &quot;Give me the value at offset locations away from memory address ptr.&quot;
              </p>
              <p class='toolkit'>A <strong>pointer offset</strong> is a number indicating how many x bytes away the next or previous value is, depending on the type of the pointer.<br/><br/>
                For example, if an int is treated as 4 bytes, and I want to access the int directly following the int at address 1000 (as in an int array starting at address 1000), then 
                an int pointer offset of 1 tells me to look 4 bytes later, at memory address 1004. Similarly, an int pointer offset of -2 tells me to look 8 bytes before, at memory address 992, etc.
              </p>
              <p>So let's look at our example again in terms of offsets:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/fall-2013/cs-31/week-8/pointers5.PNG' />
              </div>
              <p>A couple things to note above:</p>
              <ul class='indent-1'>
                <li><p>Notice how c is an array of chars, and so c is a char pointer, meaning that its offsets assume the next char is 1 byte away.</p></li>
                <li><p>The bracket c[i] notation is equivalent to the offset *(c + i) notation.</p></li>
                <li><p>Although we could generate a pointer to c[4] by saying &amp;c[4], it would be unsafe to assign anything to c[4] (overflow).</p></li>
              </ul>
              <br/>
              <div class='question' name='arrays-q0'>OK, so if I had an array of ints where ints were treated as 4 bytes a piece, then fill in the blanks below:<br/>
                <div class='text-center fit-pres'>
                <img src='../../../assets/images/fall-2013/cs-31/week-8/pointers6q.PNG' />
              </div>
              </div>
              <div class='answer' name='arrays-q0'>
                <div class='text-center fit-pres'>
                <img src='../../../assets/images/fall-2013/cs-31/week-8/pointers6a.PNG' />
              </div>
              </div>
              <p class='definition'>Takeaway message: Every time I use an offset with a pointer, it automatically scales to how large its type is in memory.</p>
              <p>Alright, back to our character array example...</p>
              <p>Although c is still an identifier used as a pointer, because it was declared as an array, we cannot change its value...</p>
              <p class='debug'>Will the following code compile? If so, what will it print?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
      
  int main () {
      char c[] = "cat";
      int len = strlen(c);
  
      for (int i = 0; i &lt; len; i++) {
          cout &lt;&lt; c[0] &lt;&lt; endl;
          c++; // hey! that's this language!
      }
  }
</pre>
              <p>So how could we do what the above is trying to do? Well, we can use another pointer to refer to where c starts:</p>
              <p class='debug'>Will the following code compile? If so, what will it print?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
      
  int main () {
      char c[] = "cat";
      char* helper = c;
      int len = strlen(c);
  
      for (int i = 0; i &lt; len; i++) {
          cout &lt;&lt; helper[0] &lt;&lt; endl;
          helper++;
      }
  }
</pre>
              <p>I could even condense the above using some pointer dereferences:</p>
              <p class='debug'>Will the following code compile? If so, what will it print?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
      
  int main () {
      char c[] = "cat";
  
      for (char* helper = c; *helper != '\0'; helper++) {
          cout &lt;&lt; helper[0] &lt;&lt; endl;
      }
  }
</pre>
              <p class='debug'>Will the following code compile? If so, what will it print?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
      
  int main () {
      char c[] = "cat";
  
      for (char* helper = c; *helper != '\0'; helper++) {
          // What happens when we just print out c?
          // Forney
          cout &lt;&lt; helper &lt;&lt; endl;
      }
  }
</pre>
              <p class='debug'>Will the following code compile? If so, what will it print?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
      
  int main () {
      char c[] = "cat";
      
      // Notice our new iterator increment...
      for (char* helper = c; *helper != '\0'; helper = &amp;helper[1]) {
          cout &lt;&lt; helper[0] &lt;&lt; endl;
      }
  }
</pre>
              
              <br/>
              <h3>Pointer Arithmetic and Operators</h3>
              <p>We've seen a couple of pointer operations already, but some are not well defined.</p>
              <p class='toolkit'>Subtraction and addition to pointers is well defined, such that if I say (ptr + i), it means &quot;refer to the address i times x bytes away from ptr,&quot; where x is the size of the type of ptr.</p>
              <p class='example'>What will the following code output?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
      
  int main () {
      double d[] = {1.1, 2.2, 3.3, 4.4, 5.5};
      double* ptr = d;
  
      // Here, I'm referencing offsets from ptr
      cout &lt;&lt; *ptr &lt;&lt; endl;
      cout &lt;&lt; *(ptr + 1) &lt;&lt; endl;
      cout &lt;&lt; ptr[2] &lt;&lt; endl;
  
      // Note where ptr points now that I've
      // reassigned it
      ptr += 2;
      cout &lt;&lt; ptr[2] &lt;&lt; endl;
  }
</pre>
              <p class='toolkit'>Pointers are NOT defined on multiplication or division; why would you do that to a memory address? :(</p>
              <p class='debug'>Will the following code compile? If so, what will it print?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
      
  int main () {
      double d[] = {1.1, 2.2, 3.3, 4.4, 5.5};
      double* ptr = d;
  
      // Derp!
      cout &lt;&lt; *(ptr * 2) &lt;&lt; endl;
  }
</pre>
              <p class='toolkit'><strong>Pointer Comparisons</strong><br/>Pointers can always be compared for equivalence (do they point to the same address), but we must be careful... we still don't know where variables will be placed in memory at runtime.</p>
              <p>A consequence of not knowing where our variables live in memory can be undefined behavior:</p>
              <p class='debug'>Will the following code compile? Is there any undefined behavior possible? If &quot;No&quot; to both, what will it print?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
      
  int main () {
      char c[] = "cat";
      char t[] = "dog";
      char* cPtr = c;
      char* tPtr = t;
      int len = strlen(c);
  
      for (int i = 0; i &lt; len; i++) {
          if (cPtr &lt; tPtr) {
              cout &lt;&lt; "cPtr: " &lt;&lt; cPtr &lt;&lt; endl;
          } else {
              cout &lt;&lt; "tPtr: " &lt;&lt; tPtr &lt;&lt; endl;
          }
      }
  }
</pre>
              <p>Thus, there is no *guarantee* that tPtr will always be greater than cPtr, even though it might appear to work. Unpredictable behavior!</p>
              <p>That said...</p>
              <p class='toolkit'>Pointers *within* the same array are always guaranteed to be comparable using &lt;, &gt;, etc. because array elements are located contiguously in memory.</p>
              <p class='debug'>Will the following code compile? Is there any undefined behavior possible? If &quot;No&quot; to both, what will it print?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
      
  int main () {
      char c[] = "catdog";
      char* cPtr = c;
      int len = strlen(c);
  
      for (int i = 0; i &lt; len; i++) {
          if (cPtr &lt; &amp;c[3]) {
              cout &lt;&lt; *cPtr &lt;&lt; endl;
              cPtr++;
          }
      }
  }
</pre>
              <p class='toolkit'>When two pointers are operating in the same array, we can even subtract them to learn their *offsets,* not their difference in bytes.</p>
              <p class='debug'>Will the following code compile? Is there any undefined behavior possible? If &quot;No&quot; to both, what will it print?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
      
  int main () {
      int i[] = {5, 6, 7, 8, 9};
      int* iPtr = i;
      int len = 3;
  
      for (int j = 0; j &lt; len; j++) {
          if (iPtr &lt; &amp;i[3]) {
              // What will print here?
              cout &lt;&lt; (&amp;i[3] - iPtr) &lt;&lt; endl;
              iPtr++;
          }
      }
  }
</pre>
              <p class='debug'>WARNING: While it is perfectly legal to subtract two pointers, and well defined when they are in the same array, it is NOT legal to add two pointers.</p>
              <p>Alright, see if you can get THIS:</p>
              <p class='example'>What does the following code print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cctype&gt;
  using namespace std;
  
  int main () {
      char c[] = "testing";
      int len = strlen(c);
      
      for (int i = 0; i &lt; len / 2; i++) {
          char* front = &amp;c[i];
          char* back = &amp;c[len - i - 1];
          char stuff = *front;
          *front = *back;
          *back = stuff;
      }
      
      cout &lt;&lt; c &lt;&lt; endl;
  }
</pre>
            </div>
            <hr/>
            
            
            <br/>
            <div id='pointerFuncs' class='scrollspy-element' scrollspy-title='Pointers &amp; Functions'></div>
            <h1>Pointers &amp; Functions</h1>
            <br/>
            <div>
              <p>So let's talk about using functions with pointers... we've unlocked a whole new world of return and parameter types.</p>
              <div class='toolkit'><p>We can accept pointer parameters using a variety of notations:<br/><br/></p>
<pre class='prettyprint'>
void pointerFunc (int* i, int[] p) {
    ...
}
</pre>
              <p>Above, both i and p refer to int pointer parameters.</p>
              </div>
              <p class='example'>What does the following code print out?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  int* findInt (int arr[], int len, int match) {
      for (int i = 0; i &lt; len; i++) {
          if (arr[i] == match) {
              return &amp;arr[i];
          }
      }
      // Case where there is no match!
      return nullptr;
  };
  
  int main () {
      int i[] = {5, 6, 7, 8, 9};
      int* ptr = findInt(i, 5, 7);
  
      if (ptr != nullptr) {
          cout &lt;&lt; *ptr &lt;&lt; endl;
      } else {
          cout &lt;&lt; "null!" &lt;&lt; endl;
      }
  }
</pre>
              <p>Note, I could have just as easily written the following parameter definition for the input array:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  // See the difference?
  int* findInt (int* arr, int len, int match) {
      for (int i = 0; i &lt; len; i++) {
          if (arr[i] == match) {
              return &amp;arr[i];
          }
      }
      // Case where there is no match!
      return nullptr;
  };
  
  int main () {
      int i[] = {5, 6, 7, 8, 9};
      int* ptr = findInt(i, 5, 7);
  
      if (ptr != nullptr) {
          cout &lt;&lt; *ptr &lt;&lt; endl;
      } else {
          cout &lt;&lt; "null!" &lt;&lt; endl;
      }
  }
</pre>
              <br/>
              <p>Perhaps the most important thing to know about pointer parameters:</p>
              <p class='toolkit'>Pointer parameters are <strong>passed by value,</strong> meaning a copy of the address is made and is named by the parameter. The values that pointer can dereference and change are NOT copied.</p>
              <p>This explains why we can pass arrays using the pointer notation and still change the individual array elements without changing the pointer itself.</p>
              <p class='example'>What will the ptr in main point to after the function call to findInt?</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cstring&gt;
  using namespace std;
  
  void findInt (int arr[], int len, int match, int* ptr) {
      for (int i = 0; i &lt; len; i++) {
          if (arr[i] == match) {
              ptr = &amp;arr[i];
              return;
          }
      }
      ptr = nullptr;
  };
  
  int main () {
      int i[] = {5, 6, 7, 8, 9};
      int* ptr = i;
      findInt(i, 5, 7, ptr);
  
      if (ptr != nullptr) {
          cout &lt;&lt; *ptr &lt;&lt; endl;
      } else {
          cout &lt;&lt; "null!" &lt;&lt; endl;
      }
  }
</pre>
              
              <br/>
              <h3>Side-Notes about Functions</h3>
              <p>If we wanted to set the ptr in main to what was changed in findInt, we'd just make sure to pass by reference via: <code class='prettyprint'>int* &amp;ptr</code></p>
              <br/>
              <p>One might ask, then, what the difference is between pointers and references, and the answer is a subtle one (great discussion found <a href='http://stackoverflow.com/questions/57483/what-are-the-differences-between-pointer-variable-and-reference-variable-in-c' target='_blank'>here</a>):</p>
              <ul class='indent-1'>
                <li><p>A pointer can be reassigned any number of times while a reference can not be after initialization.</p></li>
                <li><p>A pointer can be set to the nullptr while references can never point to null (they are just names for other variables).</p></li>
                <li><p>You can not generate the address of a reference like you can with pointers.</p></li>
                <li><p>There are no &quot;reference arithmetics&quot; like we do with pointers (e.g., *(ptr + 1) or &amp;ptr + 4)</p></li>
              </ul>
              <br/>
              <p class='debug'>WARNING: What happens to local variables in a function once we return from that function?</p>
              <p>They are no longer safely allocated in memory! This means that I cannot guarantee that any variable local to a function will still be there after I've returned.</p>
              <p>Take the following for example:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cctype&gt;
  using namespace std;
  
  void naughtyFunc (int*&amp; n) {
      // What happens to i after naughtyFunc returns?
      int i[] = {5, 6, 7};
      n = i;
  }
  
  int main () {
      int* n;
      naughtyFunc(n);
      for (int i = 0; i &lt; 3; i++) {
          cout &lt;&lt; n[i] &lt;&lt; endl;
      }
  }
</pre>
              <p>This code has unpredictable behavior because we do not know what has happened to i after naughtyFunc has returned, as i is no longer allocated space in memory (remnants may still remain as junk).</p>
              <p class='example'>What will the following code print out? Warning, maturity levels are reaching 0...</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  #include &lt;cctype&gt;
  using namespace std;
  
  char* secretDecoder (char c[], int i[], int n) {
      for (int j = 0; j &lt; n; j++) {
          c[j] = c[*(i+j)];
      }
      c[n] = '\0';
      return c;
  }
  
  int main () {
      char c[] = "disproportionate";
      int i[] = {3, 5, 1, 0};
      // :D
      char* d = secretDecoder(c, i, 4);
      
      cout &lt;&lt; d &lt;&lt; endl;
  }
</pre>
              
            </div>
            <hr/>
            
            
          </div>
          <!-- END PRESENTATION CONTENT -->
          
          
        </div>
      </div>
      <!-- END MAIN CONTENT -->
      
      
    </div>
    <!-- END WRAPPER -->
    
    <!-- BEGIN FOOTER -->
    <div id="footer">
      <div class="container">
        <div class="col-md-12 text-center">
          
        </div>
      </div>
    </div>
    <!-- END FOOTER -->
    
  </body>
</html>
