
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <title>Andrew Forney - UCLA CS</title>
    <link href="../../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../../../css/magic-bootstrap.css" rel="stylesheet" type="text/css">
    <link href="../../../css/main.css" rel="stylesheet" type="text/css">
    <script src="../../../js/lib/jquery-2.0.3.min.js"></script>
    <script src="../../../js/lib/bootstrap.min.js"></script>
    <script src="../../../js/lib/expanding.js"></script>
    <script src="../../../js/display/general/general-display.js"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
  </head>
  
  <body data-spy="scroll" data-target="#scrollspy">
    
    <!-- BEGIN WRAP -->
    <div id="wrap">
      
      <!-- BEGIN NAVIGATION -->
      <nav class='navbar navbar-default' role='navigation'>
        <div class='nav-accent'></div>
        <div class='container'>
          <div class='row'>
            <div class='col-md-12'>
              <div class='navbar-header'>
                <button class='navbar-toggle' type='button' data-toggle='collapse' data-target='.navbar-main-collapse'>
                  <span class='sr-only'>Toggle Navigation</span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                </button>
                <a class='navbar-brand' href='/~forns/'>
                  <span id='brand-text'>
                    Andrew Forney
                  </span>
                </a>
              </div>
              
              <div id='nav-main' class='collapse navbar-collapse navbar-main-collapse'>
                <ul class='nav navbar-nav navbar-right'>
                  
                  <li>
                    <a href='/~forns/about.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-user'></span>
                      </div>
                      <p class='text-center'>About</p>
                    </a>
                  </li>
                  
                  <li class='active'>
                    <a href='/~forns/classes.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-book'></span>
                      </div>
                      <p class='text-center'>Classes</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/contact.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-comment'></span>
                      </div>
                      <p class='text-center'>Contact</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/publications.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-file'></span>
                      </div>
                      <p class='text-center'>Publications</p>
                    </a>
                  </li>
                  
                </ul>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <!-- END NAVIGATION -->
      
      <!-- BEGIN MAIN CONTENT -->
      <div id="main-content" class="container">
        <div class="row">
          
          <!-- BEGIN SCROLLSPY -->
          <div class='col-md-2 hidden-sm hidden-xs'>
            <div class="bs-sidebar hidden-print affix" role="complementary">
              <ul id='scrollspy' class="nav bs-sidenav">
              </ul>
            </div>
          </div>
          <!-- END SCROLLSPY -->
          
          <!-- BEGIN PRESENTATION CONTENT -->
          <div class='col-md-10 presentation-content' role='main'>
            
            <ol class="breadcrumb hidden-print">
              <li><a href="../../../classes.html">Classes</a></li>
              <li><a href="./cs-161.html">CS161</a></li>
              <li class="active">Week 4</li>
            </ol>
            
            <div id='constraintSat' class='scrollspy-element' scrollspy-title='Constraint Satisfaction'></div>
            <h1>Constraint Satisfaction Problems</h1>
            <div>
              <p>So we've been talking about classical search in something of a &quot;black-box&quot; fashion, meaning we have knowledge about states, transitions, and tests for goal states, but...</p>
              <p>...our search algorithms have treated states as atomic; there are no internal variables for us to wiggle and try to fix something that's wrong with a state to try to make it right.</p>
              <p class='definition'><strong>Constraint satisfaction problems (CSPs)</strong> use general purpose heuristic algorithms to try to find a solution using a set of variables and constraints.</p>
              <br/>
              <p>What does this mean?</p>
              <p>With CSPs, we define our states as consisting of a variety of variables that we then individually check against a variety of constraints / conditions.</p>
              <p>If our variable <strong>assignments</strong> in a given state are all <strong>consistent</strong> with our constraints, then we say that we've found a solution!</p>
              <p class='definition'>A CSP <strong>variable (X)</strong> is defined in terms of its <strong>domains (D)</strong>, such that a variable X_i can only attain a value in D_i in any given state.</p>
              <p class='definition'>A CSP <strong>constaint (C)</strong> is a Boolean condition for success on some variable instantiation.</p>
              <br/>
              <p>Therefore, we can phrase all of our constraint satisfaction problems as consisting of:</p>
              <ul class='indent-1'>
                <li><p>X: a set of variables {X_1, X_2, ..., X_n}</p></li>
                <li><p>D: a set of domains for those variables {D_1, D_2, ..., D_n} (one for each variable)</p></li>
                <li><p>C: a set of Boolean constraints / conditions that tell us when we've found a solution with our variables</p></li>
              </ul>
              <br/>
              <p class='debug'>NOTE: We've only found a solution whenever all of our constraints are satisfied, and <strong>every</strong> variable has been assigned a value from its respective domains!</p>
              <br/>
              <p>Later, however, we'll look at how knowing how many constraints we've failed can steer us in the right direction to a solution...</p>
              <p>So, the motto of CSP might be, &quot;I don't know what I'm looking for, but I'll know it when I see it! ...oh and I don't care about how I got there.&quot;</p>
              <p>Let's look at some simple examples using numerical variables and algebraic constriants.</p>
              <p class='example'>Consider the following constraint satisfaction problem specifications and find a solution for each.</p>
<pre class='prettyprint'>
  X = {A, B} ; Variables
  D = { {1, 2}, {0, -1} } ; Domains
  
  ; Constraint Set #1
  C = { A &lt; B; A * B &gt;= 0 }
  
  ; Constraint Set #2
  C = { A &gt; B; A * B &gt;= 0 }
  
  ; Constraint Set #3
  C = { A &gt; 0 }
  
  
  
  OK... Now that we are done with the warmups...
  
  ; Constraint Set #4
  X = {A, B, C, D, E, F, G, H, I, J, K, L, M, N}
  D = {
          {1, 2, 3}, {6, 7, 22}, {2, 9, 1}, {9, 1, 2},
          {taco, 2, 1}, {1, 2, huh?}, {"what is this", ":D"},
          {left, up, down, right}, {2B, !2B}, {-_-, 0_o, 42},
          {4th, 5th, 999th}, {blue pill, red pill},
          {Cat, Dog, Catdog}, {Q, T, PI}
      }
  C = {
          A &lt; (B + C * D);
          B != C + D (string concatenation);
          E = {taco if A = 1, 1 otherwise};
          N = {Q if M = cat, T if I = 2B};
          L = {blue pill IFF all other variables = 1st in their set}
      }
</pre>
              <br/>
              <p>...OK so I had a little fun with that last example...</p>
              <p>
                The point being, of course, that what might seem like a simple task of assigning values to variables and checking constraints can quickly become difficult with a lot of variables and
                constraints.
              </p>
              <p>In any event, this gives us a comparison between classical search and CSPs:</p>
              <table class='table table-striped table-bordered'>
                <caption>Classical Search vs. CSP</caption>
                <thead>
                  <tr>
                    <th><p>Property</p></th>
                    <th><p>Classical Search</p></th>
                    <th><p>CSP</p></th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <th><p>States</p></th>
                    <td><p>Problem-specific and atomic; cannot be divided into constituent components.</p></td>
                    <td><p>Variables, Domains, and Constraints</p></td>
                  </tr>
                  <tr>
                    <th><p>Success</p></th>
                    <td><p>Test a state to see if it meets our goal condition.</p></td>
                    <td><p>Assign values to all variables and see if that assignment meets all constraints</p></td>
                  </tr>
                  <tr>
                    <th><p>Cares about...</p></th>
                    <td><p>...the path from an initial state to a goal state</p></td>
                    <td><p>...an instantiation of variables that meets all constraints; path is irrelevant!</p></td>
                  </tr>
                  <tr>
                    <th><p>Applications</p></th>
                    <td><p>Pathfinding, optimization, etc.</p></td>
                    <td><p>SAT(isfiability), map coloring, scheduling, etc.</p></td>
                  </tr>
                </tbody>
              </table>
              <br/>
              <p>From our first example, we see that not all variable domains need be the same, or even the same type / format.</p>
              <p>Furthermore, as the domains of variables grow towards infinity, the problem of satisfying all of our constraints can become less and less tractable.</p>
              <p>So how do we tackle these problems? How do we design intelligent agents to perform reasoning on constraint satisfaction?</p>
              
              <br/>
              <h3>Formulating CSP as Search</h3>
              <p>&quot;Oh... we're back to search, Andrew?&quot;</p>
              <p>Yes, stop complaining!</p>
              <p>As it turns out, we can formulate our CSPs as search problems (using a search tree) using the following tactic:</p>
              <p class='definition'>A CSP Search Tree <strong>state</strong> is either a partial or complete instantiation of variables.</p>
              <p class='definition'>A CSP Search Tree <strong>leaf state</strong> is therefore a complete instantiation.</p>
              <p class='definition'>The <strong>initial state</strong> is therefore &quot;no assignment&quot; and each <strong>action</strong> assigns one variable to a value.</p>
              <p class='definition'>A <strong>goal state</strong> is then any complete assignment such that all constraints are satisfied.</p>
              <br/>
              <p>So, let's return to our simple example using numerical variables and algebraic constraints:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/spring-2014/cs-161/week-4/csp-0.PNG' />
              </div>
              <br/>
              <p class='question' name='csp-q0'>What is the depth of this type of CSP tree in terms of one of our CSP parameters (V, D, or C)?</p>
              <p class='answer' name='csp-q0'>Simply the number of variables because it will take |V| actions to reach a complete instantiation!</p>
              
              <br/>
              <h3>Constraint Propagation</h3>
              <p>As we've seen with CSP search, the more possible variable assignments in our search tree, the larger it becomes and longer it takes to search.</p>
              <p>So, in order to improve our efficiency, we attempt to reduce the domains of our variables to those assignment combinations that are possible.</p>
              <p>For example, if one of our variables had the domain of integers from 1 to 10, and a constraint said that variable couldn't be 5, then it would be wasteful to keep 5 within the domain!</p>
              <p class='definition'>
                <strong>Constraint propagation</strong> provides a means of reducing our variable domains by considering the constraints that a domain element has the possibility of satisfying. If a domain
                element has *no* possibility of satisfying a constraint, we simply prune it from the domain!
              </p>
              <p class='definition'><strong>Node consistency</strong> determines if any unary constraints on a variable are met by each element of that variable's domain.</p>
              <br/>
<pre class='prettyprint'>
  ; In the following example, A &amp; B are Node Consistent:
  X = { A, B }
  D = { {1, 2}, {3, 4} }
  C = {
        A != 3
        B != 5
      }
      
  ; In the following example, A &amp; B are NOT Node Consistent:
  X = { A, B }
  D = { {1, 2}, {3, 4} }
  C = {
        A != 2
        B != 3
      }
      
  ; To resolve the above node inconsistency, we
  ; amend the domains of A and B to be:
  X = { A, B }
  D = { {1}, {4} }
  C = {
        A != 2
        B != 3
      }
</pre>
              <br/>
              <p class='definition'><strong>Arc consistency</strong> determines if any binary constraints between two variables can be met by all elements in their domains.</p>
              <br/>
              <p>
                In other words, we want to verify that for two variables X and Y that both appear within a constraint (e.g. X &lt; Y), all values in the domain of X can satisfy the constraint if at least
                one value in the domain of Y can be paired with that value in the domain of X.
              </p>
<pre class='prettyprint'>
  ; In the following example, A &amp; B are Arc Consistent:
  X = { A, B }
  D = { {1, 2}, {3, 4} }
  C = {
        A &lt; B
        B &gt;= 2 * A
      }
      
  ; In the following example, A &amp; B are NOT Arc Consistent:
  X = { A, B }
  D = { {1, 2}, {3, 4} }
  C = {
        A &lt; B
        B &gt; 2 * A
      }
      
  ; To resolve the above arc inconsistency, we
  ; amend the domains of A and B to be:
  X = { A, B }
  D = { {1}, {3, 4} }
  C = {
        A &lt; B
        B &gt; 2 * A
      }
</pre>
              <p>To automate arc consistency fixes, we can use an algorithm called AC-3. (page 209 of your book)</p>
              <p>To picture how AC-3 works, you can imagine our CSP as a graph with nodes as the variables, and edges between any two variables that are found in the same constraint.</p>
              <p>Let's see an example CSP and arc consistency graph.</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/spring-2014/cs-161/week-4/csp-3.PNG' />
              </div>
              <br/>
              <p>
                Now, we see that our arcs happen to involve binary constraints between all three of our variables, so we want to assess each of these arcs and determine whether or not there are
                elements to remove from any of the domains.
              </p>
              <p>Each arc can be considered a tuple (A, B) where A is the node/variable from which an arc originates and B is the terminal node.</p>
              <p>This gives us 6 arcs in our problem: (W, X), (X, W), (W, Y), (Y, W), (X, Y), and (Y, X)</p>
              <p>We begin AC-3 with all of our arcs to be assessed, and proceed as follows:</p>
<pre class='prettyprint'>
  ; Reduced AC-3 Pseudocode
  enqueue all arcs in your CSP
  while that queue is not empty
      check if current arc (A, B) is consistent
      ; i.e., there is at least 1 value in B satisfying
      ; the constraint for every value in A
      
      if a value in the domain of A is unsatisfiable, remove that val
      if any value was removed from A then do:
          if the domain of A is reduced to &empty;, return false
          enque all arcs from C_i to A (C_i, A) where C_i = all neighbor nodes of A except B
          
  return true (if your queue is empty and you've made all domains arc consistent)
</pre>
              <br/>
              <p>Let's try it with our example!</p>
<pre class='prettyprint'>
  Vars: {W, X, Y}
  Domains (for each): {0, 1, 2}
  Constraints:
  {
    W != X,
    W = floor(Y/2),
    X &lt; Y
  }
  
  ; Step 1: Queue up those arcs!
  Q = { (W, X), (X, W), (W, Y), (Y, W), (X, Y), (Y, X) }
  
  </pre>
  <pre class='prettyprint'>
  ; ----------------------------------------------------
  ; While Q is not empty...
  ; Step 2: Choose an arc from the queue
  
  chosenArc = (W, X)
  DomainW = {0, 1, 2}
  DomainX = {0, 1, 2}
  constraint = W != X
  
  ; Arc is consistent! Remove this arc from queue!
  
  </pre>
  <pre class='prettyprint'>
  ; ----------------------------------------------------
  Q = { (X, W), (W, Y), (Y, W), (X, Y), (Y, X) }
  
  chosenArc = (X, W)
  DomainW = {0, 1, 2}
  DomainX = {0, 1, 2}
  constraint = W != X
  
  ; Arc is consistent! Remove this arc from queue!
  
  </pre>
  <pre class='prettyprint'>
  ; ----------------------------------------------------
  Q = { (W, Y), (Y, W), (X, Y), (Y, X) }
  
  chosenArc = (W, Y)
  DomainW = {0, 1, 2}
  DomainY = {0, 1, 2}
  constraint = W = floor(Y/2)
  
  ; Arc is inconsistent! W can never be 2, so prune it,
  ; and add neighbors of W (X, W) to queue
  DomainW = {0, 1}
  
  </pre>
  <pre class='prettyprint'>
  ; ----------------------------------------------------
  Q = { (Y, W), (X, Y), (Y, X), (X, W) }
  
  chosenArc = (Y, W)
  DomainW = {0, 1}
  DomainY = {0, 1, 2}
  constraint = W = floor(Y/2)
  
  ; Arc is consistent! Remove this arc from queue!
  
  </pre>
  <pre class='prettyprint'>
  ; ----------------------------------------------------
  Q = { (X, Y), (Y, X), (X, W) }
  
  chosenArc = (X, Y)
  DomainX = {0, 1, 2}
  DomainY = {0, 1, 2}
  constraint = X &lt; Y
  
  ; Arc is inconsistent! X can never be 2, so prune it,
  ; and add neighbors of X (W, X) to queue
  DomainX = {0, 1}
  
  </pre>
  <pre class='prettyprint'>
  ; ----------------------------------------------------
  Q = { (Y, X), (X, W), (W, X) }
  
  chosenArc = (Y, X)
  DomainX = {0, 1}
  DomainY = {0, 1, 2}
  constraint = X &lt; Y
  
  ; Arc is inconsistent! Y can never be 0, so prune it,
  ; and add neighbors of Y (W, Y) to queue
  DomainY = {1, 2}
  
  </pre>
  <pre class='prettyprint'>
  ; ----------------------------------------------------
  Q = { (X, W), (W, X), (W, Y) }
  
  chosenArc = (X, W)
  DomainX = {0, 1}
  DomainW = {0, 1}
  constraint = W != X
  
  ; Arc is consistent! Remove this arc from queue!
  
  </pre>
  <pre class='prettyprint'>
  ; ----------------------------------------------------
  Q = { (W, X), (W, Y) }
  
  chosenArc = (W, X)
  DomainX = {0, 1}
  DomainW = {0, 1}
  constraint = W != X
  
  ; Arc is consistent! Remove this arc from queue!
  
  </pre>
  <pre class='prettyprint'>
  ; ----------------------------------------------------
  Q = { (W, Y) }
  
  chosenArc = (W, Y)
  DomainW = {0, 1}
  DomainY = {1, 2}
  constraint = W = floor(Y/2)
  
  ; Arc is consistent! Remove this arc from queue!
  
  </pre>
  <pre class='prettyprint'>
  ; ----------------------------------------------------
  Q = { }
  
  ; Queue is empty! We are done, return true!
  ; Our domains were therefore modified to:
  DomainW = {0, 1}
  DomainX = {0, 1}
  DomainY = {1, 2}
  
  ; Reducing the size of our search space substantively!
</pre>
              
              <br/>
              <h3>Map Coloring Problem</h3>
              <p>Perhaps the most widely used example for CSPs is the map coloring problem.</p>
              <p class='definition'>
                The <strong>map coloring problem</strong> asks if, given a map consisting of a set of states, with some adjacent to others, can you assign one of N colors to each state such that no two
                adjacent states have the same color? (NB: here state means the type you'd find in a country, like California)
              </p>
              <br/>
              <br/>
              <p>Some map coloring solvers will go a step further and ask: &quot;If so, what is the minimum number of colors required to complete this task?&quot;</p>
              <p>Let's formulate this as a constraint satisfaction problem!</p>
              <p class='question' name='csp-q1'>What will a state (here, state means the state in our search tree) look like in our map coloring CSP?</p>
              <p class='answer' name='csp-q1'>The assignment of one of the N colors to each of the variables (representing the map states).</p>
              <br/>
              <p class='question' name='csp-q2'>What will our constraints look like?</p>
              <p class='answer' name='csp-q2'>A set of map-state adjacencies such that no adjacency pair may ever be assigned the same color.</p>
              <br/>
              <p class='example'>What is the minimum N (where N is the number of colors) you could use to color the great Republic of Forns, below?</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/spring-2014/cs-161/week-4/csp-1.PNG' />
              </div>
              <br/>
              <p class='example'>Sketch a search tree for the CSP above, given the minimum N you decided for the map coloring.</p>
              <br/>
              <p class='question' name='csp-q3'>What do we notice about CSP node expansion that will save us some work?</p>
              <p class='answer' name='csp-q3'>As soon as we discover an inconsistency, we need not continue to explore down that path!</p>
              
              <br/>
              <h3>CSP as Local Search</h3>
              <p>Now... what would happen if the proud people of The Republic of Forns all declared independence and separated the states into millions of sovereign bodies?</p>
              <p>Would our CSP search tree for the map coloring problem be tractable?</p>
              <p>Errr... no... millions of variables? Not gonna work...</p>
              <p class='definition'>
                <strong>CSP Local Search</strong> operates under the same principles of classical local search: start off with a random complete instantiation, and then try to tweak erroneous
                assignments into a constraint-consistent solution
              </p>
              <br/>
              <p>So, just as an example using our 5-state map from before, we could arrive at the following partial instantiation for, say, N = 3 colors:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/spring-2014/cs-161/week-4/csp-2.PNG' />
              </div>
              <br/>
              <p class='question' name='csp-q4'>How should we choose which, amongst these adjacent possible solutions, to move to next?</p>
              <p class='answer' name='csp-q4'>
                Define a scoring function that assigns a higher cost to adjacent instantiations that violate more constraints! The lower the cost, the fewer constraints that are violated.
              </p>
              <br/>
              <p class='question' name='csp-q5'>What were some of the improvements we talked about with classical local search that might apply to CSP local search?</p>
              <div class='answer' name='csp-q5'>
                <ul class='indent-1'>
                  <li><p><strong>Random restarts:</strong> if we go too many iterations without finding a solution, just start from scratch with a new starting instantiation.</p></li>
                  <li><p><strong>Sideways movements:</strong> allow movements to instantiations that have the same cost score as the one we're currently investigating.</p></li>
                  <li><p><strong>Downward movements:</strong> 
                    for example, simulated annealing allows some movements to instantiations with *worse* scores than the one we're currently looking at, but is only likely to try one if we've
                    been through many failed iterations prior to the downward movement (i.e., we're more likely to take a downward movement the longer we've been searching)
                  </p></li>
                </ul>
              </div>
              
              <br/>
              <p>So far, with our search strategies, we've begun our problems under the assumption that we don't know anything about a possible solution...</p>
              <p>In classical search, all we could do was guess with some amount of confidence where in the search tree a solution was likely to be found relative to our initial state...</p>
              <p>With CSPs, we started with blank variable instantiations and tried to find one that satisfied all of our constraints.</p>
              <p>What if we knew some evidence that could direct our search in a more intelligent manner? (FOREBODING!!!)</p>
            </div>
            <hr/>
            
            <br/>
            <div id='propLogic' class='scrollspy-element' scrollspy-title='Propositional Logic'></div>
            <h1>Propositional Logic</h1>
            <div>
              <blockquote class='text-center'>
                <p>&quot;Humans, it seems, know things; and what they know helps them do things.&quot;</p>
                <footer>Our Textbook's Start to Chapter 7</footer>
              </blockquote>
              <br/>
              <p>Some humans really know how to start a textbook chapter!</p>
              <p>What the quote means to express is that human cognition has two important qualities that would be nice to recreate:</p>
              <ul class='indent-1'>
                <li><p>Humans have some sort of <strong>knowledge</strong> representation that spans the breadth of human experience from episodic (event-related) to semantic (factual) memory.</p></li>
                <li><p>Using this knowledge, humans rationalize and perform <strong>inference</strong> from the facts that they know and extrapolate unto the facts that they don't.</p></li>
              </ul>
              <br/>
              <p class='question' name='inf-q0'>For example, if I told you that &quot;If it is raining, then the pavement will be wet. Oh, by the way, it's raining.&quot; What might you infer about the pavement?</p>
              <p class='answer' name='inf-q0'>Hopefully, you infer that the pavement is wet! (and that I'm bad at concisely relaying information)</p>
              <p>This is a small gap that humans bridge very easily using reasoning about what they know and what they can infer from what they know.</p>
              <p>Computers, however, need a lot of help with this task; to start our quest to implement a reasoning engine, we'll talk about some definitions:</p>
              <p class='definition'>An intelligent system's <strong>knowledge base (KB)</strong> consists of a set of logical <strong>sentences</strong> that represent some assertions of the world.</p>
              <p class='definition'>A KB's <strong>sentences</strong> are not English sentences so much as they are logical expressions relating some properties of the environment.</p>
              <br/>
              <p>In <strong>Propositional Logic</strong>, a KB's sentences are combinations of boolean variables that express our knowledge about the world.</p>
              <p>So pictorially, our task will be to design an inference engine that takes what we know, questions about what we know, and produce an answer:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/spring-2014/cs-161/week-4/propLog-0.PNG' />
              </div>
              <br/>
              <p>Above, we say that the items that we start off with in our KB are axioms, and the facts that we derived from them are inferred.</p>
              <p class='definition'><strong>Axioms</strong> are the &quot;given&quot; elements of the KB that we assume are true before reasoning; they represent our background knowledge.</p>
              <p class='definition'><strong>Inferred</strong> terms are derived from those initial axioms to extend our knowledge base and answer queries.</p>
              <br/>
              <p class='question' name='propLog-q0'>What are the axioms and derived terms from our example above about whether the sidwalk is wet when it's raining?</p>
              <p class='answer' name='propLog-q0'>
                The axioms are that: (1) If it is raining, then the sidwalk will be wet and (2) it is raining. There is a single derived term: (3) The side walk is wet.
              </p>
              <br/>
              <p>So, we begin to see how to fit the pieces together for our inference engine, but we need a formalization.</p>
              
              <br/>
              <h3>Propositional Syntax</h3>
              <p class='definition'>In propositional logic, we'll represent our knowledge with Boolean variables called <strong>propositions</strong>, i.e., variables that can either be true or false.</p>
<pre class='prettyprint'>
  Boolean variable examples:
  
  Let S = whether or not my socks are matching today
      H = whether or not it is over 80 degrees out today
      R = whether or not it is raining
      W = whether or not the sidewalk is wet
</pre>
              <br/>
              <p>Thus, every proposition can attain either the value True or False, or T and F as you'll often see them displayed.</p>
              <p>Now, we can build logical sentences comprised of our propositions and logical connectives.</p>
              <p class='definition'>A <strong>logical operator</strong> simply defines some relationship between some number of propositions.</p>
              <div class='definition'><p>Our knowledge representation is therefore composed of:</p>
                <ul class='indent-1'>
                  <li><p><strong>Atoms:</strong> T, F, Prop, &not;Prop, where Prop is some propositional variable.</p></li>
                  <li><p><strong>Sentences:</strong> atoms or atoms used with logical operators: &not;, &or;, &and;, &rArr;</p></li>
                </ul>
              </div>
              <br/>
              <p>Logical operators are defined as follows:</p>
              <p class='toolkit'><strong>Negation (&not;)</strong> is a unary logical operator that flips the Boolean value of a sentence from T to F or from F to T.</p>
<pre class='prettyprint'>
  ; Definition:
  &not;(sentence)
  
  ; Examples:
  &not;T = F
  &not;F = T
  
  ; If Prop = T, then:
  &not;Prop = F
</pre>
              <br/>
              <p class='toolkit'><strong>DeMorgan's Law</strong> (although not strictly a logical operator) is an important aspect of negating non-atom sentences (defined below).</p>
<pre class='prettyprint'>
  ; Definition:
  &not;(prop1 &and; prop2) = (&not;prop1) &or; (&not;prop2)
  &not;(prop1 &or; prop2) = (&not;prop1) &and; (&not;prop2)
  
  ; Examples:
  &not;(T &and; F)
    = (&not;T) &or; (&not;F)
    = (F) &or; (T)
    = T
</pre>
              <br/>
              <p class='toolkit'><strong>Conjunction (&and;)</strong> AKA &quot;and&quot; is a binary operator that returns T only if the sentence on its left AND right are T.</p>
<pre class='prettyprint'>
  ; Definition:
  (sentence1) &and; (sentence2)
  
  ; Examples:
  T &and; F = F
  T &and; T = T
  (T &and; F) &and; T = F
  Prop1 &and; Prop2 &and; Prop3
</pre>
              <br/>
              <p class='toolkit'><strong>Disjunction (&or;)</strong> AKA &quot;or&quot; is a binary operator that returns T if at least one of the sentences on its left OR right is T.</p>
<pre class='prettyprint'>
  ; Definition:
  (sentence1) &or; (sentence2)
  
  ; Examples:
  T &or; F = T
  T &or; T = T
  (T &or; F) &or; F = T
  F &or; F = F
  Prop1 &or; Prop2 &or; Prop3
</pre>
              <br/>
              <p class='toolkit'><strong>Implication (&rArr;)</strong> is a logical shorthand indicating an if-then relationship between sentences.</p>
<pre class='prettyprint'>
  ; Definition:
  (sentence1) &rArr; (sentence2)
  ; ...is shorthand for:
  &not;(sentence1) &or; (sentence2)
  
  ; Examples:
  F &rArr; F
    = &not;F &or; F
    = T &or; F
    = T
</pre>
              <br/>
              <p class='toolkit'><strong>If-and-only-if (&hArr;)</strong> is a logical shorthand indicating if-then relationships of the format: (if A then B) AND (if B then A).</p>
<pre class='prettyprint'>
  ; Definition:
  (sentence1) &hArr; (sentence2)
  ; ...is shorthand for:
  ((sentence1) &rArr; (sentence2)) &and; ((sentence2) &rArr; (sentence1))
</pre>
              <br/>
              <p>Alright, so now that we have the tools at our disposal, we can talk about the semantics of propositional logic.</p>
              
              <br/>
              <h3>Propositional Semantics</h3>
              <p>Since we're dealing with propositions, which are Boolean variables, then we can imagine our variables describing a scenario by being instantiated to either T or F.</p>
              <p>Let's say we returned to the example of rain and the sidewalk. I'll define two propositions:</p>
<pre class='prettyprint'>
  Let R = whether or not it is raining
      S = whether or not the sidewalk is wet
</pre>
              <br/>
              <p>The fact that I have two propositional variables of interest means that I have 4 possible worlds consisting of:</p>
              <table class='table table-striped table-bordered'>
                <thead>
                  <tr>
                    <th><p>R</p></th>
                    <th><p>S</p></th>
                    <th><p>Interpretation of (R &and; S)</p></th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><p>F</p></td>
                    <td><p>F</p></td>
                    <td><p>It isn't raining and the sidewalk isn't wet</p></td>
                  </tr>
                  <tr>
                    <td><p>F</p></td>
                    <td><p>T</p></td>
                    <td><p>It isn't raining but the sidewalk IS wet</p></td>
                  </tr>
                  <tr>
                    <td><p>T</p></td>
                    <td><p>F</p></td>
                    <td><p>It IS raining, but the sidewalk isn't wet</p></td>
                  </tr>
                  <tr>
                    <td><p>T</p></td>
                    <td><p>T</p></td>
                    <td><p>It IS raining, and the sidewalk IS wet</p></td>
                  </tr>
                </tbody>
              </table>
              
              <br/>
              <p class='question' name='propLog-q00'>In general, then, if I have N propositional variables, how many possible worlds will I have?</p>
              <p class='answer' name='propLog-q00'>
                2^N, since every additional variable creates 2 new worlds for all worlds in the truth table with (N - 1) variables
              </p>
              <br/>
              <p>Now, let's say I observed some facts about my environment and also knew some background knowledge that are relevant to my observations.</p>
              <p class='example'>Convert the following English sentences into propositional logic sentences:</p>
<pre class='prettyprint'>
  Let R = whether or not it is raining
      S = whether or not the sidewalk is wet
      
  ;; #1
  &quot;If it is raining, then the sidewalk will be wet.&quot;
  
  ;; #2
  &quot;It is raining.&quot;
  
  ;; #3
  &quot;It is NOT raining.&quot;
</pre>
              
              <br/>
              <p>OK, so let's say that I observe the following: &quot;If it is raining, then the sidewalk will be wet. It is raining.&quot;</p>
              <p class='question' name='propLog-q1'>How can I phrase this observation as a conjunctive sentence?</p>
              <p class='answer' name='propLog-q1'>
                (R &rArr; S) &and; R<br/>
                = (&not;R &or; S) &and; R
              </p>
              <br/>
              <p>Knowing these facts about my environment, and also the set of all 4 possible worlds over instantiation combinations of R and S, I can ask if a world is consistent with my observations.</p>
              <p class='definition'>
                Formally, we say that for some logical sentence &alpha;, a world is a <strong>model</strong> of that sentence if &alpha; is true given the instantiations of variables in that world.
              </p>
              <p class='toolkit'>We use the notation M(&alpha;) to indicate the set of all models of &alpha;; this is referred to as the <strong>meaning</strong> of &alpha;</p>
              <br/>
              <p>So, for our example, if &alpha; = (&not;R &or; S) &and; R = &quot;If it is raining, then the sidewalk will be wet. It is raining.&quot;</p>
              <p>...then M(&alpha;) = the set of all worlds consistent with (&not;R &or; S) &and; R</p>
              <p>Let's look again at our truth table:</p>
              <table class='table table-striped table-bordered'>
                <thead>
                  <tr>
                    <th><p>World</p></th>
                    <th><p>R</p></th>
                    <th><p>S</p></th>
                    <th><p>&alpha; = (&not;R &or; S) &and; R</p></th>
                    <th><p>Model of &alpha;?</p></th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><p>W1</p></td>
                    <td><p>F</p></td>
                    <td><p>F</p></td>
                    <td><p>(&not;F &or; F) &and; F = F</p></td>
                    <td><p>No</p></td>
                  </tr>
                  <tr>
                    <td><p>W2</p></td>
                    <td><p>F</p></td>
                    <td><p>T</p></td>
                    <td><p>(&not;F &or; T) &and; F = F</p></td>
                    <td><p>No</p></td>
                  </tr>
                  <tr>
                    <td><p>W3</p></td>
                    <td><p>T</p></td>
                    <td><p>F</p></td>
                    <td><p>(&not;T &or; F) &and; T = F</p></td>
                    <td><p>No</p></td>
                  </tr>
                  <tr>
                    <td><p>W4</p></td>
                    <td><p>T</p></td>
                    <td><p>T</p></td>
                    <td><p>(&not;T &or; T) &and; T = T</p></td>
                    <td><p>Yes!</p></td>
                  </tr>
                </tbody>
              </table>
              <br/>
              <p>So, since W4 is the only model of our sentence &alpha;, then we say M(&alpha;) = { W4 }</p>
              <p>We can derive a few interesting set properties of models based on some atoms and sentence formats:</p>
              <p>First, some notational specifications:</p>
              <ul class='indent-1'>
                <li><p><strong>W</strong> (uppercase, bolded) is the set of all worlds.</p></li>
                <li><p>w (lowercase, unbolded) is one world in <strong>W</strong>.</p></li>
                <li><p>The notation w.Prop for some given propositional variable Prop is the instantiation of Prop in world w.</p></li>
              </ul>
              <br/>
              <p>For atoms, we have the following properties:</p>
              <ul class='indent-1'>
                <li><p>M(True) = <strong>W</strong></p></li>
                <li><p>M(False) = &empty;</p></li>
                <li><p>M(Prop) = { w &sube; <strong>W</strong> | w.Prop = T }<br/>&quot;The set of all worlds in W such that each world w in the set has instantiation Prop = T&quot;</p></li>
                <li><p>M(&not;Prop) = { w &sube; <strong>W</strong> | w.Prop = F }<br/>&quot;The set of all worlds in W such that each world w in the set has instantiation Prop = F&quot;</p></li>
              </ul>
              <br/>
              <p>For sentences, we have the following properties:</p>
              <ul class='indent-1'>
                <li><p><strong>Intersection:</strong> M(&alpha; &and; &beta;) = M(&alpha;) &cap; M(&beta;)</p></li>
                <li><p><strong>Union:</strong> M(&alpha; &or; &beta;) = M(&alpha;) &cup; M(&beta;)</p></li>
                <li><p><strong>Subtraction:</strong> M(&not;&alpha;) = <strong>W</strong> \ M(&alpha;)</p></li>
              </ul>
              
              <br/>
              <p>There a couple of accompanying definitions with propositional models where we interpret M(&alpha;) as the *meaning* of &alpha;</p>
              <p class='definition'>If M(&alpha;) = <strong>W</strong>, then we say that &alpha; is <strong>valid</strong>.</p>
              <p class='example'>Are the following sentences over worlds for variables S and R valid? If not, give an instantiation that is inconsistent with &alpha;</p>
<pre class='prettyprint'>
  ;; #1
  &alpha; = S &or; &not;S
  
  ;; #2
  &alpha; = S &and; &not;S
  
  ;; #3
  &alpha; = S &or; (&not;S &and; R)
</pre>
              <br/>
              <p class='definition'>If M(&alpha;) = &empty;, then we say that &alpha; is <strong>inconsistent</strong>.</p>
              <p class='example'>Are the following sentences over worlds for variables S and R inconsistent? If not, give an instantiation that is consistent with &alpha;</p>
<pre class='prettyprint'>
  ;; #1
  &alpha; = S &or; &not;S
  
  ;; #2
  &alpha; = S &and; &not;S
  
  ;; #3
  &alpha; = S &or; (&not;S &and; R)
</pre>
              <br/>
              <p class='definition'>If M(&alpha;) &ne; &empty;, then we say that &alpha; is <strong>consistent</strong>.</p>
              <p class='example'>Are the following sentences over worlds for variables S and R consistent?</p>
<pre class='prettyprint'>
  ;; #1
  &alpha; = S &or; &not;S
  
  ;; #2
  &alpha; = S &and; &not;S
  
  ;; #3
  &alpha; = S &or; (&not;S &and; R)
</pre>
              <br/>
              <p>We also have some sentence properties over pairs of sentences &alpha; and &beta;:</p>
              <p class='definition'>If M(&alpha;) &sube; M(&beta;), then we say that &alpha; <strong>entails</strong> &beta;, written &alpha; &#8872; &beta;.</p>
              <br/>
              <p>
                Another way of thinking about this is that all of the worlds consistent with &alpha; are also consistent with &beta; such that we know whenever some world w &#8872; &alpha;, then
                that same world w &#8872; &beta;.
              </p>
              <p>That said, we are NOT guaranteed that every world consistent with &beta; is consistent with &alpha;</p>
              <p class='example'>Does &alpha; entail &beta; in the following examples? If not, provide a world where &alpha; is consistent but &beta; isn't.</p>
<pre class='prettyprint'>
  ;; #1
  &alpha; = S
  &beta; = R
  
  ;; #2
  &alpha; = &not;R &and; (S &or; R)
  &beta; = S
</pre>
              <br/>
              <p class='definition'>If M(&alpha;) &sube; M(&beta;) AND M(&beta;) &sube; M(&alpha;), then we say that &alpha; and &beta; are <strong>equivalent</strong></p>
              <br/>
              <p>
                Another way of thinking about this is that all of the worlds consistent with &alpha; are also consistent with &beta; AND all worlds consistent with &beta; are also consistent with
                &alpha;
              </p>
              <p class='example'>Is &alpha; = &beta; in the following sentences?</p>
<pre class='prettyprint'>
  ;; #1
  &alpha; = S
  &beta; = R
  
  ;; #2
  &alpha; = &not;R &and; (S &or; R)
  &beta; = S
  
  ;; #3
  &alpha; = &not;R &and; (S &or; R)
  &beta; = &not;R &and; S
</pre>
              
              <br/>
              <h3>Formalizing the Knowledge Base</h3>
              <p>OK, so we've got our propositional logic syntax and semantics down... let's apply them to an intelligent reasoning system!</p>
              <p>Our quest begins by defining a knowledge base:</p>
              <p class='definition'>A <strong>propositional knowledge base (KB)</strong> is a conjunction of sentences that entails a set of possible worlds.</p>
              <br/>
              <p>In other words, if M(KB) = <strong>W'</strong>, then <strong>W'</strong> &sube; <strong>W</strong></p>
              <p>To illustrate this, let's expand on our previous example to include a new variable, L = &quot;The light from the sun is shining.&quot;</p>
              <p class='example'>Convert the sentences about variables S, L, and R into propositional sentences, and then form the KB:</p>
<pre class='prettyprint'>
  Let R = whether or not it is raining
      S = whether or not the sidewalk is wet
      L = whether or not the sunlight is shining
      
  ;; #1
  sent1 = &quot;If the sunlight is shining, then it is not raining.&quot;
  
  ;; #2
  sent2 = &quot;If it is not raining, then the sidewalk is dry.&quot;
  
  ;; #3
  sent3 = &quot;The sunlight is shining.&quot;
  
  ;; #4:
  KB = The conjunction of all of our sentences
     = sent1 &and; sent2 &and; sent3
</pre>
              
              <br/>
              <h3>Inference Rules</h3>
              <p>Think about what &quot;inference&quot; means... that is, what it means when you infer something?</p>
              <p>It means you take the information you know, and then make an assertion based on that information to what you haven't observed.</p>
              <p>In the context of a knowledge base, inference rules define semantics to take the sentences of a KB and then return a NEW sentence that is entailed by the KB!</p>
              <p>The first inference rule is called Modus Ponens:</p>
              <div class='definition'><p><strong>Modus Ponens</strong> is an inference rule defined as:</p>
                <div class='row'>
                  <div class='col-md-2 text-center'>
                    <h3>&alpha; &#8872; &beta;; &alpha;</h3>
                    <hr>
                    <h3>&beta;</h3>
                  </div>
                </div>
              </div>
              <br/>
              <p>Frankly, I find this syntactic definition to be one of the worst known to man; let's unpack it:</p>
              <p>Modus Ponens says, &quot;If &alpha; entails &beta; in my KB, and I also have &alpha; somewhere in my KB (by itself), then I'm allowed to add &beta; (by itself) to the knowledge base.&quot;</p>
              <p>Another, more friendly formulation is that if you ever have two sentence structures in your KB: (sent1 &rArr; sent2) &and; sent1, then you can add sent3 = sent2</p>
              <p>So, for example, if I have the following sentences, sent1 and sent2 in my KB, I can use modus ponens to infer sent3:</p>
<pre class='prettyprint'>
  ;; Assume sent1 and sent2 are in KB
  
  ;; #1
  sent1 = (R &rArr; S)
  sent2 = R
  
  ; Since, in our definition for Modus Ponens,
  ; &alpha; = R and &beta; = S, then I can infer:
  sent3 = S
  
  
  ;; #2
  sent1 = X
  sent2 = (Y &or; &not;X)
  
  sent3 = ???
</pre>
              <br/>
              <p>The second inference rule is called Resolution:</p>
              <div class='definition'><p><strong>Resolution</strong> is an inference rule defined as:</p>
                <p>For any two sentences X and Y in our KB with propositions x_i and y_i of the format: X = x1 &or; x2 &or; ... &or; xn; Y = y1 &or; y2 &or; ... &or; yn</p>
                <p>If X and Y contain some propositional variable Z such that Z &isin; X AND &not;Z &isin; Y, then we can combine the two sentences on everything except the disagreement on Z such that:</p>
                <div class='row'>
                  <div class='col-md-10 text-center'>
                    <h3>x1 &or; x2 &or; Z &or; ... &or; xn;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y1 &or; y2 &or; &not;Z &or; ... &or; yn</h3>
                    <hr>
                    <h3>x1 &or; x2 &or; ... &or; xn &or; y1 &or; y2 &or; ... &or; yn</h3>
                  </div>
                </div>
                <p>In other words, we're allowed to infer the sentence composed of all disjoined propositions of X and Y *except* for element Z.</p>
              </div>
              <br/>
              <p>Given sentences sent1 and sent2 in my KB, I can use resolution to infer sent3:</p>
<pre class='prettyprint'>
  ;; Assume sent1 and sent2 are in KB
  
  ;; #1
  sent1 = (X &or; Y &or; &not;Z)
  sent2 = (M &or; N &or; Z)
  
  ; Since sent1 and sent2 disagree on proposition Z
  ; we can resolve the two into the third sentence:
  sent3 = (X &or; Y &or; M &or; N)
  
  ;; #2
  sent1 = (X &or; Y &or; &not;Z)
  sent2 = Z
  sent3 = (X &or; Y)
  
  ;; #3
  sent1 = ((X &rArr; Y) &or; Z)
  sent2 = (&not;X &rArr; Y)
  sent3 = ???
</pre>
              <br/>
              <p>There are a couple things to note about resolution:</p>
              <p class='definition'>Resolution expects our sentences to be in the form of <strong>clauses</strong>, which are sentences composed only of disjunction between propositions.</p>
              <p class='example'>Are the following sentences clauses? Can they be converted to clauses?</p>
<pre class='prettyprint'>
  ;; #1
  (X &or; Y &or; Z)
  
  ;; #2
  (X &and; Y &or; Z)
  
  ;; #3
  ((X &and; Y) &rArr; Z)
</pre>
              <br/>
              <p>Because we want to reason using resolution (which we've just seen operates on cluases), it would be nice to have our knowledge base in a format that consisted ONLY of clauses!</p>
              <p class='definition'><strong>Conjunctive Normal Form (CNF)</strong> is a sentence format consisting solely of a conjunction of clauses. This is the format we'd like to have our KB in!</p>
              <p class='example'>Are the following sentences in CNF?</p>
<pre class='prettyprint'>
  ;; #1
  (X &or; Y) &and; (Z &or; X) &and; (&not;W &or; D)
  
  ;; #2
  (X &rArr; Y) &and; (Z &rArr; X)
  
  ;; #3
  &not;(X &and; Y) &or; Z
</pre>
              <br/>
              <p class='toolkit'>Fortunately, we can convert any arbitrary knowledge base in CNF; the procedure on page 253 of the textbook describes this.</p>
              <br/>
              <p>Because of the assumption that our KB is in CNF, we often simply list a KB's sentences like:</p>
<pre class='prettyprint'>
  KB = (X &or; Y &or; Z) &and; (W &or; M) &and; (&not;X &or; W)
  
  ; Notationally represented as:
  KB =
     1. (X &or; Y &or; Z)
     2. (W &or; M)
     3. (&not;X &or; W)
</pre>
              <br/>
              <h3>Inference Using Refutation</h3>
              <p>OK, now that we have our knowledge base, the goal of the system is to prove certain facts about what we know.</p>
              <p>We'll do this by illustrating that for some query sentence &alpha;, we will determine whether or not our KB &#8872; &alpha;</p>
              <p>However, since it is difficult to show that, for all worlds a KB satisfies, &alpha; is also satisfied, we'll use a clever trick:</p>
              <p class='definition'>
                <strong>Refutation</strong> AKA proof by contradiction, is an inference strategy whereby for query sentence &alpha;, we say KB &#8872; &alpha; IFF M(KB &and; &not;&alpha;) = &empty;
              </p>
              <br/>
              <p>&quot;Ugh... maths...&quot; you might remark.</p>
              <p>But it's really quite intuitive! Let's translate refutation inference into English:</p>
              <p class='toolkit'>
                Refutation says, &quot;Add the *opposite* of my query to the Knowledge Base, and if it makes the KB inconsistent, then I know my query had to have been entailed in the first place!&quot;
              </p>
              <p class='example'>Are the following KB's inconsistent?</p>
<pre class='prettyprint'>
  ;; #1
  KB =
     1. &not;A
     2. (A &or; B)
     3. A
     
  ;; #2
  KB =
     1. &not;A
     2. (A &or; B)
     3. &not;B
</pre>
              <br/>
              <p>Let's try a simple example with our previous raining and sidwalk-wetness stuff:</p>
<pre class='prettyprint'>
  Let R = whether or not it is raining
      S = whether or not the sidewalk is wet
      L = whether or not the sunlight is shining
  
  KB =
     ; The sidewalk is wet IFF it is raining
     1. (R &rArr; S)
     2. (S &rArr; R)
     
     ; If the sun is shining, then it is not raining
     3. (L &rArr; &not;R)
      = (&not;L &or; &not;R)
     
     ; The sun is shining
     4. L
     
  ; ---------------------------------------------------
  ; KB sentences 1 - 4 represent our axioms.
  ; Now, let us ask our query: Is the sidewalk dry?
  ; &alpha; = &not;S
  ; Therefore, we add &not;&alpha; = S to our KB:
  
     5. S
  
  ; ---------------------------------------------------
  ; Now we use resolution to see if a contradiction
  ; exists in our KB! If it does, then KB &#8872; &alpha;
  
     6. R [Modus Ponens: #2 and #5]
     7. &not;L [Resolution: #3 and #6]
     8. &empty; [Resolution: #4 and #7]
     
  &rarr; &larr; Contradiction: We had both L and &not;L in
      the KB, which derived &empty;
     
  &there4; KB &#8872; &alpha;
</pre>
              <br/>
              <p>So, since we reached a contradiction, we conclude that KB &#8872; &alpha; since we added &not;&alpha; and made it inconsistent.</p>
              <p class='debug'>Note: We can make this assumption BECAUSE we assume the KB is consistent to begin with.</p>
              <br/>
              <p>That said... what does it mean if we fail to reach a contradiction using resolution and we've exhausted all of our resolution possibilities in the KB?</p>
              <p>Well, we know nothing! We can't conclude that our KB *doesn't* entail &alpha;, we just know that resolution didn't find the answer.</p>
              <p class='definition'>
                For this reason, we say that resolution is <strong>refutation complete</strong>, meaning that if a contradiction exists in the KB from addition of our query &not;&alpha;, then
                resolution is guaranteed to find it. 
              </p>
              <br/>
              <p>The other property of resolution is that it is sound:</p>
              <p class='definition'>
                <strong>Soundness</strong> is a resolution strategy property meaning that only entailed sentences are ever derived during use of that algorithm; i.e., no sentences are ever made up.
              </p>
              <br/>
              <p>We don't want our reasoning system just making things up!</p>
              <p>So that's resolution in a nutshell!</p>
              
              <br/>
              <h3>Other Sentence Formats</h3>
              <p>As an appendix to this section, I wanted to mention two special logical sentence formats that have special meaning for inference:</p>
              <p class='definition'>A <strong>positive literal</strong> is any non-negated proposition in a sentence.</p>
              <p class='definition'><strong>Horn Clauses</strong> are still clauses (disjunction of propositions) that have the additional constraint of allowing *at most* one positive literal.</p>
              <p class='example'>Which of the following are Horn clauses?</p>
<pre class='prettyprint'>
  ;; #1
  (&not;X &or; Y &or; &not;Z)
  
  ;; #2
  (X &rArr; Y)
  
  ;; #3
  (&not;X)
  
  ;; #4
  (X &or; Y &or; Z)
</pre>
              <br/>
              <p class='definition'>A <strong>definite clause</strong> has *exactly* one positive literal.</p>
              <p class='example'>Which of the following are definite clauses?</p>
<pre class='prettyprint'>
  ;; #1
  (&not;X &or; Y &or; &not;Z)
  
  ;; #2
  (X &rArr; Y)
  
  ;; #3
  (&not;X)
  
  ;; #4
  (X &or; Y &or; Z)
</pre>
              <br/>
              <p>The significance of these forms are discussed on page 256 of the book and can be used for efficient inference algorithms.</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='homework2' class='scrollspy-element' scrollspy-title='Homework 2'></div>
            <h1>Homework 2</h1>
            <div>
              <p>We'll save the last 5 - 10 minutes of discussion going over HW2 here!</p>
              <p>Any time left will be devoted to practice, below.</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='midterm' class='scrollspy-element' scrollspy-title='Midterm'></div>
            <h1>Midterm</h1>
            <div>
              <p>Your midterm is next week! Commence panic!</p>
              <p>A couple of notes:</p>
              <ul class='indent-1'>
                <li><p>No, I don't know what's going to be on it -- you should certainly read your book!</p></li>
                <li><p>That said, I have some *best guesses* for what is likely about 80% of the material. I've given you some relevant practice problems in my 
                  <a href='/~forns/classes/winter-2016/cs-161/midterm-practice.html'>practice midterm located here</a>!</p></li>
                <li><p>In the event that First Order Logic is on the exam (which will be the topic of next week's discussion), I'll uploaded my lecture notes for it in advance of the exam.</p></li>
              </ul>
            </div>
            <hr/>
            
            
            <br/>
            <div id='practice' class='scrollspy-element' scrollspy-title='Practice'></div>
            <h1>Practice</h1>
            <div>
              <p>Let's try out some of the propositional logic stuff we learned today!</p>
              <br/>
              <p class='example'>For variables P and Q, show, using truth tables, that the following sentences are equivalent:</p>
<pre class='prettyprint'>
  P &rArr; &not;Q
  Q &rArr; &not;P
</pre>
              <br/>
              <p class='example'>Use Boolean logic properties to convert the following sentence into CNF:</p>
<pre class='prettyprint'>
  ;; #1
  &not;(X &or; Y) &and; Z
  
  ;; #2
  (X &and; Y) &rArr; Z
  
  ;; #3
  (X &or; Y) &rArr; Z
</pre>
              <br/>
              <p class='example'>Perform resolution on the following KB to answer the question as to whether KB &#8872; &alpha;</p>
<pre class='prettyprint'>
  &alpha; = &not;X &and; Y
  &not;&alpha; = X &or; &not;Y
  
  KB =
     1. X &or; Z &or; Y
     2. &not;Z &or; W &or; X
     3. &not;X &or; W
     4. &not;W
</pre>
            </div>
            <hr/>
            
            <a class='btn btn-default pull-right hidden-print' href='javascript:window.print();'>
              <span class='glyphicon glyphicon-print'></span>
              &nbsp; PDF / Print
            </a>
            
          </div>
          <!-- END PRESENTATION CONTENT -->
          
          <!-- MATERIALS FROM CLASS: -->
          
        </div>
      </div>
      <!-- END MAIN CONTENT -->
      
      
    </div>
    <!-- END WRAPPER -->
    
    <!-- BEGIN FOOTER -->
    <div id="footer">
      <div class="container">
        <div class="col-md-12 text-center">
          
        </div>
      </div>
    </div>
    <!-- END FOOTER -->
    
  </body>
</html>
