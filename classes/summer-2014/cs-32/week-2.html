
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <title>Andrew Forney - UCLA CS</title>
    <link href="../../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../../../css/magic-bootstrap.css" rel="stylesheet" type="text/css">
    <link href="../../../css/main.css" rel="stylesheet" type="text/css">
    <script src="../../../js/lib/jquery-2.0.3.min.js"></script>
    <script src="../../../js/lib/bootstrap.min.js"></script>
    <script src="../../../js/lib/expanding.js"></script>
    <script src="../../../js/display/general/general-display.js"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
  </head>
  
  <body data-spy="scroll" data-target="#scrollspy">
    
    <!-- BEGIN WRAP -->
    <div id="wrap">
      
      <!-- BEGIN NAVIGATION -->
      <nav class='navbar navbar-default' role='navigation'>
        <div class='nav-accent'></div>
        <div class='container'>
          <div class='row'>
            <div class='col-md-12'>
              <div class='navbar-header'>
                <button class='navbar-toggle' type='button' data-toggle='collapse' data-target='.navbar-main-collapse'>
                  <span class='sr-only'>Toggle Navigation</span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                </button>
                <a class='navbar-brand' href='/~forns/'>
                  <span id='brand-text'>
                    Andrew Forney
                  </span>
                </a>
              </div>
              
              <div id='nav-main' class='collapse navbar-collapse navbar-main-collapse'>
                <ul class='nav navbar-nav navbar-right'>
                  
                  <li>
                    <a href='/~forns/about.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-user'></span>
                      </div>
                      <p class='text-center'>About</p>
                    </a>
                  </li>
                  
                  <li class='active'>
                    <a href='/~forns/classes.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-book'></span>
                      </div>
                      <p class='text-center'>Classes</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/contact.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-comment'></span>
                      </div>
                      <p class='text-center'>Contact</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/publications.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-file'></span>
                      </div>
                      <p class='text-center'>Publications</p>
                    </a>
                  </li>
                  
                </ul>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <!-- END NAVIGATION -->
      
      <!-- BEGIN MAIN CONTENT -->
      <div id="main-content" class="container">
        <div class="row">
          
          <!-- BEGIN SCROLLSPY -->
          <div class='col-md-2 hidden-sm hidden-xs'>
            <div class="bs-sidebar hidden-print affix" role="complementary">
              <ul id='scrollspy' class="nav bs-sidenav">
              </ul>
            </div>
          </div>
          <!-- END SCROLLSPY -->
          
          <!-- BEGIN PRESENTATION CONTENT -->
          <div class='col-md-10 presentation-content' role='main'>
            
            <ol class="breadcrumb hidden-print">
              <li><a href="../../../classes.html">Classes</a></li>
              <li><a href="./cs-32.html">Summer14 CS32</a></li>
              <li class="active">Week 2</li>
            </ol>
            
            <div id='functionTrickz' class='scrollspy-element' scrollspy-title='Function Stuff'></div>
            <h1>A Few Notes on Functions</h1>
            <div>
              <p>I didn't know where else to put this section, so why not here?</p>
              <p>Say I had a function with which I wanted to give the user some parameter flexibility.</p>
              <p>If my function could take in 3 arguments, but I only *needed* the user to specify 2 of those, I could use default parameter values:</p>
              <p class='definition'><strong>Default parameters</strong> specify the value for a function parameter if it is not included as an argument from the user's function call.</p>
              <p>Take a look:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
  
  // hippyFunc will like... take whatever arguments
  // you want to give, man
  double hippyFunc (int i, double d = 1.0, string s = "cool man") {
      for (int n = 0; n &lt; i; n++) {
          cout &lt;&lt; s &lt;&lt; endl;
      }
      return i * d;
  }
  
  int main () {
      // Not specifying d or s parameters
      cout &lt;&lt; hippyFunc(1) &lt;&lt; endl;
      // Not specifying s parameter
      cout &lt;&lt; hippyFunc(1, 2.3) &lt;&lt; endl;
      // Specifying all parameters
      cout &lt;&lt; hippyFunc(2, 4.5, "GET A JOB!") &lt;&lt; endl;
  }
</pre>
              <p>Yeah, that's about the quality of examples you can expect from this set of notes... it's been a long week.</p>
              <p>Warning! Once you decide that, say, parameter #2 (in the parameter list of a function) can have a default value, all parameters following it must also have a default value.</p>
              <p class='debug'>Will the following code compile?</p>
<pre class='prettyprint'>
  double hippyFunc (int i, double d = 1.0, string s) {
      for (int n = 0; n &lt; i; n++) {
          cout &lt;&lt; s &lt;&lt; endl;
      }
      return i * d;
  }
</pre>
              <p>Notice how the parameter s followed a parameter with a default value while lacking one of its own.</p>
              <p>Any who, why might this be useful?</p>
              <ul class='indent-1'>
                <li><p>We can give users of our functions some flexibility with the function interface, especially when some values can be specified that aren't usually cared about.</p></li>
                <li><p>We can specify logical default values for class object constructors that reduce the amount of code we have to write.</p></li>
              </ul>
              <p>Here's an example for condensing two constructors using parameter defaults:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
  
  class LazyConstructors {
      private:
          int i;
          string s;
      public:
          // One default constructor...
          LazyConstructors () {
              i = 0;
          }
          
          // Another taking two parameters
          LazyConstructors (int j, string t) {
              i = j;
              s = t;
          }
  
          // ...
  
          // Getters
          int getI () {return i;}
          string getS () {return s;}
  };
  
  int main () {
      LazyConstructors lame;
      LazyConstructors alsoLame(3, "-_-");
  
      cout &lt;&lt; lame.getI() &lt;&lt; endl;
      cout &lt;&lt; alsoLame.getS() &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>Wow... that example was really boring... let's at least improve it before we forget it ever happened:</p>
<pre class='prettyprint'>
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
  
  class LazyConstructors {
      private:
          int i;
          string s;
      public:
          // Now with fewer constructors!
          LazyConstructors (int j = 0, string t = "") {
              i = j;
              s = t;
          }
  
          // ...
  
          // Getters
          int getI () {return i;}
          string getS () {return s;}
  };
  
  int main () {
      LazyConstructors lame;
      LazyConstructors alsoLame(3, "-_-");
  
      cout &lt;&lt; lame.getI() &lt;&lt; endl;
      cout &lt;&lt; alsoLame.getS() &lt;&lt; endl;
  }
</pre>
              <br/>
              <p>Neat, right? We combined our two constructors into one with the same behavior.</p>
              <p class='question' name='funcs-q0'>There *is* however, one difference between what our second default-parameter constructor allows and the two it replaced. What is it?</p>
              <p class='answer' name='funcs-q0'>
                Our second implementation allows us to construct a LazyConstructors object with just the i parameter defined, which would not similarly work for the first 
                implementation... we won't worry about it in this case, though, because we'll just pretend that our spec didn't care.
              </p>
              <br/>
              <p>One final note for default parameters: where am I meant to specify them? The signatures (typically in header files) or the implementations (typically in .cpp files)?</p>
              <p>Convention says to place the default parameter values in the header files because users who are interested in how functions / classes operate will look there first.</p>
              <p class='debug'>WARNING: Necessity says to NOT put the default parameter values in BOTH the function signature and implementation, as this will cause a compile error.</p>
              <p>For example, with our hippyFunc from earlier:</p>
<pre class='prettyprint'>
  // In a header file somewhere...
  double hippyFunc (int i, double d  = 1.0, string s = "cool man");
  
  // ...
  
  // In a .cpp file somewhere...
  double hippyFunc (int i, double d, string s) {
      for (int n = 0; n &lt; i; n++) {
          cout &lt;&lt; s &lt;&lt; endl;
      }
      return i * d;
  }
</pre>
              <p class='debug'>BUT, *this* will not compile. Why?</p>
<pre class='prettyprint'>
  // In a header file somewhere...
  double hippyFunc (int i, double d = 1.0, string s = "cool man");
  
  // ...
  
  // In a .cpp file somewhere...
  double hippyFunc (int i, double d = 1.0, string s = "cool man") {
      for (int n = 0; n &lt; i; n++) {
          cout &lt;&lt; s &lt;&lt; endl;
      }
      return i * d;
  }
</pre>
            </div>
            <hr/>
            
            
            <br/>
            <div id='delete' class='scrollspy-element' scrollspy-title='Delete Operator'></div>
            <h1>Review of the Delete Operator</h1>
            <div>
              <p>Just a brief note to remind us of what the delete keyword does.</p>
              <p>If you're a bit hazy, I suggest you review my 
                <a href='http://cs.ucla.edu/~forns/classes/fall-2013/cs-31/cs-31-week-10.html#dynamicMem' target='_blank'>notes on dynamic memory from CS 31, located here!</a>
              </p>
              <p>We need to say one more thing that we only touched upon in CS 31:</p>
              <p class='toolkit'>
                Note that we have two forms of the delete operator:<br/><br/>
                <code class='prettyprint'>delete dynamicObject; // used ONLY when dynamicObject was allocated with the new syntax</code><br/>
                <code class='prettyprint'>delete[] dynamicArray; // used ONLY when dynamicArray was allocated with the new[] syntax</code>
              </p>
              <p>In CS 31, we only used the delete keyword but never the delete[] one.</p>
              <p>
                We use the delete keyword whenever the target object of our deletion was a pointer to a *single* object, whereas we use the delete[] keyword whenever the target object was a pointer to 
                a dynamically allocated *array* of objects.
              </p>
              <p>Here's a nice example:</p>
<pre class='prettyprint'>
  int main () {
      int* i = new int(3);
      int* arr = new int[3];
  
      // OK!
      delete i;
      // BAD:
      // delete[] i;
  
      // OK!
      delete[] arr;
      // BAD:
      // delete arr[0];
  }
</pre>
              <p>The first pointer, i, just sticks an int on the heap. The second pointer, arr, allows us to dynamically allocate an array of the size of our choosing (also on the heap).</p>
              <p>We delete them in different ways, though, as you see above.</p>
              <p>I think that's as much of a review as I'd like to go over right now... so onwards!</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='resources' class='scrollspy-element' scrollspy-title='Resource Management'></div>
            <h1>Introduction to Resource Management</h1>
            <div>
              <p>
                As you might have already seen in class, one of the interesting aspects of programming is that different problem solutions (although eliciting the same correct behavior), 
                may go about finding the solution in wildly different ways.
              </p>
              <p>The next thing you'll notice is that not all solutions are the same quality!</p>
              <p>What I mean by this is that what one solution takes 2 minutes to solve, another takes 2 days...</p>
              <p>Just because they arrive at the same answer, doesn't mean that one of them wasn't incredibly stupid in doing it.</p>
              <p class='definition'><strong>Resource management</strong> involves the ability to effectively, efficiently, and economically use data structures to accomplish your program's goals.</p>
              <br/>
              <p>That sounded more like a business slogan than a definition, but the idea is that you want to use the right tool for the right job, and then effectively clean up after ourselves.</p>
              <p>So, let's examine how to engineer the right tools so we won't be sad.</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='LL-basics' class='scrollspy-element' scrollspy-title='Singly Linked Lists'></div>
            <h1>Singly Linked Lists</h1>
            <div>
              <p>Here's what we've said so far about Singly Linked Lists...</p>
              <p class='definition'>They are an abstract data type consisting of Nodes with data elements and a pointer to each successive Node:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-3/linkedLists-0.PNG' />
              </div>
              <br/>
              <p>
                Then, we examined LinkedLists in comparison the Arrays because of their similarities. We concluded that, although they can do (mostly) the same things, Arrays 
                are more efficient than LinkedLists at some things, and vice versa.
              </p>
              <br/>
              
              <h3>Element Insertion</h3>
              <p>We saw that adding elements to the end of an array is easy:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-3/linkedLists-1.PNG' />
              </div>
              <br/>
              <br/>
              <p>But finding the end of a LinkedList actually takes some effort:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-3/linkedLists-2.PNG' />
              </div>
              <br/>
              <p>Now, we stopped the discussion there... that Arrays win at end-of-list insertions...</p>
              <p class='question' name='ll-q0'>Is there a way that we could make LinkedLists comparable to Arrays with end-of-list insertion?</p>
              <p class='answer' name='ll-q0'>Yes! Maintain a pointer within the LinkedList that always points to the last Node. Let's call that the tail.</p>
              <br/>
              <p>Here was our implementation of the LinkedList from last class... why don't we modify it and see how we improve the code?</p>
<pre class='prettyprint'>
  // LinkedList.h
  #ifndef LINKED_LIST_INCLUDED
  #define LINKED_LIST_INCLUDED
  #include &lt;string&gt;
  #include &lt;iostream&gt;
  
  class LinkedList {
      private:
          struct Node {
              std::string m_data;
              Node* m_next;
              Node (std::string s) {
                  m_data = s;
                  m_next = nullptr;
              }
          };
          
          Node* head;
          // [!] Added the tail pointer
          Node* tail;
          int size;
  
      public:
          LinkedList();
          ~LinkedList();
          void insert(std::string);
          bool erase(std::string);
          bool contains(std::string s);
          void print();
  };
  
  #endif
</pre>
              <br/>
<pre class='prettyprint'>
  // LinkedList.cpp
  #include "LinkedList.h"
  
  // Default LinkedList constructor
  LinkedList::LinkedList () {
      head = nullptr;
      tail = nullptr;
      size = 0;
  }
  
  // Destructor
  LinkedList::~LinkedList () {
      // TODO
  }
</pre>
              <br/>
              <p>We then looked at how to implement the insert to end function, and came up with the following:</p>
<pre class='prettyprint'>
  // Insert a new Node at the end of the List
  // with the given string data
  void LinkedList::insert (std::string s) {
      // 1) Dynamically allocate a Node
      Node* toAdd = new Node(s);
    
      // 2) Update the head if first insertion
      if (head == nullptr) {
          head = toAdd;
      } else {
          // 3) Make an iterator to find the last
          // position in the List
          Node* iterator = head;
    
          // 4) Stick the new Node on the end of the List
          while ( iterator-&gt;m_next != nullptr ) {
              iterator = iterator-&gt;m_next;
          }
          iterator-&gt;m_next = toAdd;
      }
  
      // 5) Add one to the size
      size++;
  }
</pre>
              <br/>
              <p class='example'>Modify the code for the insert function so that it uses and maintains the tail pointer:</p>
<pre class='prettyprint'>
  // Insert a new Node at the end of the List
  // with the given string data
  void LinkedList::insert (std::string s) {
      // 1) Dynamically allocate a Node
      Node* toAdd = new Node(s);
    
      // 2) Update the head if first insertion
      if (head == nullptr) {
          head = toAdd;
      }
  
      // 3) Make last node point to toAdd
      // if it exists
      // [!] ???
  
      // 4) Tail now points to toAdd
      // [!] ???
  
      // 5) Add one to the size
      size++;
  }
</pre>
              <br/>
              <h3>Element Deletion</h3>
              <p>As another brief review, we saw that, for Arrays, element deletion is easy when we don't care about sorting the elements:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-3/linkedLists-3.PNG' />
              </div>
              <br/>
              <p>...but is actually a huge pain when we need to delete something toward the front / in the middle of the array:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-3/linkedLists-4.PNG' />
              </div>
              <br/>
              <p>Lastly, we saw that LinkedLists perform admirably at deletion, but the overhead of finding the element to delete costs us efficiency:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-3/linkedLists-5.PNG' />
              </div>
              <p>Let's look at the Singly Linked List delete for a moment...</p>
              <p class='debug'>Some poor soul on an internet forum submitted the following as a solution to a Singly Linked List deletion. Where does it go wrong?</p>
<pre class='prettyprint'>
  bool LinkedList::erase (std::string s) {
      Node* iterator = head;
      Node* prev = nullptr;
      bool erased = false;
  
      // First, find the Node to delete...
      while (iterator != nullptr) {
          // If we don't find a match, keep looking
          if (iterator-&gt;m_data != s) {
              prev = iterator;
              iterator = iterator-&gt;m_next;
              
          // Otherwise, perform the necessary deletion
          } else {
              prev-&gt;m_next = iterator-&gt;m_next;
              delete iterator;
              erased = true;
              break;
          }
      }
      
      // Return whether or not we found
      // and erased anything
      return erased;
  }
</pre>
              
              <br/>
              <h3>Practice &amp; Diagnosis</h3>
              <p>Just to round everything out, let's do a little LinkedList triage and then move on (I totally didn't reuse these from Wednesday &gt;_&gt;):</p>
              <p class='debug'>Noob R. Nooberson thought that the following destructor would work for the LinkedList. Is there a problem with it?</p>
<pre class='prettyprint'>
  // Destructor
  LinkedList::~LinkedList () {
      delete head;
  }
</pre>
              <br/>
              <p class='debug'>
                Then, your illustrious TA suggested it would be cute to solve the above problem by doing the following; why is he a lamo?:
              </p>
<pre class='prettyprint'>
  // ...
  ~Node () {
      delete m_next;
  }
  // ...
</pre>
              <br/>
              <p class='debug'>Lord Voldemort himself produced the following attempt at the LinkedList contains function. Why should he not be named (in respectable programming circles)?</p>
<pre class='prettyprint'>
  bool LinkedList::contains (std::string s) {
      Node* iterator = head;
      while (iterator-&gt;m_data != s &amp;&amp; iterator != nullptr) {
          iterator = iterator-&gt;m_next;
      }
      return iterator != nullptr;
  }
</pre>
              <br/>
              <p>He then tested it on this main function and concluded success:</p>
<pre class='prettyprint'>
  #include "LinkedList.h"
  
  int main () {
      LinkedList listy;
      listy.insert("WHERE");
      listy.insert("IS");
      listy.insert("POTTER");
      std::cout &lt;&lt; listy.contains("POTTER") &lt;&lt; std::endl;
  }
</pre>
            </div>
            <hr/>
            
            
            <br/>
            <div id='LL-stacks' class='scrollspy-element' scrollspy-title='Linked List Stacks'></div>
            <h1>Application of Linked Lists: The Stack</h1>
            <div>
              <p>Heretofore (can you believe that's a word?), we've only seen some abstract uses for LinkedLists and their comparisons to Arrays...</p>
              <p>Let's talk about a real-world data structure that works well with LinkedLists: the stack.</p>
              <p class='definition'>A <strong>stack</strong> is a data structure used to store elements in a way that the most recently stored items are the first to be retrieved.</p>
              <p>...O...K...</p>
              <p>Trust me, it's cool! By analogy, think of a pile of dishes:</p>
              <ul class='indent-1'>
                <li><p>You <em>stack</em> dishes one on top of the other</p></li>
                <li><p>Once you've stacked dish Z on top of all the other dishes, you can only access dish Z (and <em>cannot</em> access any other dish beneath it) until you pop Z off the top again</p></li>
              </ul>
              <p>
                Stacks are very useful; in fact, there's a reason why local variables are stored in <strong>the stack,</strong> because every function's variables get stacked on the top when they're called, 
                and popped off again when you leave the function!
              </p>
              <p>So, let's try to use a LinkedList to represent this data structure:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-3/linkedLists-6.PNG' />
              </div>
              <br/>
              <p class='question' name='stacks-q0'>OK, Andrew, why would we want to make a data structure that's a LinkedList... but more restricted than one?</p>
              <p class='answer' name='stacks-q0'>
                This goes back to our public vs. private interface discussion: we want to give users of our classes certain guaranteed behaviors that allow for predictable code execution. 
                If an algorithm requires that only the most recently pushed Node can be accessed at any time, we need to make sure our users don't tamper with that guaranteed behavior.
              </p>
              <p>Here's my new interface:</p>
<pre class='prettyprint'>
  // Stack.h
  #ifndef STACK_INCLUDED
  #define STACK_INCLUDED
  #include &lt;string&gt;
  #include &lt;iostream&gt;
  
  class Stack {
      private:
          struct Node {
              std::string m_data;
              Node* m_next;
              Node (std::string s) {
                  m_data = s;
                  m_next = nullptr;
              }
          };
  
          Node* head;
          int size;
  
      public:
          Stack();
          ~Stack();
          void push(std::string s);
          std::string pop();
          void print();
  };
  
  #endif
</pre>
              <br/>
              <p>And, of course, a shell for the implementation.</p>
<pre class='prettyprint'>
  // LinkedList.cpp
  #include "Stack.h"
  
  // Default Stack constructor
  Stack::Stack () {
      head = nullptr;
      size = 0;
  }
  
  // Destructor
  Stack::~Stack () {
      // TODO
  }
  
  // Pushes a new Node with data string s
  // to the top of the stack!
  void Stack::push (std::string s) {
      // TODO
  }
  
  // Pops the top Node on the stack off,
  // returning its data member and removing
  // itself from the top (making the one beneath
  // it the new top)
  std::string Stack::pop () {
      // TODO
      return "";
  }
  
  // ... print function same as for LinkedList
</pre>
              <p>Let's fill out the push and pop functions to see it in action:</p>
              <p class='example'>Implement the following shell for the push function:</p>
<pre class='prettyprint'>
  // Pushes a new Node with data string s
  // to the top of the stack!
  void Stack::push (std::string s) {
      // 1) Dynamically allocate a new Node
      Node* toAdd = new Node(s);
  
      // 2) If it's not the first to be added,
      // we need to have it point to the current
      // head
      // [!] Fill in here!
  
      // 3) Whether it's first or not, have the head point
      // to it
      // [!] Fill in here!
  
      // 4) Bump the size
      size++;
  }
</pre>
              <br/>
              <p class='example'>If we test our push with the following main function, what gets printed out?</p>
<pre class='prettyprint'>
  int main () {
      Stack onStacksOnStacks;
      onStacksOnStacks.push("Bill");
      onStacksOnStacks.push("Dolla");
      onStacksOnStacks.push("Dolla");
      onStacksOnStacks.print();
  }
</pre>
              <br/>
              <p class='example'>Implement the following shell for the pop function:</p>
<pre class='prettyprint'>
  // Pops the top Node on the stack off,
  // returning its data member and removing
  // itself from the top (making the one beneath
  // it the new top)
  std::string Stack::pop () {
      // 1) Return the empty string if empty
      if (head == nullptr) {
          return "";
      }
  
      // 2) Set a pointer to the top node
      // [!] Fill in here!
  
      // 3) Save the top Node's data
      std::string result; // [!] Fill in here!
  
      // 4) Adjust head accordingly
      // [!] Fill in here!
  
      // 5) ...take care of the top Node... quietly...
      // [!] Fill in here!
      
      // 6) Reduce size
      size--;
  
      return result;
  }
</pre>
              <p class='example'>If we test our pop with the following main function, what gets printed out?</p>
<pre class='prettyprint'>
  int main () {
      Stack onStacksOnStacks;
      onStacksOnStacks.pop();
      onStacksOnStacks.push("TA");
      onStacksOnStacks.push("great");
      onStacksOnStacks.pop();
      onStacksOnStacks.push("is a");
      onStacksOnStacks.push("Andrew");
      onStacksOnStacks.push("Great...");
      onStacksOnStacks.print();
  }
</pre>
              <br/>
              <p>-_______________-</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='double-LL' class='scrollspy-element' scrollspy-title='Doubly Linked Lists'></div>
            <h1>Doubly Linked Lists</h1>
            <div>
              <p>Wake up your neighbors folks, let's talk Doubly Linked Lists.</p>
              <p class='definition'>
                A <strong>doubly linked list</strong> is just like a regular linked list, except each Node has a pointer to the previous Node in the sequence along with a pointer to the next Node.
              </p>
              <br/>
              <p>What's this look like you ask?</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-3/linkedLists-7.PNG' />
              </div>
              <p>&quot;I like the new arrows, Andrew... what good do they do?&quot;</p>
              <p>
                Excellent question. Whereas previously, in the Singly Linked List, we had only forward arrows, if we ever wanted information about a Node behind us in the sequence, we had to start 
                all over at the beginning... now we don't!
              </p>
              <p>I'm sure the 1 or 2 cases in which these new arrows save us headaches will more than make up for their upkeep...</p>
              <br/>
              <p>Should we start at the start? Check out pushing elements to the end?</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-3/linkedLists-8.PNG' />
              </div>
              <br/>
              <p>Alright... so we've been dealing with Nodes this whole time, but you know what?</p>
              <p>I'm bored with Nodes... let's use a more pop-culture-friendly class and implementation.</p>
              <br/>
<pre class='prettyprint'>
  // HumanCentipede.h
  #ifndef HC_INCLUDED
  #define HC_INCLUDED
  #include &lt;string&gt;
  #include &lt;iostream&gt;
  
  class HumanCentipede {
      private:
          struct Person {
              std::string m_data;
              Person* m_front;
              Person* m_behind;
              Person (std::string s) {
                  m_data = s;
                  m_front = nullptr;
                  m_behind = nullptr;
              }
          };
  
          Person* head;
          Person* tail;
          int size;
  
      public:
          HumanCentipede();
          ~HumanCentipede();
          void insert(std::string);
          bool erase(std::string);
          void print();
  };
  
  #endif
</pre>
              <p>...and if you haven't seen the movie, or didn't catch the reference, please don't look it up (read: please don't sue me if you do)</p>
              <br/>
              <p class='example'>Make a single change to our LinkedList insert function to bring it up to speed with the HumanCentipede. That rhymed:</p>
<pre class='prettyprint'>
  // Add a new person to the centipede at the
  // end with name s
  void HumanCentipede::insert (std::string s) {
      // 1) Dynamically allocate a Person
      // ...whatever that translates to in
      // people terms...
      Person* toAdd = new Person(s);
    
      // 2) Update the head if first victim
      if (head == nullptr) {
          head = toAdd;
  
      // 2) Otherwise, we already have some People
      } else {
          // TODO: Use tail in HumanCentipede to track
          // the last slot in the centipede instead
  
          // Make an iterator to find the last
          // Person in the Centipede
          Person* iterator = head;
      
          // Stick the new Person on the end of the
          // centipede
          while ( iterator-&gt;m_front != nullptr ) {
              iterator = iterator-&gt;m_front;
          }
          // Update the last Person's m_front
          iterator-&gt;m_front = toAdd;
          
          // Update the new Person's m_back
          // [!] Fill in here!
      }
  
      // 3) Add one to the size
      size++;
  }
</pre>
              <br/>
              <p>It should work with this main function:</p>
<pre class='prettyprint'>
  int main () {
      // Looked up the character names
      HumanCentipede cent;
      cent.insert("Katsuro");
      cent.insert("Lindsay");
      cent.insert("Jenny");
      cent.print();
  }
</pre>
              <br/>
              <p>Alright, that one was basically a freebie... no more freebies for HumanCentipede... instead, let's just walk through the erase function.</p>
              <p>Here are some behaviors for erasing a node at certain positions in a Doubly Linked... err... HumanCentipede:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-3/linkedLists-9.PNG' />
              </div>
              <hr/>
              <p>K, how about this one?</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-3/linkedLists-10.PNG' />
              </div>
            </div>
            <hr/>
            
            
            <br/>
            <div id='stacks' class='scrollspy-element' scrollspy-title='Stacks'></div>
            <h1>Stacks on Stacks</h1>
            <div>
              <p>Although we went over the basics of stacks last week, we uhh... didn't cover much more in class this week, so we'll dive a little deeper today.</p>
              <p>First, a little review... remember we implemented a stack using a linked list design:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-3/linkedLists-6.PNG' />
              </div>
              <p class='question' name='stacks-q0'>Are stacks designed for the "Last in, first out" (LIFO) or "First in, first out" (FIFO) behavior of insertion / retrieval?</p>
              <p class='answer' name='stacks-q0'>
                <strong>LIFO:</strong> The last items (of a sequence of items) we push onto the stack are at the top, and therefore the first to be retrieved (popped).
              </p>
              <br/>
              <p>We also discussed a variety of benefits for using stacks:</p>
              <p class='question' name='stacks-q1'>Name a couple benefits of using stacks over Lists, which allow access to all elements, rather than just the top.</p>
              <div class='answer' name='stacks-q1'>
                <p>Although there a variety of situational reasons to use stacks, in general, they are superior to Lists when:</p>
                <ul class='indent-1'>
                  <li><p>We don't want users of the interface to be able to see what's below the top of the stack (information hiding)</p></li>
                  <li><p>We want to enforce efficient insertion (push) and retrieval (pop) behavior (always at top of stack)</p></li>
                  <li><p>We want to enforce the LIFO behavior</p></li>
                </ul>
              </div>
              <br/>
              <p>We'll look at a few more applications with stacks later.</p>
              <p>First, let's take a quick look at the stack interface we have available through the C++ standard library.</p>
              <p><strong>Aside:</strong> I should note that stacks are a member of a classification of data structures called abstract data types:</p>
              <p class='definition'>
                An <strong>abstract data type (ADT)</strong> is a model for a certain class of data structures with similar behaviors. Just as the notion of a &quot;stack&quot; is an 
                abstract data type describing a list with the LIFO constraint, the C++ standard library stack is an implementation of that ADT.
              </p>
              <p>Here is the interface for the standard library stack</p>
              <p>We begin by using the necessary STL inclusion: <code class='prettyprint'>#include &lt;stack&gt;</code></p>
              <p>Now, if we want to define a new stack we have to use some notation we haven't seen before.</p>
              <div class='toolkit'>
                <p>To define a stack, we must specify the type of objects that we wish to stack; we do this via a <strong>template:</strong></p><br/>
<pre class='prettyprint'>
  // Where classT is the template
  // for the declared stack
  stack&lt;classT&gt; stacky;
</pre>
              </div>
              <br/>
              <p class='question' name='stacks-q2'>Why do we have to provide a type template to our stacks?</p>
              <p class='answer' name='stacks-q2'>The compiler will want to know the size of the objects we're stacking, as well as what operations are legal on its elements.</p>
              <br/>
              <h3>STL Stack Interface</h3>
              <p>Let's look at the public interface for our stacks.</p>
              <p class='definition'>
                As we've seen, we need to specify a template type for our stacks; for the purposes of the following function signatures, we'll assume that type is the generic &lt;classT&gt;
              </p>
              
              <br/>
              <h4>Construction</h4>
<pre class='prettyprint'>
  int main () {
      stack&lt;string&gt; stringStack;
      stack&lt;int&gt;* intStack = new stack&lt;int&gt;;
      delete intStack;
  }
</pre>
              <p>Note the syntax for dynamically allocating a stack with a template type. We must also specify the type in our <code class='prettyprint'>new</code> operator usage.</p>
              
              <br/>
              <h4>void push(const &lt;classT&gt; value)</h4>
<pre class='prettyprint'>
  // Making stack examples always reminds me
  // of someone because of the backwards
  // order of words...
  int main () {
      stack&lt;string&gt; stringStack;
      stringStack.push("-Yoda");
      stringStack.push("stack");
      stringStack.push("this");
      stringStack.push("is");
      stringStack.push("Lame");
  }
</pre>

              <br/>
              <h4>void pop()</h4>
              <p class='debug'>Warning: Notice that this particular implementation of a stack chooses a void return, and so the pop does not also return the object just popped.</p>
              <p>
                This is why we call stacks an abstract data type--it's abstract because different implementations can decide certain behavioral nuances (non essential to the key properties
                of a stack) differently.
              </p>
<pre class='prettyprint'>
  // [!] WARNING: will not compile
  int main () {
      stack&lt;string&gt; stringStack;
      string derp = stringStack.pop(":(");
  }
</pre>
              
              <br/>
              <h4>&lt;classT&gt;&amp; top()</h4>
              <p>Returns a <strong>*reference*</strong> to the item on the top of the stack. Sometimes called &quot;peeking&quot; at the top.</p>
<pre class='prettyprint'>
  int main () {
      // Is fabric technically a stack of
      // string? Kinda not... oh well, I
      // already typed it, so...
      stack&lt;string&gt; fabric;
      fabric.push("sheet");
      fabric.push("is the");
      fabric.push("This linen");
  
      fabric.top() = "This satin";
      cout &lt;&lt; fabric.top() &lt;&lt; endl;
  }
</pre>
              <p>Wow that... that example was beyond bad... I'm even sorry...</p>
              
              <br/>
              <h3>Other Functions:</h3>
              <p>Read: I'm too lazy to give each of these their own section:</p>
              <ul class='indent-1'>
                <li><p><strong>empty()</strong> returns a boolean designating whether or not the stack has any elements.</p></li>
                <li><p><strong>size()</strong> returns a count of the number of elements currently in the stack.</p></li>
              </ul>
              
              <br/>
              <h3>Stacks as Parameters:</h3>
              <p class='example'>Implement the printStack function signature designated below:</p>
<pre class='prettyprint'>
  // Returns a string representation of the given
  // stack of strings, added from top to bottom
  string printStringStack (stack&lt;string&gt; stacky) {
      // ...
  }
  
  int main () {
      stack&lt;string&gt; loudStack;
      loudStack.push("BRO");
      loudStack.push("STRINGS");
      loudStack.push("COOL");
      cout &lt;&lt; printStringStack(loudStack) &lt;&lt; endl;
  }
</pre>
              <p>We'll cover the way to accept generic stack / object template inputs in a later lecture.</p>
            </div>
            <hr/>
            
            
            <br/>
            <div id='queues' class='scrollspy-element' scrollspy-title='Queues'></div>
            <h1>Queueueueueues</h1>
            <div>
              <p>Queues aren't a whole lot different from stacks, except that instead of pushing to and popping from the top, we queue to the back of the queue and dequeue from the front.</p>
              <p class='definition'>A <strong>queue</strong> is another abstract data type that maintains the FIFO (first in, first out) behavior of insertion and retrieval of its elements.</p>
              <p>Here's what that might look like as a singly linked list:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/winter-2014/cs-32/week-4/stacks-2.PNG' />
              </div>
              <p>Again, though, you should be aware that a queue is an abstract data type, and that some implementations WILL allow you to access the intermediary nodes behind the front.</p>
              <p>That, however, is not true of the C++ STL queue, which only has access to the front and back element.</p>
              <p>Because the STL queue and stack have such a similar interface, let's race through this real quick!</p>
              <h3>Construction</h3>
<pre class='prettyprint'>
  #include &lt;queue&gt;
  #include &lt;iostream&gt;
  #include &lt;string&gt;
  using namespace std;
  
  int main () {
      queue&lt;string&gt; q; // ;_;
      queue&lt;int&gt;* qi = new queue&lt;int&gt;;
      delete qi;
  }
</pre>
              <br/>
              <h3>Push, pop, front, back</h3>
              <p>Cha cha real smooth.</p>
              <p>We can enqueue elements to the back of queues using the push function, and dequeue those from the front via pop:</p>
<pre class='prettyprint'>
  int main () {
      queue&lt;string&gt; q;
      q.push("Is");
      q.push("this");
      q.push("class");
      q.push("like...");
      q.push("5 hours?");
  
      for (int i = 0; i &lt; 5; i++) {
          cout &lt;&lt; q.front() &lt;&lt; endl;
          q.pop();
      }
  }
</pre>
              <h3>Other functions</h3>
              <ul class='indent-1'>
                <li><p><strong>back()</strong> returns a reference to the element at the back of the queue (most recently added)</p></li>
                <li><p><strong>empty()</strong> returns true if the queue has no elements, false otherwise</p></li>
                <li><p><strong>size()</strong> returns a count of the number of elements in the queue</p></li>
              </ul>
            </div>
            <hr/>
            
            
            <a class='btn btn-default pull-right hidden-print' href='javascript:window.print();'>
              <span class='glyphicon glyphicon-print'></span>
              &nbsp; PDF / Print
            </a>
            
          </div>
          <!-- END PRESENTATION CONTENT -->
          
          <!-- MATERIALS FROM CLASS: -->
          
        </div>
      </div>
      <!-- END MAIN CONTENT -->
      
      
    </div>
    <!-- END WRAPPER -->
    
    <!-- BEGIN FOOTER -->
    <div id="footer">
      <div class="container">
        <div class="col-md-12 text-center">
          
        </div>
      </div>
    </div>
    <!-- END FOOTER -->
    
  </body>
</html>
