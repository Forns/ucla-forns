
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <title>Andrew Forney - UCLA CS</title>
    <link href="../../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../../../css/magic-bootstrap.css" rel="stylesheet" type="text/css">
    <link href="../../../css/main.css" rel="stylesheet" type="text/css">
    <script src="../../../js/lib/jquery-2.0.3.min.js"></script>
    <script src="../../../js/lib/bootstrap.min.js"></script>
    <script src="../../../js/lib/expanding.js"></script>
    <script src="../../../js/display/general/general-display.js"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
  </head>
  
  <body data-spy="scroll" data-target="#scrollspy">
    
    <!-- BEGIN WRAP -->
    <div id="wrap">
      
      <!-- BEGIN NAVIGATION -->
      <nav class='navbar navbar-default' role='navigation'>
        <div class='nav-accent'></div>
        <div class='container'>
          <div class='row'>
            <div class='col-md-12'>
              <div class='navbar-header'>
                <button class='navbar-toggle' type='button' data-toggle='collapse' data-target='.navbar-main-collapse'>
                  <span class='sr-only'>Toggle Navigation</span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                </button>
                <a class='navbar-brand' href='/~forns/'>
                  <span id='brand-text'>
                    Andrew Forney
                  </span>
                </a>
              </div>
              
              <div id='nav-main' class='collapse navbar-collapse navbar-main-collapse'>
                <ul class='nav navbar-nav navbar-right'>
                  
                  <li>
                    <a href='/~forns/about.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-user'></span>
                      </div>
                      <p class='text-center'>About</p>
                    </a>
                  </li>
                  
                  <li class='active'>
                    <a href='/~forns/classes.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-book'></span>
                      </div>
                      <p class='text-center'>Classes</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/contact.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-comment'></span>
                      </div>
                      <p class='text-center'>Contact</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/publications.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-file'></span>
                      </div>
                      <p class='text-center'>Publications</p>
                    </a>
                  </li>
                  
                </ul>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <!-- END NAVIGATION -->
      
      <!-- BEGIN MAIN CONTENT -->
      <div id="main-content" class="container">
        <div class="row">
          
          <!-- BEGIN SCROLLSPY -->
          <div class='col-md-2 hidden-sm hidden-xs'>
            <div class="bs-sidebar hidden-print affix" role="complementary">
              <ul id='scrollspy' class="nav bs-sidenav">
              </ul>
            </div>
          </div>
          <!-- END SCROLLSPY -->
          
          <!-- BEGIN PRESENTATION CONTENT -->
          <div class='col-md-10 presentation-content' role='main'>
            
            <ol class="breadcrumb hidden-print">
              <li><a href="../../../classes.html">Classes</a></li>
              <li><a href="./cs-32.html">CS32</a></li>
              <li class="active">Midterm II Exercises</li>
            </ol>
            
            <div id='review' class='scrollspy-element' scrollspy-title='Midterm II'></div>
            <h1>Midterm II Review</h1>
            <div>
              <p>The following practice problems are meant to be supplemental to the lecture notes, and give some extra practice for problem types you might encounter on the midterm.</p>
              <p>Topics that are *probably* fair game include, but are not limited to, the following:</p>
              <ul class='indent-1'>
                <li><p>All of Midterm I's topics!</p></li>
                <li><p>Inheritance</p></li>
                <li><p>Polymorphism</p></li>
                <li><p>Recursion</p></li>
                <li><p>Complexity Analysis</p></li>
                <li><p>Sorting</p></li>
                <li><p>Binary and Binary Search Trees</p></li>
                <li><p>Tree Traversals</p></li>
              </ul>
            </div>
            <hr/>
            
            
            <br/>
            <div id='inheritanceAndPolymorphism' class='scrollspy-element' scrollspy-title='Inheritance and Polymorphism'></div>
            <h1>NoisyClass? Again? Really?</h1>
            <div>
              <p>Yes really!</p>
              <p>You'll thank me later...</p>
              <p>Here's the latest inheritance and polymorphism version:</p>
<pre class='prettyprint'>
  class NoisyBase {
      private:
          string s;
      public:
          NoisyBase (string sBase) {
              cout &lt;&lt; "[B] Base Constructor: " &lt;&lt; sBase &lt;&lt; endl;
              s = sBase;
          }
          virtual ~NoisyBase () {
              cout &lt;&lt; "[B] Base Destructor!" &lt;&lt; endl;
          }
          virtual string getS () {
              return s;
          }
  };
  
  class NoisyDerived: public NoisyBase {
      private:
          string s;
      public:
          NoisyDerived (string sBase, string sDerived): NoisyBase(sBase) {
              cout &lt;&lt; "[D] Derived Constructor: " &lt;&lt; sDerived &lt;&lt; endl;
              s = sDerived;
          }
          ~NoisyDerived () {
              cout &lt;&lt; "[D] Derived Destructor!" &lt;&lt; endl;
          }
          virtual string getS () {
              return s;
          }
  };
</pre>
              <br/>
              <p>So, let's start off with the simple stuff and then ramp it up. Make sure you remember the order of construction and destruction!</p>
              
              <br/>
              <p class='example'>Using the NoisyBase and NoisyDerived implementations above, what will the following code print out?</p>
<pre class='prettyprint'>
  int main() {
      NoisyBase b("base!");
      NoisyDerived d("base!", "derived!");
  }
</pre>

              <br/>
              <p class='example'>Using the NoisyBase and NoisyDerived implementations above, what will the following code print out?</p>
<pre class='prettyprint'>
  int main() {
      NoisyDerived d("base!", "derived!");
      NoisyBase* bPtr = &amp;d;
      cout &lt;&lt; bPtr-&gt;getS() &lt;&lt; endl;
  }
</pre>

              <br/>
              <p class='example'>Using the NoisyBase and NoisyDerived implementations above, what will the following code print out?</p>
<pre class='prettyprint'>
  // [!] Note: no noisy copy constructor defined, but
  // b is still passed by value... so what happens
  // at the end of this function?
  void NoisyFunc (NoisyBase b) {
      cout &lt;&lt; b.getS() &lt;&lt; endl;
  }
  
  int main() {
      NoisyDerived d("base!", "derived!");
      NoisyFunc(d);
  }
</pre>

              <br/>
              <p class='example'>Using the NoisyBase and NoisyDerived implementations above, what will the following code print out?</p>
<pre class='prettyprint'>
  int main() {
      NoisyBase* bPtr0 = new NoisyBase("base!");
      NoisyBase* bPtr1 = new NoisyDerived("base!", "derived!");
      delete bPtr0;
      // [!] Remember your order of destruction!
      delete bPtr1;
  }
</pre>
              <br/>
              
              <p class='example'>Using the NoisyBase and NoisyDerived implementations above, what will the following code print out?</p>
<pre class='prettyprint'>
  void f(int n) {
      NoisyDerived* d = new NoisyDerived("base!", "derived!");
      if (n &lt;= 0) {
          delete d;
          return;
      } else {
          f(n - 1);
      }
      delete d;
  }
  
  int main() {
      f(1);
  }
</pre>
              <br/>
            </div>
            <hr/>
            
            
            <br/>
            <div id='recursion' class='scrollspy-element' scrollspy-title='Recursion'></div>
            <h1>Recursion Examples</h1>
            <div>
              <p>More recursion than one person can handle! Before we start, keep the following tips in mind:</p>
              <p><strong>Q: Is there a general strategy to approaching a recursion problem?</strong></p>
              <p>General? Well, not really, but there are some guidelines that might help you to think recursively:</p>
              <ul class='indent-1'>
                <li>
                  <p>Start with the very simplest case of the problem that you know how to solve.</p>
                  <ul class='indent-1'>
                    <li><p>Write down the steps that you use to solve it</p></li>
                    <li><p>See if you can reduce those steps to recursive ones</p></li>
                  </ul>
                </li>
                <li>
                  <p>Once you see the very simple case, try applying the same strategy to a more difficult case</p>
                  <ul class='indent-1'>
                    <li><p>If that works, then cool! You're done!</p></li>
                    <li><p>If that *doesn't* work, see if you can split the data in a meaningful way that reduces it to the simple case that you know how to solve.</p></li>
                  </ul>
                </li>
                <li>
                  <p>It also helps to think about base cases and the conditions of termination</p>
                  <ul class='indent-1'>
                    <li><p>
                      Problems involving arrays usually have to look out for index out of bound problems, for example, and how the &quot;end index&quot; relates to where the current recursive
                      call pointer is to an element in that array
                    </p></li>
                  </ul>
                </li>
                <li>
                  <p>Remember the tools available to you in your problem's scenario:</p>
                  <ul class='indent-1'>
                    <li><p>
                      If it's an array input, remember that the elements are indexed; this means that if I have a pointer to the &quot;first&quot; element 
                      (I put &quot;first&quot; in quotes because that might be the first element of a recursive call, but not necessarily the true first element of the array) 
                      and also the length of that array, then I know I have access to that first element and any offset up to the length - 1.
                    </p></li>
                    <li><p>
                      Remember that you can add to and chain recursive calls, for example some function f taking in a pointer to some array element and the remaining length, 
                      I can do: return f(a1 + 1, n1 - 1) + f(a2, n2 - 1); (just an example, not a real answer to anything)
                    </p></li>
                    <li><p>
                      If your function isn't void, try to put your recursive cases into return statements (like above) and plan around that mechanic.
                    </p></li>
                  </ul>
                </li>
              </ul>
              <p>
                The most fruitful experience I have is to do problems by hand, see how I solve it mentally, and then try to abstract those steps to an algorithm--after 
                that, I'll try to make that algorithm recursive!
              </p>
              <p>That said, let's start off with some warm up problems and then ramp up to that heavy ish.</p>
              
              <p class='example'>Implement the cliche recursion problem factorial, which takes in <code class='prettyprint'>int n</code> and returns the value n!.</p>
<pre class='prettyprint'>
  int factorial(int n) {
      // ...
  }
</pre>
<pre class='prettyprint'>
  int main () {
      // Prints 1 (0! is defined as 1)
      cout &lt;&lt; factorial(0) &lt;&lt; endl;
      // Prints 1
      cout &lt;&lt; factorial(1) &lt;&lt; endl;
      // Prints 2 = 2 * 1
      cout &lt;&lt; factorial(2) &lt;&lt; endl;
      // Prints 6 = 3 * 2 * 1
      cout &lt;&lt; factorial(3) &lt;&lt; endl;
      // Prints 24 = 4 * 3 * 2 * 1
      cout &lt;&lt; factorial(4) &lt;&lt; endl;
  }
</pre>
              <p class='question' name='recursion-q0'>Click here for a sample solution.</p>
              <div class='answer' name='recursion-q0'>
<pre class='prettyprint'>
  int factorial(int n) {
      return (n == 1 || n == 0) ? 1 : factorial(n - 1) * n;
  }
</pre>
              </div>
              <br/>
              
              <p class='example'>
                Implement the isPalindrome function recursively, which determines whether or not the input array of chars is a palindrome (the same forward as backward). If the input 
                has spaces, ignore them.
              </p>
<pre class='prettyprint'>
  bool isPalindrome(char* c, int len) {
      // ...
  }
</pre>
<pre class='prettyprint'>
  int main () {
      char p0[] = " a ";
      char p1[] = "racecar";
      char p2[] = "I R PALINDROME?";
      char p3[] = "nurses run";
      char p4[] = " ";
      char p5[] = "ra ce ca r";
      
      // All tests except for p2 return true
      cout &lt;&lt; isPalindrome(p0, 3) &lt;&lt; endl;
      cout &lt;&lt; isPalindrome(p1, 7) &lt;&lt; endl;
      cout &lt;&lt; isPalindrome(p2, 15) &lt;&lt; endl;
      cout &lt;&lt; isPalindrome(p3, 10) &lt;&lt; endl;
      cout &lt;&lt; isPalindrome(p4, 1) &lt;&lt; endl;
      cout &lt;&lt; isPalindrome(p5, 10) &lt;&lt; endl;
  }
</pre>
              <p class='question' name='recursion-q1'>Click here for a sample solution.</p>
              <div class='answer' name='recursion-q1'>
<pre class='prettyprint'>
  bool isPalindrome(char* c, int len) {
      if (c[0] == ' ') {
          return isPalindrome(&amp;c[1], len - 1);
      }
      if (c[len - 1] == ' ') {
          return isPalindrome(&amp;c[0], len - 1);
      }
      if(len &lt; 2) {
          return true;
      } else {
          return c[0] == c[len-1] &amp;&amp; isPalindrome(&amp;c[1], len - 2);
      }
  }
</pre>
              </div>
              <br/>
              
              <p class='example'>
                Implement the lengthInClosure function recursively, which prints out how many non-parenthesis characters (whitespace included) are within AND on either side of a set of parentheses in an input
                cstring ('\0' terminated array of characters).
                If no characters appear on a side of a parenthesis, print nothing (i.e., do not print anything, do not print '0').
                You may assume all input is syntactically valid (no mismatched parens) and that all expressions begin with an open parenthesis.
              </p>
<pre class='prettyprint'>
  void lengthInClosure (char* c, int n = 0)
      // ...
  }
</pre>
<pre class='prettyprint'>
  int main () {
      char c1[] = "(testing(stuff) now)";
      char c2[] = "(testing() now)(wow(yo))";
      char c3[] = "(((stuff)))";
  
      // Prints (7(5)4)
      lengthInClosure(c1);
  
      // Prints (7()4)(3(2))
      lengthInClosure(c2);
  
      // Prints (((5)))
      lengthInClosure(c3);
  }
</pre>
              <p class='question' name='recursion-q2'>Click here for a sample solution.</p>
              <div class='answer' name='recursion-q2'>
<pre class='prettyprint'>
  void lengthInClosure (char* c, int n = 0) {
      switch (*c) {
          case '\0':
              cout &lt;&lt; endl;
              return;
          case '(':
          case ')':
              if (n != 0) {
                  cout &lt;&lt; n;
              }
              cout &lt;&lt; *c;
              lengthInClosure(c + 1, 0);
              break;
          default:
              lengthInClosure(c + 1, n + 1);
      }
  }
</pre>
              </div>
              <br/>
              
              
              <p class='example'>
                Implement the countDigit function recursively, which takes in an input int n and then an input digit (int from 0 - 9) and returns how many times the given digit appears within n. Assume only 
                input n > 0.
                <br/>
                [!] Hint: The input int n is a *deci*mal number. Do we have integer arithmetic that could perform a first-and-rest split on n? Maybe a last-and-rest split even?
              </p>
<pre class='prettyprint'>
  int countDigit(int n, int digit) {
      // ...
  }
</pre>
<pre class='prettyprint'>
  int main () {
      int n1 = 1000,
          n2 = 10101;
  
      // Prints 3
      cout &lt;&lt; countDigit(n1, 0) &lt;&lt; endl;
  
      // Prints 1
      cout &lt;&lt; countDigit(n1, 1) &lt;&lt; endl;
  
      // Prints 0
      cout &lt;&lt; countDigit(n1, 2) &lt;&lt; endl;
  
      // Prints 3
      cout &lt;&lt; countDigit(n2, 1) &lt;&lt; endl;
  }
</pre>
              <p class='question' name='recursion-q3'>Click here for a sample solution.</p>
              <div class='answer' name='recursion-q3'>
  <p class='question' name='recursion-q4'>Seriously though, did you try it or did you think about it for a second and then be like, "well, I'll just take a peek at what he did..."?</p>
  <div class='answer' name='recursion-q4'>
<pre class='prettyprint'>
  int countDigit(int n, int digit) {
      int count;
      if (n == 0) {
          return 0;
      }
      
      if (n % 10 == digit) {
          return 1 + countDigit(n / 10, digit);
      } else {
          return countDigit(n / 10, digit);
      }
  }
</pre>
  </div>
              </div>
              <br/>
              
              <p>Are you guys ready for this one? This is a fantastic recursion problem, I got really happy when I thought of it.</p>
              <p class='example'>
                Implement the maxPath function recursively, which takes in a Maze (just like in homeworks 2 and 3) that is an array of strings with 'X' characters for walls and '.' characters for corridors,
                and returns the longest path one could walk starting at the given start row and start column.
                <br/>
                [!] Hint: You might want to use the cmath max(int1, int2); function, which returns the maximum of its two arguments.
              </p>
<pre class='prettyprint'>
  int maxPath(string maze[], int nRows, int nCols, int sr, int sc) {
      // ...
  }
</pre>
<pre class='prettyprint'>
  int main () {
      string maze0[] = {
        "XXXXX",
        "XX.XX",
        "XX..X",
        "X..XX",
        "XXXXX"
    };
    string maze0Copy[] = {
        "XXXXX",
        "XX.XX",
        "XX..X",
        "X..XX",
        "XXXXX"
    };
    string maze1[] = {
        "XXXXX",
        "XX.XX",
        "XX..X",
        "X.XXX",
        "XXXXX"
    };
    string maze1Copy[] = {
        "XXXXX",
        "XX.XX",
        "XX..X",
        "X.XXX",
        "XXXXX"
    };
    string maze2[] = {
        "XXXXX",
        "X...X",
        "X...X",
        "X...X",
        "XXXXX"
    };
    
    // Prints 4
    cout &lt;&lt; maxPath(maze0, 5,5, 3,1) &lt;&lt; endl;
    // Prints 3
    cout &lt;&lt; maxPath(maze0Copy, 5,5, 3,2) &lt;&lt; endl;
    // Prints 1
    cout &lt;&lt; maxPath(maze1, 5,5, 3,1) &lt;&lt; endl;
    // Prints 0
    cout &lt;&lt; maxPath(maze1Copy, 5,5, 3,2) &lt;&lt; endl;
    // Prints 9
    // (observe the "serpentine" path we can take)
    cout &lt;&lt; maxPath(maze2, 5,5, 3,1) &lt;&lt; endl;
  }
</pre>
              <p class='question' name='recursion-q5'>Click here for a sample solution.</p>
              <div class='answer' name='recursion-q5'>
  <p class='question' name='recursion-q6'>OK, don't try to pull a fast one on me... you gotta try this yourself first...</p>
  <div class='answer' name='recursion-q6'>
    <p class='question' name='recursion-q7'>I know you haven't tried it yet! No easy answers here!</p>
    <div class='answer' name='recursion-q7'>
<pre class='prettyprint'>
  int maxPath(string maze[], int nRows, int nCols, int sr, int sc) {
      if (maze[sr][sc] != '.') {
          return 0;
      }
  
      maze[sr][sc] = '@';
      int currentMax = 0;
      currentMax = max(1 + maxPath(maze, nRows, nCols, sr - 1, sc), currentMax);
      currentMax = max(1 + maxPath(maze, nRows, nCols, sr, sc + 1), currentMax);
      currentMax = max(1 + maxPath(maze, nRows, nCols, sr + 1, sc), currentMax);
      currentMax = max(1 + maxPath(maze, nRows, nCols, sr, sc - 1), currentMax);
  
      return currentMax;
  }
</pre>
    </div>
  </div>
              </div>
              <br/>
            </div>
            <hr/>
            
            
            <br/>
            <div id='bigO' class='scrollspy-element' scrollspy-title='Big-O'></div>
            <h1>Big 'Ole Big-O Review</h1>
            <div>
              <p>Remember our guidelines for determining time complexity:</p>
              <ol class='indent-1'>
                <li><p>Identify the statements that rely on the size of the input</p></li>
                <li><p>Of those that are reliant on the size of the input, which are dependent upon each other?</p></li>
                <li><p>Remember that a single statement, particularly a function call, is not a guarantee for a constant time operation!</p></li>
              </ol>
              <p>You ready to do this? Let's start off with some non-programmatic analyses and then move to the hard stuff...</p>
              <br/>
              <p>Andrew continually loses socks in his dryer... one day he discovers why: a quantum sock portal has opened up within the lint rack and has been sucking socks in; finally
              it reaches critical mass, and then expodes into an (almost) infinite number of socks!</p>
              <p>Rather than work on his research, Andrew decides to do something more exciting and starts sorting the socks into their respective pairs. Because he's particularly devoted to
              procrastinating, he desides to pick up one sock, and then look at other socks in the pile until he finds a match.</p>
              <p class='example'>
                If more socks continue to spill out of the quantum sock portal, what is the time complexity growth of Andrew's sort algorithm?
              </p>
              <p class='question' name='bigO-q0'>Click for solution</p>
              <p class='answer' name='bigO-q0'>
                Andrew, that was an *excessive* amount of setup for the answer of O(n^2); we see that the sort is much like bubble sort in that you're needing to take each sock and run it through
                the rest of the &quot;input&quot; until we find a match.
              </p>
              
              <br/>
              <p>Well, it took awhile, but Andrew finally finished sorting all those damn socks. He decided he'd keep about a million socks just in case, but where to put all of them?</p>
              <p>As it turns out, the sock pairs have a couple defining characteristics:</p>
              <ul class='indent-1'>
                <li><p>They have a color (every pair of socks falls, conveniently, evenly distributed across the hexadecimal color spectrum from #000000 (black) to #FFFFFF (white))</p></li>
                <li><p>They have a shape-pattern of 1 of 3 shapes: squares, circles, and triangles. 1/3 of the socks have squares, 1/3 circles, and 1/3 triangles.</p></li>
              </ul>
              <p>Luckily, Ikea sells SOK, a drawer apparatus for storing millions of socks that lets you add an arbitrary number of drawers...</p>
              <p>SOK also comes with a data pad that allows you to know exactly the drawer (note: not necessarily where in the drawer) that contains a given sock color OR a given shape, but not both.</p>
              <p class='example'>
                Would it be more efficient for Andrew to store his socks by shape or by color if, on any given day, he is interested in searching for a pair of socks with a given color AND shape pattern?
              </p>
              <p class='question' name='bigO-q1'>Click for solution</p>
              <p class='answer' name='bigO-q1'>
                It would be more efficient to keep drawers indexed by color, because the SOK data pad could thin the results to a more unique color, which would only have a few pairs with different shapes
                within the drawer. If you indexed drawers by shape, then you'd only have 3 drawers with about 333,333 socks each, which would then need a linear search to find the right color!
              </p>
              
              <br/>
              <p>&quot;Andrew, what *were* those examples? Is this a creative writing class?&quot;</p>
              <p>So I wanted to break the monotony a bit!</p>
              <p>Fine, you want programmy stuff? Here you go:</p>
              
              
              <br/>
              <p class='example'>What is the time complexity of the following function?</p>
<pre class='prettyprint'>
  void funkyFunc (int n) {
      for (int i = 0; i &lt; n; i++) {
          for (int j = 10; j &gt; 0; j--) {
              cout &lt;&lt; j &lt;&lt; endl;
          }
      }
  }
</pre>
              <p class='question' name='bigO-q2'>Click for solution</p>
              <p class='answer' name='bigO-q2'>O(n) because the inner loop runs a constant number of times</p>
              
              
              <br/>
              <p class='example'>What is the time complexity of the following function?</p>
<pre class='prettyprint'>
  void funkyFunc (int n) {
      for (int i = 0; i &lt; n * n; i++) {
          for (int j = 0; j &lt; n; j++) {
              cout &lt;&lt; i &lt;&lt; j &lt;&lt; endl;
          }
      }
  }
</pre>
              <p class='question' name='bigO-q2-1'>Click for solution</p>
              <p class='answer' name='bigO-q2-1'>O(n^3) because the outer loop relies on the size of the input squared, and the inner loop relies on the size of the input as many times as the outer loop. n * n^2</p>
              
              
              <br/>
              <p class='example'>What is the time complexity of the following function?</p>
<pre class='prettyprint'>
  void funkyFunc (int n) {
      for (int i = 0; i &lt; n * n; i++) {
          for (int j = 0; j &lt; i; j++) {
              cout &lt;&lt; i &lt;&lt; j &lt;&lt; endl;
          }
      }
  }
</pre>
              <p class='question' name='bigO-q3'>Click for solution</p>
              <div class='answer' name='bigO-q3'>
<pre class='prettyprint'>
  sum(i)_i=1 to n^2 
  = 1 + 2 + 3 + ... + (n^2 - 2) + (n^2 - 1) + n^2
  = (n^2 + 1) + (n^2 + 1) + ... + (n^2 + 1) // how many (n^2 + 1)'s?
  = (n^2)/2 * (n^2 + 1) // (n^2)/2 of them!
  = (n^4)/2 + (n^2)/2
  => O(n^4)
</pre>
              </div>
              
              
              <br/>
              <p class='example'>
                Say the following algorithm takes in a pointer to a Node in a linked list. Assume N to be the size of the linked list. What is the time complexity of the following function in terms of N?
              </p>
<pre class='prettyprint'>
  void funkyFunc (Node* n) {
      int i = 1;
      while (true) {
          int j = i;
          while (j &gt; 0 &amp;&amp; n != nullptr) {
              n = n-&gt;next;
              cout &lt;&lt; n-&gt;data &lt;&lt; endl;
              j--;
          }
          if (j != 0) {
              return;
          }
          i *= 2;
      }
  }
</pre>
              <p class='question' name='bigO-q4'>Click for solution</p>
              <p class='answer' name='bigO-q4'>
                O(N); it might LOOK like we're reducing the size of our data set at every step by the i *= 2, but if you look at the innermost loop, we're actually visiting every Node once! 
              </p>
              
              
              <br/>
              <p class='example'>What is the time complexity of the following function in terms of q and r?</p>
<pre class='prettyprint'>
  void funkyFunc (int q, int r) {
      for (int i = q * r; i &gt; 0; i--) {
          cout &lt;&lt; q &lt;&lt; r &lt;&lt; endl;
      }
      for (int i = q * r; i &gt; 0; i /= 2) {
          cout &lt;&lt; r &lt;&lt; q &lt;&lt; endl;
      }
  }
</pre>
              <p class='question' name='bigO-q5'>Click for solution</p>
              <p class='answer' name='bigO-q5'>
                O(q*r); note that the second loop runs with O(log(q*r)), which is NOT dependent on the first loop and a lesser complexity than the colinear case in the first loop, so we reduce
                from O(q*r + log(q*r)) to O(q*r).
              </p>
              
              
              <br/>
              <p class='example'>What is the time complexity of the following function in terms of input n and size of input list, L?</p>
<pre class='prettyprint'>
  void funkyFunc (int n, list&lt;int&gt; listy) {
      vector&lt;int&gt; victor;
      for (int i = 0; i &lt; listy.size(); i++) {
          victor.push_back(i * n);
      }
      vector&lt;int&gt;::iterator vit = victor.begin();
      list&lt;int&gt;::iterator lit = listy.begin();
      while (vit != victor.end()) {
          lit = listy.insert(lit, *vit);
          vit = victor.erase(vit);
      }
  }
</pre>
              <p class='question' name='bigO-q6'>Click for solution</p>
              <div class='answer' name='bigO-q6'>
<pre class='prettyprint'>
  void funkyFunc (int n, list&lt;int&gt; listy) {
      vector&lt;int&gt; victor;
      // [!] Goes L times; n is irrelevant to steps
      for (int i = 0; i &lt; listy.size(); i++) {
          // [!] Push to back of vector O(1)
          victor.push_back(i * n);
      }
      vector&lt;int&gt;::iterator vit = victor.begin();
      list&lt;int&gt;::iterator lit = listy.begin();
      
      // [!] Goes L times because victor was constructed
      // with all L elements
      while (vit != victor.end()) {
          // [!] Insertion into linked list constant time O(1)
          lit = listy.insert(lit, *vit);
          // [!] Deletion of front of vector requires re-ordering
          // proportional to size of the vector, in this case, that size
          // is L; so O(L)
          vit = victor.erase(vit);
      }
      // [!] Therefore, above loop has complexity O(L^2)
      
      // [!] Total complexity: O(L + L^2), which reduces to
      // O(L^2)
  }
</pre>
              </div>
              
              
              <br/>
              <p class='example'>What is the time complexity of the following function in terms of the number of nodes in s1 (call that number S) and the number in s2 (call that number R)?</p>
<pre class='prettyprint'>
  void funkyFunc (set&lt;int&gt; s1, set&lt;int&gt; s2) {
      set&lt;int&gt;::iterator sit = s1.begin();
      while (sit != s1.end()) {
          if (s2.find(*sit) != s2.end()) {
              s2.insert(*sit);
          }
          sit++;
      }
  }
</pre>
              <p class='question' name='bigO-q7'>Click for solution</p>
              <div class='answer' name='bigO-q7'>
<pre class='prettyprint'>
  void funkyFunc (set&lt;int&gt; s1, set&lt;int&gt; s2) {
      set&lt;int&gt;::iterator sit = s1.begin();
      // [!] Goes through all S elements of s1
      while (sit != s1.end()) {
          // [!] Find operation is binary search so log(R)
          if (s2.find(*sit) != s2.end()) {
              // [!] Insertion into BST take log(R)
              s2.insert(*sit);
          }
          sit++;
      }
      // [!] Therefore, outer loop runs S times and with every loop
      // we're performing O(log(R)), giving us total complexity:
      // O(S*log(R))
  }
</pre>
              </div>
              
              
              <br/>
              <p class='example'>What is the time complexity of the following function in terms of the size of the input stack (S) and the number of elements in the unordered_set (U)?</p>
<pre class='prettyprint'>
  void funkyFunc (stack&lt;int&gt; si, unordered_set&lt;int&gt; ui) {
      while (!si.empty()) {
          if (ui.find(si.top()) == ui.end()) {
              ui.insert(si.top());
          }
          si.pop();
      }
  }
</pre>
              <p class='question' name='bigO-q8'>Click for solution</p>
              <div class='answer' name='bigO-q8'>
<pre class='prettyprint'>
  void funkyFunc (stack&lt;int&gt; si, unordered_set&lt;int&gt; ui) {
      // [!] Go through all S elements of the stack
      while (!si.empty()) {
          // [!] unordered_sets are hashes! Average case constant time lookup O(1)
          if (ui.find(si.top()) == ui.end()) {
              // [!] Same thing with hashes; average case constant time insertion O(1)
              ui.insert(si.top());
          }
          // [!] Popping from stack is constant time
          si.pop();
      }
      
      // [!] Total time complexity: O(S)
  }
</pre>
              </div>
              
              
              <br/>
              <p class='example'>What is the time complexity of the following function?</p>
<pre class='prettyprint'>
  void funkyFunc (int q, int r) {
      map&lt;int, int&gt; mappy;
      for (int i = 0; i &lt; q; i++) {
          for (int j = r * r * i; j &gt; 0; j--) {
              mappy[i] = j;
          }
      }
  }
</pre>
              <p class='question' name='bigO-q9'>Click for solution</p>
              <div class='answer' name='bigO-q9'>
<pre class='prettyprint'>
  void funkyFunc (int q, int r) {
      map&lt;int, int&gt; mappy;
      // [!] Go through q times in outer loop
      for (int i = 0; i &lt; q; i++) {
          // [!] Inner loop goes r^2 * i times, and i is dependent
          // on q, so really this loop is proportional to O(r^2 * q)
          for (int j = r * r * i; j &gt; 0; j--) {
              // [!] Insertion into map takes a log time on the keys...
              // since we're inserting into the map with keys related to
              // i, and i is dependent on q, then our insertion time is
              // proportional to O(log(q))
              mappy[i] = j;
          }
      }
      // [!] Total, then, we have complexities of:
      // Outer loop: O(q)
        // Inner loop: O(r^2 * q)
          // Inner map assignment: O(log(q))
      // Total: O(r^2 * q^2 * log(q))
  }
</pre>
              </div>
              
              
              <br/>
              <p class='example'>What is the time complexity of funkyFunc below in terms of inputs q and r?</p>
<pre class='prettyprint'>
  struct Node {
      Node* next;
      int data;
      Node (int d) {
          data = d;
          next = nullptr;
      }
  };
  
  struct Trickz {
      Node* insertion;
      Node* head;
      Trickz () {
          insertion = nullptr;
          head = nullptr;
      }
      void push (int dat) {
          Node* toInsert = new Node(dat);
          if (head == nullptr) {
              head = toInsert;
          } else {
              insertion-&gt;next = toInsert;
          }
          insertion = toInsert;
      }
      ~Trickz () {
          insertion = head;
          Node* comp1 = head;
          Node* comp2 = head;
          while (comp1 != nullptr) {
              while (comp2 != nullptr) {
                  if (comp1-&gt;data == comp2-&gt;data) {
                      cout &lt;&lt; comp1-&gt;data &lt;&lt; endl;
                  }
                  comp2 = comp2-&gt;next;
              }
              comp1 = comp1-&gt;next;
          }
          while (insertion != nullptr) {
              Node* temp = insertion;
              insertion = temp-&gt;next;
              delete temp;
          }
      }
  };
  
  void funkyFunc (int q, int r) {
      for (int i = q * r; i &gt; 0; i -= 2) {
          Trickz t;
          for (int j = 0; j &lt; i; j++) {
              t.push(j);
          }
      }
  }
</pre>
              <p class='question' name='bigO-q11'>...that escalated quickly... Click for solution</p>
              <div class='answer' name='bigO-q11'>
<pre class='prettyprint'>
  void funkyFunc (int q, int r) {
      // [!] Even though i -= 2 at ever loop, i is still
      // linearly dependent on q * r, so we know this outer
      // loop has a complexity of O(q * r)
      for (int i = q * r; i &gt; 0; i -= 2) {
          Trickz t;
          // [!] Since j is dependent on i, then this inner
          // loop will also run q * r times, so O(q * r)
          for (int j = 0; j &lt; i; j++) {
              // [!] Our Trickz' push is constant time
              t.push(j);
          }
          // [!] But hark!
          // Trickz t was local to each iteration of the outer loop!
          // We call the destructor for t here... observe that the
          // Trickz destructor actually iterates through the list
          // multiple times... how many times? Well L^2 times if L is
          // the size of the list...
          
          // [!] What is L if we want our complexity answer in terms of q and r?
          // Well, L is dependent on how many times the inner loop runs, which is
          // dependent on how many times the outer loop runs, so our list length L is
          // also going to be proportional to q * r
          
          // [!] This gives us a total complexity of:
          // Outer loop: O(q * r)
            // Inner loop: O(q * r)
              // Insertion: O(1)
            // Destructor for Trickz O(L^2) = O((q * r) ^ 2)
            
          // [!] Total complexity: O((q * r) * (q * r) ^ 2) = O(q^3 * r^3)
      }
  }
</pre>
              </div>
              
            </div>
            <hr/>
            <br/>
            
            
            <div id='triage' class='scrollspy-element' scrollspy-title='Code Triage'></div>
            <h1>Code Triage</h1>
            <div>
              <p class='debug'>Someone tried to solve the isPalindrome function above with the following implementation. What is the error and show a test case on which it will break.</p>
<pre class='prettyprint'>
  bool isPalindrome(char* c, int len) {
      if (c[0] == ' ') {
          c++; // THAT'S THIS LANGUAGE! :DDD
          len--;
      }
      if (c[len - 1] == ' ') {
          len--;
      }
      if(len &lt; 2) {
          return true;
      } else {
          return c[0] == c[len-1] &amp;&amp; isPalindrome(&amp;c[1], len - 2);
      }
  }
</pre>
              <br/>
              
              <p>...maybe more to come... I just got really lazy... congrats on finishing the practice midterm!</p>
            </div>
            <hr/>
              
            <a class='btn btn-default pull-right hidden-print' href='javascript:window.print();'>
              <span class='glyphicon glyphicon-print'></span>
              &nbsp; PDF / Print
            </a>
            
          </div>
          <!-- END PRESENTATION CONTENT -->
          
          <!-- TODO: NoisyClass with recursion / inheritance / polymorphism -->
          <!-- TODO: Triage -->
          
            
        </div>
      </div>
      <!-- END MAIN CONTENT -->
      
      
    </div>
    <!-- END WRAPPER -->
    
    <!-- BEGIN FOOTER -->
    <div id="footer">
      <div class="container">
        <div class="col-md-12 text-center">
          
        </div>
      </div>
    </div>
    <!-- END FOOTER -->
    
  </body>
</html>
