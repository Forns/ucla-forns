
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <title>Andrew Forney - UCLA CS</title>
    <link href="../../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../../../css/magic-bootstrap.css" rel="stylesheet" type="text/css">
    <link href="../../../css/main.css" rel="stylesheet" type="text/css">
    <script src="../../../js/lib/jquery-2.0.3.min.js"></script>
    <script src="../../../js/lib/bootstrap.min.js"></script>
    <script src="../../../js/lib/expanding.js"></script>
    <script src="../../../js/display/general/general-display.js"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
  </head>
  
  <body data-spy="scroll" data-target="#scrollspy">
    
    <!-- BEGIN WRAP -->
    <div id="wrap">
      
      <!-- BEGIN NAVIGATION -->
      <nav class='navbar navbar-default' role='navigation'>
        <div class='nav-accent'></div>
        <div class='container'>
          <div class='row'>
            <div class='col-md-12'>
              <div class='navbar-header'>
                <button class='navbar-toggle' type='button' data-toggle='collapse' data-target='.navbar-main-collapse'>
                  <span class='sr-only'>Toggle Navigation</span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                </button>
                <a class='navbar-brand' href='/~forns/'>
                  <span id='brand-text'>
                    Andrew Forney
                  </span>
                </a>
              </div>
              
              <div id='nav-main' class='collapse navbar-collapse navbar-main-collapse'>
                <ul class='nav navbar-nav navbar-right'>
                  
                  <li>
                    <a href='/~forns/about.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-user'></span>
                      </div>
                      <p class='text-center'>About</p>
                    </a>
                  </li>
                  
                  <li class='active'>
                    <a href='/~forns/classes.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-book'></span>
                      </div>
                      <p class='text-center'>Classes</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/contact.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-comment'></span>
                      </div>
                      <p class='text-center'>Contact</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/publications.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-file'></span>
                      </div>
                      <p class='text-center'>Publications</p>
                    </a>
                  </li>
                  
                </ul>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <!-- END NAVIGATION -->
      
      <!-- BEGIN MAIN CONTENT -->
      <div id="main-content" class="container">
        <div class="row">
          
          <!-- BEGIN SCROLLSPY -->
          <div class='col-md-2 hidden-sm hidden-xs'>
            <div class="bs-sidebar hidden-print affix" role="complementary">
              <ul id='scrollspy' class="nav bs-sidenav">
              </ul>
            </div>
          </div>
          <!-- END SCROLLSPY -->
          
          <!-- BEGIN PRESENTATION CONTENT -->
          <div class='col-md-10 presentation-content' role='main'>
            
            <ol class="breadcrumb hidden-print">
              <li><a href="../../../classes.html">Classes</a></li>
              <li><a href="./cs-32.html">CS32</a></li>
              <li class="active">Midterm II Exercises</li>
            </ol>
            
            <div id='review' class='scrollspy-element' scrollspy-title='Midterm II'></div>
            <h1>Midterm II Review</h1>
            <div>
              <p>The following practice problems are meant to be supplemental to the lecture notes, and give some extra practice for problem types you might encounter on the midterm.</p>
              <p>Topics that are *probably* fair game include, but are not limited to, the following:</p>
              <ul class='indent-1'>
                <li><p>All of Midterm I's topics!</p></li>
                <li><p>Inheritance</p></li>
                <li><p>Polymorphism</p></li>
                <li><p>Recursion</p></li>
                <li><p>Sorting</p></li>
                <li><p>Binary and Binary Search Trees</p></li>
              </ul>
            </div>
            <hr/>
            
            
            <br/>
            <div id='inheritanceAndPolymorphism' class='scrollspy-element' scrollspy-title='Inheritance and Polymorphism'></div>
            <h1>NoisyClass? Again? Really?</h1>
            <div>
              <p>Yes really!</p>
              <p>You'll thank me later...</p>
              <p>Here's the latest inheritance and polymorphism version:</p>
<pre class='prettyprint'>
  class NoisyBase {
      private:
          string s;
      public:
          NoisyBase (string sBase) {
              cout &lt;&lt; "[B] Base Constructor: " &lt;&lt; sBase &lt;&lt; endl;
              s = sBase;
          }
          virtual ~NoisyBase () {
              cout &lt;&lt; "[B] Base Destructor!" &lt;&lt; endl;
          }
          virtual string getS () {
              return s;
          }
  };
  
  class NoisyDerived: public NoisyBase {
      private:
          string s;
      public:
          NoisyDerived (string sBase, string sDerived): NoisyBase(sBase) {
              cout &lt;&lt; "[D] Derived Constructor: " &lt;&lt; sDerived &lt;&lt; endl;
              s = sDerived;
          }
          ~NoisyDerived () {
              cout &lt;&lt; "[D] Derived Destructor!" &lt;&lt; endl;
          }
          virtual string getS () {
              return s;
          }
  };
</pre>
              <br/>
              <p>So, let's start off with the simple stuff and then ramp it up. Make sure you remember the order of construction and destruction!</p>
              
              <br/>
              <p class='example'>Using the NoisyBase and NoisyDerived implementations above, what will the following code print out?</p>
<pre class='prettyprint'>
  int main() {
      NoisyBase b("base!");
      NoisyDerived d("base!", "derived!");
  }
</pre>

              <br/>
              <p class='example'>Using the NoisyBase and NoisyDerived implementations above, what will the following code print out?</p>
<pre class='prettyprint'>
  int main() {
      NoisyDerived d("base!", "derived!");
      NoisyBase* bPtr = &amp;d;
      cout &lt;&lt; bPtr-&gt;getS() &lt;&lt; endl;
  }
</pre>

              <br/>
              <p class='example'>Using the NoisyBase and NoisyDerived implementations above, what will the following code print out?</p>
<pre class='prettyprint'>
  // [!] Note: no noisy copy constructor defined, but
  // b is still passed by value... so what happens
  // at the end of this function?
  void NoisyFunc (NoisyBase b) {
      cout &lt;&lt; b.getS() &lt;&lt; endl;
  }
  
  int main() {
      NoisyDerived d("base!", "derived!");
      NoisyFunc(d);
  }
</pre>

              <br/>
              <p class='example'>Using the NoisyBase and NoisyDerived implementations above, what will the following code print out?</p>
<pre class='prettyprint'>
  int main() {
      NoisyBase* bPtr0 = new NoisyBase("base!");
      NoisyBase* bPtr1 = new NoisyDerived("base!", "derived!");
      delete bPtr0;
      // [!] Remember your order of destruction!
      delete bPtr1;
  }
</pre>
              <br/>
              
              <p class='example'>Using the NoisyBase and NoisyDerived implementations above, what will the following code print out?</p>
<pre class='prettyprint'>
  void f(int n) {
      NoisyDerived* d = new NoisyDerived("base!", "derived!");
      if (n &lt;= 0) {
          delete d;
          return;
      } else {
          f(n - 1);
      }
      delete d;
  }
  
  int main() {
      f(1);
  }
</pre>
              <br/>
            </div>
            <hr/>
            
            
            <br/>
            <div id='recursion' class='scrollspy-element' scrollspy-title='Recursion'></div>
            <h1>Recursion Examples</h1>
            <div>
              <p>More recursion than one person can handle! Before we start, keep the following tips in mind:</p>
              <p><strong>Q: Is there a general strategy to approaching a recursion problem?</strong></p>
              <p>General? Well, not really, but there are some guidelines that might help you to think recursively:</p>
              <ul class='indent-1'>
                <li>
                  <p>Start with the very simplest case of the problem that you know how to solve.</p>
                  <ul class='indent-1'>
                    <li><p>Write down the steps that you use to solve it</p></li>
                    <li><p>See if you can reduce those steps to recursive ones</p></li>
                  </ul>
                </li>
                <li>
                  <p>Once you see the very simple case, try applying the same strategy to a more difficult case</p>
                  <ul class='indent-1'>
                    <li><p>If that works, then cool! You're done!</p></li>
                    <li><p>If that *doesn't* work, see if you can split the data in a meaningful way that reduces it to the simple case that you know how to solve.</p></li>
                  </ul>
                </li>
                <li>
                  <p>It also helps to think about base cases and the conditions of termination</p>
                  <ul class='indent-1'>
                    <li><p>
                      Problems involving arrays usually have to look out for index out of bound problems, for example, and how the &quot;end index&quot; relates to where the current recursive
                      call pointer is to an element in that array
                    </p></li>
                  </ul>
                </li>
                <li>
                  <p>Remember the tools available to you in your problem's scenario:</p>
                  <ul class='indent-1'>
                    <li><p>
                      If it's an array input, remember that the elements are indexed; this means that if I have a pointer to the &quot;first&quot; element 
                      (I put &quot;first&quot; in quotes because that might be the first element of a recursive call, but not necessarily the true first element of the array) 
                      and also the length of that array, then I know I have access to that first element and any offset up to the length - 1.
                    </p></li>
                    <li><p>
                      Remember that you can add to and chain recursive calls, for example some function f taking in a pointer to some array element and the remaining length, 
                      I can do: return f(a1 + 1, n1 - 1) + f(a2, n2 - 1); (just an example, not a real answer to anything)
                    </p></li>
                    <li><p>
                      If your function isn't void, try to put your recursive cases into return statements (like above) and plan around that mechanic.
                    </p></li>
                  </ul>
                </li>
              </ul>
              <p>
                The most fruitful experience I have is to do problems by hand, see how I solve it mentally, and then try to abstract those steps to an algorithm--after 
                that, I'll try to make that algorithm recursive!
              </p>
              <p>That said, let's start off with some warm up problems and then ramp up to that heavy ish.</p>
              
              <p class='example'>Implement the cliche recursion problem factorial, which takes in <code class='prettyprint'>int n</code> and returns the value n!.</p>
<pre class='prettyprint'>
  int factorial(int n) {
      // ...
  }
</pre>
<pre class='prettyprint'>
  int main () {
      // Prints 1 (0! is defined as 1)
      cout &lt;&lt; factorial(0) &lt;&lt; endl;
      // Prints 1
      cout &lt;&lt; factorial(1) &lt;&lt; endl;
      // Prints 2 = 2 * 1
      cout &lt;&lt; factorial(2) &lt;&lt; endl;
      // Prints 6 = 3 * 2 * 1
      cout &lt;&lt; factorial(3) &lt;&lt; endl;
      // Prints 24 = 4 * 3 * 2 * 1
      cout &lt;&lt; factorial(4) &lt;&lt; endl;
  }
</pre>
              <p class='question' name='recursion-q0'>Click here for a sample solution.</p>
              <div class='answer' name='recursion-q0'>
<pre class='prettyprint'>
  int factorial(int n) {
      return (n == 1 || n == 0) ? 1 : factorial(n - 1) * n;
  }
</pre>
              </div>
              <br/>
              
              <p class='example'>
                Implement the isPalindrome function recursively, which determines whether or not the input array of chars is a palindrome (the same forward as backward). If the input 
                has spaces, ignore them.
              </p>
<pre class='prettyprint'>
  bool isPalindrome(char* c, int len) {
      // ...
  }
</pre>
<pre class='prettyprint'>
  int main () {
      char p0[] = " a ";
      char p1[] = "racecar";
      char p2[] = "I R PALINDROME?";
      char p3[] = "nurses run";
      char p4[] = " ";
      char p5[] = "ra ce ca r";
      
      // All tests except for p2 return true
      cout &lt;&lt; isPalindrome(p0, 3) &lt;&lt; endl;
      cout &lt;&lt; isPalindrome(p1, 7) &lt;&lt; endl;
      cout &lt;&lt; isPalindrome(p2, 15) &lt;&lt; endl;
      cout &lt;&lt; isPalindrome(p3, 10) &lt;&lt; endl;
      cout &lt;&lt; isPalindrome(p4, 1) &lt;&lt; endl;
      cout &lt;&lt; isPalindrome(p5, 10) &lt;&lt; endl;
  }
</pre>
              <p class='question' name='recursion-q1'>Click here for a sample solution.</p>
              <div class='answer' name='recursion-q1'>
<pre class='prettyprint'>
  bool isPalindrome(char* c, int len) {
      if (c[0] == ' ') {
          return isPalindrome(&amp;c[1], len - 1);
      }
      if (c[len - 1] == ' ') {
          return isPalindrome(&amp;c[0], len - 1);
      }
      if(len &lt; 2) {
          return true;
      } else {
          return c[0] == c[len-1] &amp;&amp; isPalindrome(&amp;c[1], len - 2);
      }
  }
</pre>
              </div>
              <br/>
              
              <p class='example'>
                Implement the lengthInClosure function recursively, which prints out how many non-parenthesis characters (whitespace included) are within AND on either side of a set of parentheses in an input
                cstring ('\0' terminated array of characters).
                If no characters appear on a side of a parenthesis, print nothing (i.e., do not print anything, do not print '0').
                You may assume all input is syntactically valid (no mismatched parens) and that all expressions begin with an open parenthesis.
              </p>
<pre class='prettyprint'>
  void lengthInClosure (char* c, int n = 0)
      // ...
  }
</pre>
<pre class='prettyprint'>
  int main () {
      char c1[] = "(testing(stuff) now)";
      char c2[] = "(testing() now)(wow(yo))";
      char c3[] = "(((stuff)))";
  
      // Prints (7(5)4)
      lengthInClosure(c1);
  
      // Prints (7()4)(3(2))
      lengthInClosure(c2);
  
      // Prints (((5)))
      lengthInClosure(c3);
  }
</pre>
              <p class='question' name='recursion-q2'>Click here for a sample solution.</p>
              <div class='answer' name='recursion-q2'>
<pre class='prettyprint'>
  void lengthInClosure (char* c, int n = 0) {
      switch (*c) {
          case '\0':
              cout &lt;&lt; endl;
              return;
          case '(':
          case ')':
              if (n != 0) {
                  cout &lt;&lt; n;
              }
              cout &lt;&lt; *c;
              lengthInClosure(c + 1, 0);
              break;
          default:
              lengthInClosure(c + 1, n + 1);
      }
  }
</pre>
              </div>
              <br/>
              
              
              <p class='example'>
                Implement the countDigit function recursively, which takes in an input int n and then an input digit (int from 0 - 9) and returns how many times the given digit appears within n. Assume only 
                input n > 0.
                <br/>
                [!] Hint: The input int n is a *deci*mal number. Do we have integer arithmetic that could perform a first-and-rest split on n? Maybe a last-and-rest split even?
              </p>
<pre class='prettyprint'>
  int countDigit(int n, int digit) {
      // ...
  }
</pre>
<pre class='prettyprint'>
  int main () {
      int n1 = 1000,
          n2 = 10101;
  
      // Prints 3
      cout &lt;&lt; countDigit(n1, 0) &lt;&lt; endl;
  
      // Prints 1
      cout &lt;&lt; countDigit(n1, 1) &lt;&lt; endl;
  
      // Prints 0
      cout &lt;&lt; countDigit(n1, 2) &lt;&lt; endl;
  
      // Prints 3
      cout &lt;&lt; countDigit(n2, 1) &lt;&lt; endl;
  }
</pre>
              <p class='question' name='recursion-q3'>Click here for a sample solution.</p>
              <div class='answer' name='recursion-q3'>
  <p class='question' name='recursion-q4'>Seriously though, did you try it or did you think about it for a second and then be like, "well, I'll just take a peek at what he did..."?</p>
  <div class='answer' name='recursion-q4'>
<pre class='prettyprint'>
  int countDigit(int n, int digit) {
      int count;
      if (n == 0) {
          return 0;
      }
      
      if (n % 10 == digit) {
          return 1 + countDigit(n / 10, digit);
      } else {
          return countDigit(n / 10, digit);
      }
  }
</pre>
  </div>
              </div>
              <br/>
              
              <p>Are you guys ready for this one? This is a fantastic recursion problem, I got really happy when I thought of it.</p>
              <p class='example'>
                Implement the maxPath function recursively, which takes in a Maze (just like in homeworks 2 and 3) that is an array of strings with 'X' characters for walls and '.' characters for corridors,
                and returns the longest path one could walk starting at the given start row and start column.
                <br/>
                [!] Hint: You might want to use the cmath max(int1, int2); function, which returns the maximum of its two arguments.
              </p>
<pre class='prettyprint'>
  int maxPath(string maze[], int nRows, int nCols, int sr, int sc) {
      // ...
  }
</pre>
<pre class='prettyprint'>
  int main () {
      string maze0[] = {
        "XXXXX",
        "XX.XX",
        "XX..X",
        "X..XX",
        "XXXXX"
    };
    string maze0Copy[] = {
        "XXXXX",
        "XX.XX",
        "XX..X",
        "X..XX",
        "XXXXX"
    };
    string maze1[] = {
        "XXXXX",
        "XX.XX",
        "XX..X",
        "X.XXX",
        "XXXXX"
    };
    string maze1Copy[] = {
        "XXXXX",
        "XX.XX",
        "XX..X",
        "X.XXX",
        "XXXXX"
    };
    string maze2[] = {
        "XXXXX",
        "X...X",
        "X...X",
        "X...X",
        "XXXXX"
    };
    
    // Prints 4
    cout &lt;&lt; maxPath(maze0, 5,5, 3,1) &lt;&lt; endl;
    // Prints 3
    cout &lt;&lt; maxPath(maze0Copy, 5,5, 3,2) &lt;&lt; endl;
    // Prints 1
    cout &lt;&lt; maxPath(maze1, 5,5, 3,1) &lt;&lt; endl;
    // Prints 0
    cout &lt;&lt; maxPath(maze1Copy, 5,5, 3,2) &lt;&lt; endl;
    // Prints 9
    // (observe the "serpentine" path we can take)
    cout &lt;&lt; maxPath(maze2, 5,5, 3,1) &lt;&lt; endl;
  }
</pre>
              <p class='question' name='recursion-q5'>Click here for a sample solution.</p>
              <div class='answer' name='recursion-q5'>
  <p class='question' name='recursion-q6'>OK, don't try to pull a fast one on me... you gotta try this yourself first...</p>
  <div class='answer' name='recursion-q6'>
    <p class='question' name='recursion-q7'>I know you haven't tried it yet! No easy answers here!</p>
    <div class='answer' name='recursion-q7'>
<pre class='prettyprint'>
  int maxPath(string maze[], int nRows, int nCols, int sr, int sc) {
      if (maze[sr][sc] != '.') {
          return 0;
      }
  
      maze[sr][sc] = '@';
      int currentMax = 0;
      currentMax = max(1 + maxPath(maze, nRows, nCols, sr - 1, sc), currentMax);
      currentMax = max(1 + maxPath(maze, nRows, nCols, sr, sc + 1), currentMax);
      currentMax = max(1 + maxPath(maze, nRows, nCols, sr + 1, sc), currentMax);
      currentMax = max(1 + maxPath(maze, nRows, nCols, sr, sc - 1), currentMax);
  
      return currentMax;
  }
</pre>
    </div>
  </div>
              </div>
              <br/>
            </div>
            <hr/>
            
            
            <div id='triage' class='scrollspy-element' scrollspy-title='Code Triage'></div>
            <h1>Code Triage</h1>
            <div>
              <p class='debug'>Someone tried to solve the isPalindrome function above with the following implementation. What is the error and show a test case on which it will break.</p>
<pre class='prettyprint'>
  bool isPalindrome(char* c, int len) {
      if (c[0] == ' ') {
          c++; // THAT'S THIS LANGUAGE! :DDD
          len--;
      }
      if (c[len - 1] == ' ') {
          len--;
      }
      if(len &lt; 2) {
          return true;
      } else {
          return c[0] == c[len-1] &amp;&amp; isPalindrome(&amp;c[1], len - 2);
      }
  }
</pre>
              <br/>
              
              <p>...maybe more to come... I just got really lazy... congrats on finishing the practice midterm!</p>
            </div>
            <hr/>
              
            <a class='btn btn-default pull-right hidden-print' href='javascript:window.print();'>
              <span class='glyphicon glyphicon-print'></span>
              &nbsp; PDF / Print
            </a>
            
          </div>
          <!-- END PRESENTATION CONTENT -->
          
          <!-- TODO: NoisyClass with recursion / inheritance / polymorphism -->
          <!-- TODO: Triage -->
          
            
        </div>
      </div>
      <!-- END MAIN CONTENT -->
      
      
    </div>
    <!-- END WRAPPER -->
    
    <!-- BEGIN FOOTER -->
    <div id="footer">
      <div class="container">
        <div class="col-md-12 text-center">
          
        </div>
      </div>
    </div>
    <!-- END FOOTER -->
    
  </body>
</html>
