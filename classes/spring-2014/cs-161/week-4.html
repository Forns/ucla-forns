
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <title>Andrew Forney - UCLA CS</title>
    <link href="../../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../../../css/magic-bootstrap.css" rel="stylesheet" type="text/css">
    <link href="../../../css/main.css" rel="stylesheet" type="text/css">
    <script src="../../../js/lib/jquery-2.0.3.min.js"></script>
    <script src="../../../js/lib/bootstrap.min.js"></script>
    <script src="../../../js/lib/expanding.js"></script>
    <script src="../../../js/display/general/general-display.js"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
  </head>
  
  <body data-spy="scroll" data-target="#scrollspy">
    
    <!-- BEGIN WRAP -->
    <div id="wrap">
      
      <!-- BEGIN NAVIGATION -->
      <nav class='navbar navbar-default' role='navigation'>
        <div class='nav-accent'></div>
        <div class='container'>
          <div class='row'>
            <div class='col-md-12'>
              <div class='navbar-header'>
                <button class='navbar-toggle' type='button' data-toggle='collapse' data-target='.navbar-main-collapse'>
                  <span class='sr-only'>Toggle Navigation</span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                </button>
                <a class='navbar-brand' href='/~forns/'>
                  <span id='brand-text'>
                    Andrew Forney
                  </span>
                </a>
              </div>
              
              <div id='nav-main' class='collapse navbar-collapse navbar-main-collapse'>
                <ul class='nav navbar-nav navbar-right'>
                  
                  <li>
                    <a href='/~forns/about.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-user'></span>
                      </div>
                      <p class='text-center'>About</p>
                    </a>
                  </li>
                  
                  <li class='active'>
                    <a href='/~forns/classes.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-book'></span>
                      </div>
                      <p class='text-center'>Classes</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/contact.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-comment'></span>
                      </div>
                      <p class='text-center'>Contact</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/publications.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-file'></span>
                      </div>
                      <p class='text-center'>Publications</p>
                    </a>
                  </li>
                  
                </ul>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <!-- END NAVIGATION -->
      
      <!-- BEGIN MAIN CONTENT -->
      <div id="main-content" class="container">
        <div class="row">
          
          <!-- BEGIN SCROLLSPY -->
          <div class='col-md-2 hidden-sm hidden-xs'>
            <div class="bs-sidebar hidden-print affix" role="complementary">
              <ul id='scrollspy' class="nav bs-sidenav">
              </ul>
            </div>
          </div>
          <!-- END SCROLLSPY -->
          
          <!-- BEGIN PRESENTATION CONTENT -->
          <div class='col-md-10 presentation-content' role='main'>
            
            <ol class="breadcrumb hidden-print">
              <li><a href="../../../classes.html">Classes</a></li>
              <li><a href="./cs-161.html">Spring14 CS161</a></li>
              <li class="active">Week 4</li>
            </ol>
            
            <div id='constraintSat' class='scrollspy-element' scrollspy-title='Constraint Satisfaction'></div>
            <h1>Constraint Satisfaction Problems</h1>
            <div>
              <p>So we've been talking about classical search in something of a &quot;black-box&quot; fashion, meaning we have knowledge about states, transitions, and tests for goal states, but...</p>
              <p>...our search algorithms have treated states as atomic; there are no internal variables for us to wiggle and try to fix something that's wrong with a state and try to make it right.</p>
              <p class='definition'><strong>Constraint satisfaction problems (CSPs)</strong> use general purpose heuristic algorithms to try to find a solution using a set of variables and constraints.</p>
              <br/>
              <p>What does this mean?</p>
              <p>With CSPs, we define our states as consisting of a variety of variables that we then individually check against a variety of constraints.</p>
              <p>If our variable <strong>assignments</strong> in a given state are all <strong>consistent</strong> with our constraints, then we say that we've found a solution!</p>
              <p class='definition'>A CSP <strong>variable (X)</strong> is defined in terms of its <strong>domains (D)</strong>, such that a variable X_i can only attain a value in D_i in any given state.</p>
              <p class='definition'>A CSP <strong>constaint (C)</strong> is a Boolean condition for success on some variable instantiation.</p>
              <br/>
              <p>Therefore, we can phrase all of our constraint satisfaction problems as consisting of:</p>
              <ul class='indent-1'>
                <li><p>X: a set of variables {X_1, X_2, ..., X_n}</p></li>
                <li><p>D: a set of domains for those variables {D_1, D_2, ..., D_n} (one for each variable)</p></li>
                <li><p>C: a set of Boolean constraints that tell us when we've found a solution with our variables</p></li>
              </ul>
              <br/>
              <p class='debug'>NOTE: We've only found a solution whenever all of our constraints are satisfied, and every variable has been assigned a value from its respective domains!</p>
              <br/>
              <p>Later, however, we'll look at how knowing how many constraints we've failed can steer us in the right direction to a solution...</p>
              <p>This gives us a comparison between classical search and CSPs:</p>
              <table class='table table-striped table-bordered'>
                <caption>Classical Search vs. CSP</caption>
                <thead>
                  <tr>
                    <th><p>Property</p></th>
                    <th><p>Classical Search</p></th>
                    <th><p>CSP</p></th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <th><p>States</p></th>
                    <td><p>Problem-specific and atomic; cannot be divided into constituent components.</p></td>
                    <td><p>Variables, Domains, and Constraints</p></td>
                  </tr>
                  <tr>
                    <th><p>Success</p></th>
                    <td><p>Test a state to see if it meets our goal condition.</p></td>
                    <td><p>Assign values to all variables and see if that assignment meets all constraints</p></td>
                  </tr>
                  <tr>
                    <th><p>Cares about...</p></th>
                    <td><p>...the path from an initial state to a goal state</p></td>
                    <td><p>...an instantiation of variables that meets all constraints; path is irrelevant!</p></td>
                  </tr>
                  <tr>
                    <th><p>Applications</p></th>
                    <td><p>Pathfinding, optimization, etc.</p></td>
                    <td><p>SAT(isfiability), map coloring, scheduling, etc.</p></td>
                  </tr>
                </tbody>
              </table>
              <br/>
              <p>So, the motto of CSP might be, &quot;I don't know what I'm looking for, but I'll know it when I see it! ...oh and I don't care about how I got there.&quot;</p>
              <p>Let's look at some simple examples using numerical variables and algebraic constriants.</p>
              <p class='example'>Consider the following constraint satisfaction problem specifications and find a solution for each.</p>
<pre class='prettyprint'>
  X = {A, B}
  D = { {1, 2}, {0, -1} }
  
  #1
  C = { A &lt; B; A * B &gt;= 0 }
  
  #2
  C = { A &gt; B; A * B &gt;= 0 }
  
  #3
  C = { A &gt; 0 }
  
  
  
  OK... Now that we're done with the warmups...
  
  #4
  X = {A, B, C, D, E, F, G, H, I, J, K, L, M, N}
  D = {
          {1, 2, 3}, {6, 7, 22}, {2, 9, 1}, {9, 1, 2},
          {taco, 2, 1}, {1, 2, huh?}, {"what is this", ":D"},
          {left, up, down, right}, {2B, !2B}, {-_-, 0_o, 42},
          {4th, 5th, 999th}, {blue pill, red pill},
          {Cat, Dog, Catdog}, {Q, T, PI}
      }
  C = {
          A &lt; (B + C * D);
          B != C + D (string concatenation);
          E = {taco if A = 1, 1 otherwise};
          N = {Q if M = cat, T if I = 2B};
          L = {blue pill IFF all other variables = 1st in their set}
      }
</pre>
              <br/>
              <p>...OK so I had a little fun with that last example...</p>
              <p>
                The point being, of course, that what might seem like a simple task of assigning values to variables and checking constraints can quickly become difficult with a lot of variables and
                constraints.
              </p>
              <p>Additionally, we see that not all variable domains need be the same, or even the same type / format.</p>
              <p>So how do we tackle this problem? How do we design intelligent agents to do this?</p>
              
              <br/>
              <h3>Formulating CSP as Search</h3>
              <p>&quot;Oh... we're back to search, Andrew?&quot;</p>
              <p>Yes, stop complaining!</p>
              <p>As it turns out, we can formulate our CSPs as search problems (using a search tree) using the following tactic:</p>
              <p class='definition'>A CSP Search Tree <strong>state</strong> is either a partial or complete instantiation of variables.</p>
              <p class='definition'>A CSP Search Tree <strong>leaf state</strong> is therefore a complete instantiation.</p>
              <p class='definition'>The <strong>initial state</strong> is therefore &quot;no assignment&quot; and each <strong>action</strong> assigns one variable to a value.</p>
              <p class='definition'>A <strong>goal state</strong> is then any complete assignment such that all constraints are satisfied.</p>
              <br/>
              <p>So, let's return to our simple example using numerical variables and algebraic constraints:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/spring-2014/cs-161/week-4/csp-0.PNG' />
              </div>
              <br/>
              <p class='question' name='csp-q0'>What is the depth of this type of CSP tree?</p>
              <p class='answer' name='csp-q0'>Simply the number of variables because it will take |V| actions to reach a complete instantiation!</p>
              
              <br/>
              <h3>Map Coloring Problem</h3>
              <p>Perhaps the most widely used example for CSPs is the map coloring problem.</p>
              <p class='definition'>
                The <strong>map coloring problem</strong> asks if, given a map consisting of a set of states, with some adjacent to others, can you assign one of N colors to each state such that no two
                adjacent states have the same color? (NB: here state means the type you'd find in a country, like California)
              </p>
              <br/>
              <br/>
              <p>Some map coloring solvers will go a step further and ask: &quot;If so, what is the minimum number of colors required to complete this task?&quot;</p>
              <p>Let's formulate this as a constraint satisfaction problem!</p>
              <p class='question' name='csp-q1'>What will a state (here, state means the state in our search tree) look like in our map coloring CSP?</p>
              <p class='answer' name='csp-q1'>The assignment of one of the N colors to each of the variables (representing the map states).</p>
              <br/>
              <p class='question' name='csp-q2'>What will our constraints look like?</p>
              <p class='answer' name='csp-q2'>A set of map-state adjacencies such that no adjacency pair may ever be assigned the same color.</p>
              <br/>
              <p class='example'>What is the minimum N (where N is the number of colors) you could use to color the great Republic of Forns, below?</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/spring-2014/cs-161/week-4/csp-1.PNG' />
              </div>
              <br/>
              <p class='example'>Sketch a search tree for the CSP above, given the minimum N you decided for the map coloring.</p>
              <br/>
              <p class='question' name='csp-q3'>What do we notice about CSP node expansion that will save us some work?</p>
              <p class='answer' name='csp-q3'>As soon as we discover an inconsistency, we need not continue to explore down that path!</p>
              
              <br/>
              <h3>CSP as Local Search</h3>
              <p>Now... what would happen if the proud people of The Republic of Forns all declared independence and separated the states into millions of sovereign bodies?</p>
              <p>Would our CSP search tree for the map coloring problem be tractable?</p>
              <p>Errr... no... millions of variables? Not gonna work...</p>
              <p class='definition'>
                <strong>CSP Local Search</strong> operates under the same principles of classical local search: start off with a random complete instantiation, and then try to tweak erroneous
                assignments into a constraint-consistent solution
              </p>
              <br/>
              <p>So, just as an example using our 5-state map from before, we could arrive at the following partial instantiation for, say, N = 3 colors:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/spring-2014/cs-161/week-4/csp-2.PNG' />
              </div>
              <br/>
              <p class='question' name='csp-q4'>How should we choose which, amongst these adjacent possible solutions, to move to next?</p>
              <p class='answer' name='csp-q4'>
                Define a scoring function that assigns a higher cost to adjacent instantiations that violate more constraints! The lower the cost, the fewer constraints that are violated.
              </p>
              <br/>
              <p class='question' name='csp-q5'>What were some of the improvements we talked about with classical local search that might apply to CSP local search?</p>
              <div class='answer' name='csp-q5'>
                <ul class='indent-1'>
                  <li><p><strong>Random restarts:</strong> if we go too many iterations without finding a solution, just start from scratch with a new starting instantiation.</p></li>
                  <li><p><strong>Sideways movements:</strong> allow movements to instantiations that have the same cost score as the one we're currently investigating.</p></li>
                  <li><p><strong>Downward movements:</strong> 
                    for example, simulated annealing allows some movements to instantiations with *worse* scores than the one we're currently looking at, but is only likely to try one if we've
                    been through many failed iterations prior to the downward movement (i.e., we're more likely to take a downward movement the longer we've been searching)
                  </p></li>
                </ul>
              </div>
              <br/>
              <p>So far, with our search strategies, we've begun our problems under the assumption that we don't know anything about a possible solution...</p>
              <p>In classical search, all we could do was guess with some amount of confidence where in the search tree a solution was likely to be found relative to our initial state...</p>
              <p>With CSPs, we started with blank variable instantiations and tried to find one that satisfied all of our constraints.</p>
              <p>What if we knew some evidence that could direct our search in a more intelligent manner? (FOREBODING!!!)</p>
            </div>
            <hr/>
            
            <br/>
            <div id='propLogic' class='scrollspy-element' scrollspy-title='Propositional Logic'></div>
            <h1>Propositional Logic</h1>
            <div>
              <blockquote class='text-center'>
                <p>&quot;Humans, it seems, know things; and what they know helps them do things.&quot;</p>
                <footer>Our Textbook's Start to Chapter 7</footer>
              </blockquote>
              <br/>
              <p>Some humans really know how to start a textbook chapter!</p>
              <p>What the quote means to express is that human cognition has two important qualities that would be nice to recreate:</p>
              <ul class='indent-1'>
                <li><p>Humans have some sort of <strong>knowledge</strong> representation that spans the breadth of human experience from episodic (event-related) to semantic (factual) memory.</p></li>
                <li><p>Using this knowledge, humans rationalize and perform <strong>inference</strong> from the facts that they know and extrapolate unto the facts that they don't.</p></li>
              </ul>
              <br/>
              <p>For example, if I told you that &quot;If it is raining, then the pavement will be wet. Oh, by the way, it's raining.&quot; What might you infer about the pavement?</p>
              <p>Hopefully, you infer that the pavement is wet! (and that I'm bad at concisely relaying information)</p>
              <p>This is a small gap that humans bridge very easily using reasoning about what they know and what they can infer from what they know.</p>
              <p>Computers, however, need a lot of help with this task; to start our quest to implement a reasoning engine, we'll talk about some definitions:</p>
              <p class='definition'>An intelligent system's <strong>knowledge base (KB)</strong> consists of a set of logical <strong>sentences</strong> that represent some assertions of the world.</p>
              <p class='definition'>A KB's <strong>sentences</strong> are not English sentences so much as they are logical expressions relating some properties of the environment.</p>
              <br/>
              <p>In <strong>Propositional Logic</strong>, a KB's sentences are combinations of boolean variables that express our knowledge about the world.</p>
              <p>So pictorially, our task will be to design an inference engine that takes what we know, questions about what we know, and produce an answer:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/spring-2014/cs-161/week-4/propLog-0.PNG' />
              </div>
              <br/>
              <p>Above, we say that the items that we start off with in our KB are axioms, and the facts that we derived from them are inferred.</p>
              <p class='definition'><strong>Axioms</strong> are the &quot;given&quot; elements of the KB that we assume are true before reasoning; they represent our background knowledge.</p>
              <p class='definition'><strong>Inferred</strong> terms are derived from those initial axioms to extend our knowledge base and answer queries.</p>
              <br/>
              <p class='question' name='propLog-q0'>What are the axioms and derived terms from our example above about whether the sidwalk is wet when it's raining?</p>
              <p class='answer' name='propLog-q0'>
                The axioms are that: (1) If it is raining, then the sidwalk will be wet and (2) it is raining. There is a single derived term: (3) The side walk is wet.
              </p>
              <br/>
              <p>So, we begin to see how to fit the pieces together for our inference engine, but we need a formalization.</p>
              
              <br/>
              <h3>Propositional Syntax</h3>
              <p class='definition'>In propositional logic, we'll represent our knowledge with Boolean variables called <strong>propositions</strong>, i.e., variables that can either be true or false.</p>
<pre class='prettyprint'>
  Boolean variable examples:
  
  Let S = whether or not Andrew's socks are matching today
      H = whether or not it is over 80 degrees out today
      R = whether or not it is raining
      W = whether or not the sidewalk is wet
</pre>
              <br/>
              <p>Thus, every proposition can attain either the value True or False, or T and F as you'll often see them displayed.</p>
              <p>Now, we can build logical sentences comprised of our propositions and logical connectives.</p>
              <p class='definition'>A <strong>logical operator</strong> simply defines some relationship between some number of propositions.</p>
              <div class='definition'><p>Our knowledge representation is therefore composed of:</p>
                <ul class='indent-1'>
                  <li><p><strong>Atoms:</strong> T, F, Prop, &not;Prop, where Prop is some propositional variable.</p></li>
                  <li><p><strong>Sentences:</strong> atoms or atoms used with logical operators: &not;, &or;, &and;, &rArr;</p></li>
                </ul>
              </div>
              <br/>
              <p>Logical operators are defined as follows:</p>
              <p class='toolkit'><strong>Negation (&not;)</strong> is a unary logical operator that flips the Boolean value of a sentence from T to F or from F to T.</p>
<pre class='prettyprint'>
  ; Definition:
  &not;(sentence)
  
  ; Examples:
  &not;T = F
  &not;F = T
  
  ; If Prop = T, then:
  &not;Prop = F
</pre>
              <br/>
              <p class='toolkit'><strong>DeMorgan's Law</strong> (although not strictly a logical operator) is an important aspect of negating non-atom sentences (defined below).</p>
<pre class='prettyprint'>
  ; Definition:
  &not;(prop1 &and; prop2) = (&not;prop1) &or; (&not;prop2)
  &not;(prop1 &or; prop2) = (&not;prop1) &and; (&not;prop2)
  
  ; Examples:
  &not;(T &and; F)
    = (&not;T) &or; (&not;F)
    = (F) &or; (T)
    = T
</pre>
              <br/>
              <p class='toolkit'><strong>Conjunction (&and;)</strong> AKA &quot;and&quot; is a binary operator that returns T only if the sentence on its left AND right are T.</p>
<pre class='prettyprint'>
  ; Definition:
  (sentence1) &and; (sentence2)
  
  ; Examples:
  T &and; F = F
  T &and; T = T
  (T &and; F) &and; T = F
  Prop1 &and; Prop2 &and; Prop3
</pre>
              <br/>
              <p class='toolkit'><strong>Disjunction (&or;)</strong> AKA &quot;or&quot; is a binary operator that returns T if at least one of the sentences on its left OR right is T.</p>
<pre class='prettyprint'>
  ; Definition:
  (sentence1) &or; (sentence2)
  
  ; Examples:
  T &or; F = T
  T &or; T = T
  (T &or; F) &or; F = T
  F &or; F = F
  Prop1 &or; Prop2 &or; Prop3
</pre>
              <br/>
              <p class='toolkit'><strong>Implication (&rArr;)</strong> is a logical shorthand indicating an if-then relationship between sentences.</p>
<pre class='prettyprint'>
  ; Definition:
  (sentence1) &rArr; (sentence2)
  ; ...is shorthand for:
  &not;(sentence1) &or; (sentence2)
  
  ; Examples:
  F &rArr; F
    = &not;F &or; F
    = T &or; F
    = T
</pre>
              <br/>
              <p class='toolkit'><strong>If-and-only-if (&hArr;)</strong> is a logical shorthand indicating if-then relationships of the format: (if A then B) AND (if B then A).</p>
<pre class='prettyprint'>
  ; Definition:
  (sentence1) &hArr; (sentence2)
  ; ...is shorthand for:
  ((sentence1) &rArr; (sentence2)) &and; ((sentence2) &rArr; (sentence1))
</pre>
              <br/>
              <p>Alright, so now that we have the tools at our disposal, we can talk about the semantics of propositional logic.</p>
              
              <br/>
              <h3>Propositional Semantics</h3>
              <p>Since we're dealing with propositions, which are Boolean variables, then we can imagine our variables describing a scenario by being instantiated to either T or F.</p>
              <p>Let's say we returned to the example of rain and the sidewalk. I'll define two propositions:</p>
<pre class='prettyprint'>
  Let R = whether or not it's raining
      S = whether or not the sidewalk is wet
</pre>
              <br/>
              <p>The fact that I have two propositional variables of interest mean that I have 4 possible worlds consisting of:</p>
              <table class='table table-striped table-bordered'>
                <thead>
                  <tr>
                    <th><p>R</p></th>
                    <th><p>S</p></th>
                    <th><p>Interpretation of (R &and; S)</p></th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><p>F</p></td>
                    <td><p>F</p></td>
                    <td><p>It isn't raining and the sidewalk isn't wet</p></td>
                  </tr>
                  <tr>
                    <td><p>F</p></td>
                    <td><p>T</p></td>
                    <td><p>It isn't raining but the sidewalk IS wet</p></td>
                  </tr>
                  <tr>
                    <td><p>T</p></td>
                    <td><p>F</p></td>
                    <td><p>It IS raining, but the sidewalk isn't wet</p></td>
                  </tr>
                  <tr>
                    <td><p>T</p></td>
                    <td><p>T</p></td>
                    <td><p>It IS raining, and the sidewalk IS wet</p></td>
                  </tr>
                </tbody>
              </table>
              
              <br/>
              <p class='question' name='propLog-q00'>In general, then, if I have N propositional variables, how many possible worlds will I have?</p>
              <p class='answer' name='propLog-q00'>
                2^N, since every additional variable creates 2 new worlds for all worlds in the truth table with (N - 1) variables
              </p>
              <br/>
              <p>Now, let's say I observed some facts about my environment and also knew some background knowledge that are relevant to my observations.</p>
              <p class='example'>Convert the following English sentences into propositional logic sentences:</p>
<pre class='prettyprint'>
  Let R = whether or not it's raining
      S = whether or not the sidewalk is wet
      
  ;; #1
  &quot;If it is raining, then the sidewalk will be wet.&quot;
  
  ;; #2
  &quot;It is raining.&quot;
  
  ;; #3
  &quot;It is NOT raining.&quot;
</pre>
              
              <br/>
              <p>OK, so let's say that I observe the following: &quot;If it is raining, then the sidewalk will be wet. It is raining.&quot;</p>
              <p class='question' name='propLog-q1'>How can I phrase this observation as a conjunctive sentence?</p>
              <p class='answer' name='propLog-q1'>
                (R &rArr; S) &and; R<br/>
                = (&not;R &or; S) &and; R
              </p>
              <br/>
              <p>Knowing these facts about my environment, and also the set of all 4 possible worlds over instantiation combinations of R and S, I can ask if a world is consistent with my observations.</p>
              <p class='definition'>
                Formally, we say that for some logical sentence &alpha;, a world is a <strong>model</strong> of that sentence if &alpha; is true given the instantiations of variables in that world.
              </p>
              <p class='toolkit'>We use the notation M(&alpha;) to indicate the set of all models of &alpha;; this is referred to as the <strong>meaning</strong> of &alpha;</p>
              <br/>
              <p>So, for our example, if &alpha; = (&not;R &or; S) &and; R = &quot;If it is raining, then the sidewalk will be wet. It is raining.&quot;</p>
              <p>...then M(&alpha;) = the set of all worlds consistent with (&not;R &or; S) &and; R</p>
              <p>Let's look again at our truth table:</p>
              <table class='table table-striped table-bordered'>
                <thead>
                  <tr>
                    <th><p>World</p></th>
                    <th><p>R</p></th>
                    <th><p>S</p></th>
                    <th><p>&alpha; = (&not;R &or; S) &and; R</p></th>
                    <th><p>Model of &alpha;?</p></th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td><p>W1</p></td>
                    <td><p>F</p></td>
                    <td><p>F</p></td>
                    <td><p>(&not;F &or; F) &and; F = F</p></td>
                    <td><p>No</p></td>
                  </tr>
                  <tr>
                    <td><p>W2</p></td>
                    <td><p>F</p></td>
                    <td><p>T</p></td>
                    <td><p>(&not;F &or; T) &and; F = F</p></td>
                    <td><p>No</p></td>
                  </tr>
                  <tr>
                    <td><p>W3</p></td>
                    <td><p>T</p></td>
                    <td><p>F</p></td>
                    <td><p>(&not;T &or; F) &and; T = F</p></td>
                    <td><p>No</p></td>
                  </tr>
                  <tr>
                    <td><p>W4</p></td>
                    <td><p>T</p></td>
                    <td><p>T</p></td>
                    <td><p>(&not;T &or; T) &and; T = T</p></td>
                    <td><p>Yes!</p></td>
                  </tr>
                </tbody>
              </table>
              <br/>
              <p>So, since W4 is the only model of our sentence &alpha;, then we say M(&alpha;) = { W4 }</p>
              <p>We can derive a few interesting set properties of models based on some atoms and sentence formats:</p>
              <p>First, some notational specifications:</p>
              <ul class='indent-1'>
                <li><p><strong>W</strong> (uppercase, bolded) is the set of all worlds.</p></li>
                <li><p>w (lowercase, unbolded) is one world in <strong>W</strong>.</p></li>
                <li><p>The notation w.Prop for some given propositional variable Prop is the instantiation of Prop in world w.</p></li>
              </ul>
              <br/>
              <p>For atoms, we have the following properties:</p>
              <ul class='indent-1'>
                <li><p>M(True) = <strong>W</strong></p></li>
                <li><p>M(False) = &empty;</p></li>
                <li><p>M(Prop) = { w &sube; <strong>W</strong> | w.Prop = T }<br/>&quot;The set of all worlds in W such that each world w in the set has instantiation Prop = T&quot;</p></li>
                <li><p>M(&not;Prop) = { w &sube; <strong>W</strong> | w.Prop = F }<br/>&quot;The set of all worlds in W such that each world w in the set has instantiation Prop = F&quot;</p></li>
              </ul>
              <br/>
              <p>For sentences, we have the following properties:</p>
              <ul class='indent-1'>
                <li><p><strong>Intersection:</strong> M(&alpha; &and; &beta;) = M(&alpha;) &cap; M(&beta;)</p></li>
                <li><p><strong>Union:</strong> M(&alpha; &or; &beta;) = M(&alpha;) &cup; M(&beta;)</p></li>
                <li><p><strong>Subtraction:</strong> M(&not;&alpha;) = <strong>W</strong> \ M(&alpha;)</p></li>
              </ul>
              
              <br/>
              <p>There a couple of accompanying definitions with propositional models where we interpret M(&alpha;) as the *meaning* of &alpha;</p>
              <p class='definition'>If M(&alpha;) = <strong>W</strong>, then we say that &alpha; is <strong>valid</strong>.</p>
              <p class='example'>Are the following sentences over worlds for variables S and R valid? If not, give an instantiation that is inconsistent with &alpha;</p>
<pre class='prettyprint'>
  ;; #1
  &alpha; = S &or; &not;S
  
  ;; #2
  &alpha; = S &and; &not;S
  
  ;; #3
  &alpha; = S &or; (&not;S &and; R)
</pre>
              <br/>
              <p class='definition'>If M(&alpha;) = &empty;, then we say that &alpha; is <strong>inconsistent</strong>.</p>
              <p class='example'>Are the following sentences over worlds for variables S and R inconsistent? If not, give an instantiation that is consistent with &alpha;</p>
<pre class='prettyprint'>
  ;; #1
  &alpha; = S &or; &not;S
  
  ;; #2
  &alpha; = S &and; &not;S
  
  ;; #3
  &alpha; = S &or; (&not;S &and; R)
</pre>
              <br/>
              <p class='definition'>If M(&alpha;) &ne; &empty;, then we say that &alpha; is <strong>consistent</strong>.</p>
              <p class='example'>Are the following sentences over worlds for variables S and R consistent?</p>
<pre class='prettyprint'>
  ;; #1
  &alpha; = S &or; &not;S
  
  ;; #2
  &alpha; = S &and; &not;S
  
  ;; #3
  &alpha; = S &or; (&not;S &and; R)
</pre>
              <br/>
              <p>We also have some sentence properties over pairs of sentences &alpha; and &beta;:</p>
              <p class='definition'>If M(&alpha;) &sube; M(&beta;), then we say that &alpha; <strong>entails</strong> &beta;, written &alpha; &#8872; &beta;.</p>
              <br/>
              <p>
                Another way of thinking about this is that all of the worlds consistent with &alpha; are also consistent with &beta; such that we know whenever some world w &#8872; &alpha;, then
                that same world w &#8872; &beta;.
              </p>
              <p>That said, we are NOT guaranteed that every world consistent with &beta; is consistent with &alpha;</p>
              <p class='example'>Does &alpha; entail &beta; in the following examples? If not, provide a world where &alpha; is consistent but &beta; isn't.</p>
<pre class='prettyprint'>
  ;; #1
  &alpha; = S
  &beta; = R
  
  ;; #2
  &alpha; = &not;R &and; (S &or; R)
  &beta; = S
</pre>
              <br/>
              <p class='definition'>If M(&alpha;) &sube; M(&beta;) AND M(&beta;) &sube; M(&alpha;), then we say that &alpha; and &beta; are <strong>equivalent</strong></p>
              <br/>
              <p>
                Another way of thinking about this is that all of the worlds consistent with &alpha; are also consistent with &beta; AND all worlds consistent with &beta; are also consistent with
                &alpha;
              </p>
              <p class='example'>Is &alpha; = &beta; in the following sentences?</p>
<pre class='prettyprint'>
  ;; #1
  &alpha; = S
  &beta; = R
  
  ;; #2
  &alpha; = &not;R &and; (S &or; R)
  &beta; = S
  
  ;; #3
  &alpha; = &not;R &and; (S &or; R)
  &beta; = &not;R &and; S
</pre>
              
              <br/>
              <h3>Formalizing the Knowledge Base</h3>
              <p>OK, so we've got our propositional logic syntax and semantics down... let's apply them to an intelligent reasoning system!</p>
              <p>Our quest begins by defining a knowledge base:</p>
              <p class='definition'>A <strong>propositional knowledge base (KB)</strong> is a conjunction of sentences that entails a set of possible worlds.</p>
              <br/>
              <p>In other words, if M(KB) = <strong>W'</strong>, then <strong>W'</strong> &sube; <strong>W</strong></p>
              <p>To illustrate this, let's expand on our previous example to include a new variable, L = &quot;The light from the sun is shining.&quot;</p>
              <p class='example'>Convert the sentences about variables S, L, and R into propositional sentences, and then form the KB:</p>
<pre class='prettyprint'>
  Let R = whether or not it's raining
      S = whether or not the sidewalk is wet
      L = whether or not the sunlight is shining
      
  ;; #1
  sent1 = &quot;If the sunlight is shining, then it is not raining.&quot;
  
  ;; #2
  sent2 = &quot;If it is not raining, then the sidewalk is dry.&quot;
  
  ;; #3
  sent3 = &quot;The sunlight is shining.&quot;
  
  ;; #4:
  KB = The conjunction of all of our sentences
     = sent1 &and; sent2 &and; sent3
</pre>
              <br/>
              <p>OK, now that we have our knowledge base, the goal of the system is to prove certain facts about what we know.</p>
              <p>We'll do this by illustrating that for some query sentence &alpha;, we will determine whether or not our KB &#8872; &alpha;</p>
              <p>However, since it is difficult to show that, for all worlds a KB satisfies, &alpha; is also satisfied, we'll use a clever trick:</p>
              <p class='definition'>
                <strong>Refutation</strong> AKA proof by contradiction, is an inference strategy whereby for query sentence &alpha;, we say KB &#8872; &alpha; IFF M(KB &and; &not;&alpha;) = &empty;
              </p>
              <br/>
              <p>&quot;Ugh... maths...&quot; you might remark.</p>
              <p>But it's really quite intuitive! Let's translate refutation inference into English:</p>
              <p class='toolkit'>
                Refutation says, &quot;Add the *opposite* of my query to the Knowledge Base, and if it makes the KB inconsistent, then I know my query had to have been entailed in the first place!&quot;
              </p>
              <br/>
              <p>Before we can use refutation, we first need to learn some inference rules.</p>
              
              <br/>
              <h3>Inference Rules</h3>
              <p>Think about what &quot;inference&quot; means... that is, what it means when you infer something?</p>
              <p>It means you take the information you know, and then make an assertion based on that information to what you haven't observed.</p>
              <p>In the context of a knowledge base, inference rules define semantics to take the sentences of a KB and then return a NEW sentence that is entailed by the KB!</p>
              <p>The first inference rule is called Modus Ponens:</p>
              <div class='definition'><p><strong>Modus Ponens</strong> is an inference rule defined as:</p>
                <div class='row'>
                  <div class='col-md-2 text-center'>
                    <h3>&alpha; &#8872; &beta;; &alpha;</h3>
                    <hr>
                    <h3>&beta;</h3>
                  </div>
                </div>
              </div>
              <br/>
              <p>Frankly, I find this syntactic definition to be one of the worst known to man; let's unpack it:</p>
              <p>Modus Ponens says, &quot;If &alpha; entails &beta; in my KB, and I also have &alpha; somewhere in my KB (by itself), then I'm allowed to add &beta; (by itself) to the knowledge base.&quot;</p>
              <p>Another, more friendly formulation is that if you ever have two sentence structures in your KB: (sent1 &rArr; sent2) &and; sent1, then you can add sent3 = sent2</p>
              <p>So, for example, if I have the following sentences, sent1 and sent2 in my KB, I can use modus ponens to infer sent3:</p>
<pre class='prettyprint'>
  ;; Assume sent1 and sent2 are in KB
  
  ;; #1
  sent1 = (R &rArr; S)
        = (&not; R &or; S)
  sent2 = R
  
  ; Since, in our definition for Modus Ponens,
  ; &alpha; = R and &beta; = S, then I can infer:
  sent 3 = S
  
  
  ;; #2
  sent1 = ((R &rArr; S) &rArr; &not;R)
  sent2 = (R &rArr; S)
  
  ; Since, in our definition for Modus Ponens,
  ; &alpha; = (R &rArr; S) and &beta; = &not;R, then I can infer:
  sent3 = &not;R
</pre>
              <br/>
              <p>The second inference rule is called Resolution:</p>
              <div class='definition'><p><strong>Resolution</strong> is an inference rule defined as:</p>
                <p>For any two sentences X and Y with propositions x_i and y_i of the format: X = x1 &or; x2 &or; ... &or; xn; Y = y1 &or; y2 &or; ... &or; yn</p>
                <p>If X and Y contain some propositional variable Z such that Z &isin; X AND &not;Z &isin; Y, then we can combine the two sentences on everything except the disagreement on Z such that:</p>
                <div class='row'>
                  <div class='col-md-10 text-center'>
                    <h3>x1 &or; x2 &or; Z &or; ... &or; xn; y1 &or; y2 &or; &not;Z &or; ... &or; yn</h3>
                    <hr>
                    <h3>x1 &or; x2 &or; ... &or; xn &or; y1 &or; y2 &or; ... &or; yn</h3>
                  </div>
                </div>
                <p>In other words, we're allowed to infer the sentence composed of all disjoined propositions of X and Y *except* for element Z.</p>
              </div>
            </div>
            <hr/>
            
            <a class='btn btn-default pull-right hidden-print' href='javascript:window.print();'>
              <span class='glyphicon glyphicon-print'></span>
              &nbsp; PDF / Print
            </a>
            
          </div>
          <!-- END PRESENTATION CONTENT -->
          
          <!-- MATERIALS FROM CLASS: -->
          
          <!-- TODO: Constraint satisfaction problems -->
          <!-- TODO: Propositional Logic -->
          <!-- TODO: First-order Logic -->
            
        </div>
      </div>
      <!-- END MAIN CONTENT -->
      
      
    </div>
    <!-- END WRAPPER -->
    
    <!-- BEGIN FOOTER -->
    <div id="footer">
      <div class="container">
        <div class="col-md-12 text-center">
          
        </div>
      </div>
    </div>
    <!-- END FOOTER -->
    
  </body>
</html>
