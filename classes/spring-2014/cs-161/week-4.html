
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

  <head>
    <title>Andrew Forney - UCLA CS</title>
    <link href="../../../css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../../../css/magic-bootstrap.css" rel="stylesheet" type="text/css">
    <link href="../../../css/main.css" rel="stylesheet" type="text/css">
    <script src="../../../js/lib/jquery-2.0.3.min.js"></script>
    <script src="../../../js/lib/bootstrap.min.js"></script>
    <script src="../../../js/lib/expanding.js"></script>
    <script src="../../../js/display/general/general-display.js"></script>
    <script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
  </head>
  
  <body data-spy="scroll" data-target="#scrollspy">
    
    <!-- BEGIN WRAP -->
    <div id="wrap">
      
      <!-- BEGIN NAVIGATION -->
      <nav class='navbar navbar-default' role='navigation'>
        <div class='nav-accent'></div>
        <div class='container'>
          <div class='row'>
            <div class='col-md-12'>
              <div class='navbar-header'>
                <button class='navbar-toggle' type='button' data-toggle='collapse' data-target='.navbar-main-collapse'>
                  <span class='sr-only'>Toggle Navigation</span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                  <span class='icon-bar'></span>
                </button>
                <a class='navbar-brand' href='/~forns/'>
                  <span id='brand-text'>
                    Andrew Forney
                  </span>
                </a>
              </div>
              
              <div id='nav-main' class='collapse navbar-collapse navbar-main-collapse'>
                <ul class='nav navbar-nav navbar-right'>
                  
                  <li>
                    <a href='/~forns/about.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-user'></span>
                      </div>
                      <p class='text-center'>About</p>
                    </a>
                  </li>
                  
                  <li class='active'>
                    <a href='/~forns/classes.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-book'></span>
                      </div>
                      <p class='text-center'>Classes</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/contact.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-comment'></span>
                      </div>
                      <p class='text-center'>Contact</p>
                    </a>
                  </li>
                  
                  <li>
                    <a href='/~forns/publications.html'>
                      <div class='text-center'>
                        <span class='glyphicon glyphicon-file'></span>
                      </div>
                      <p class='text-center'>Publications</p>
                    </a>
                  </li>
                  
                </ul>
              </div>
            </div>
          </div>
        </div>
      </nav>
      <!-- END NAVIGATION -->
      
      <!-- BEGIN MAIN CONTENT -->
      <div id="main-content" class="container">
        <div class="row">
          
          <!-- BEGIN SCROLLSPY -->
          <div class='col-md-2 hidden-sm hidden-xs'>
            <div class="bs-sidebar hidden-print affix" role="complementary">
              <ul id='scrollspy' class="nav bs-sidenav">
              </ul>
            </div>
          </div>
          <!-- END SCROLLSPY -->
          
          <!-- BEGIN PRESENTATION CONTENT -->
          <div class='col-md-10 presentation-content' role='main'>
            
            <ol class="breadcrumb hidden-print">
              <li><a href="../../../classes.html">Classes</a></li>
              <li><a href="./cs-161.html">Spring14 CS161</a></li>
              <li class="active">Week 4</li>
            </ol>
            
            <div id='constraintSat' class='scrollspy-element' scrollspy-title='Constraint Satisfaction'></div>
            <h1>Constraint Satisfaction Problems</h1>
            <div>
              <p>So we've been talking about classical search in something of a &quot;black-box&quot; fashion, meaning we have knowledge about states, transitions, and tests for goal states, but...</p>
              <p>...our search algorithms have treated states as atomic; there are no internal variables for us to wiggle and try to fix something that's wrong with a state and try to make it right.</p>
              <p class='definition'><strong>Constraint satisfaction problems (CSPs)</strong> use general purpose heuristic algorithms to try to find a solution using a set of variables and constraints.</p>
              <br/>
              <p>What does this mean?</p>
              <p>With CSPs, we define our states as consisting of a variety of variables that we then individually check against a variety of constraints.</p>
              <p>If our variable <strong>assignments</strong> in a given state are all <strong>consistent</strong> with our constraints, then we say that we've found a solution!</p>
              <p class='definition'>A CSP <strong>variable (X)</strong> is defined in terms of its <strong>domains (D)</strong>, such that a variable X_i can only attain a value in D_i in any given state.</p>
              <p class='definition'>A CSP <strong>constaint (C)</strong> is a Boolean condition for success on some variable instantiation.</p>
              <br/>
              <p>Therefore, we can phrase all of our constraint satisfaction problems as consisting of:</p>
              <ul class='indent-1'>
                <li><p>X: a set of variables {X_1, X_2, ..., X_n}</p></li>
                <li><p>D: a set of domains for those variables {D_1, D_2, ..., D_n} (one for each variable)</p></li>
                <li><p>C: a set of Boolean constraints that tell us when we've found a solution with our variables</p></li>
              </ul>
              <br/>
              <p class='debug'>NOTE: We've only found a solution whenever all of our constraints are satisfied, and every variable has been assigned a value from its respective domains!</p>
              <br/>
              <p>Later, however, we'll look at how knowing how many constraints we've failed can steer us in the right direction to a solution...</p>
              <p>This gives us a comparison between classical search and CSPs:</p>
              <table class='table table-striped table-bordered'>
                <caption>Classical Search vs. CSP</caption>
                <thead>
                  <tr>
                    <th><p>Property</p></th>
                    <th><p>Classical Search</p></th>
                    <th><p>CSP</p></th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <th><p>States</p></th>
                    <td><p>Problem-specific and atomic; cannot be divided into constituent components.</p></td>
                    <td><p>Variables, Domains, and Constraints</p></td>
                  </tr>
                  <tr>
                    <th><p>Success</p></th>
                    <td><p>Test a state to see if it meets our goal condition.</p></td>
                    <td><p>Assign values to all variables and see if that assignment meets all constraints</p></td>
                  </tr>
                  <tr>
                    <th><p>Cares about...</p></th>
                    <td><p>...the path from an initial state to a goal state</p></td>
                    <td><p>...an instantiation of variables that meets all constraints; path is irrelevant!</p></td>
                  </tr>
                  <tr>
                    <th><p>Applications</p></th>
                    <td><p>Pathfinding, optimization, etc.</p></td>
                    <td><p>SAT(isfiability), map coloring, scheduling, etc.</p></td>
                  </tr>
                </tbody>
              </table>
              <br/>
              <p>So, the motto of CSP might be, &quot;I don't know what I'm looking for, but I'll know it when I see it! ...oh and I don't care about how I got there.&quot;</p>
              <p>Let's look at some simple examples using numerical variables and algebraic constriants.</p>
              <p class='example'>Consider the following constraint satisfaction problem specifications and find a solution for each.</p>
<pre class='prettyprint'>
  X = {A, B}
  D = { {1, 2}, {0, -1} }
  
  #1
  C = { A &lt; B; A * B &gt;= 0 }
  
  #2
  C = { A &gt; B; A * B &gt;= 0 }
  
  #3
  C = { A &gt; 0 }
  
  
  
  OK... Now that we're done with the warmups...
  
  #4
  X = {A, B, C, D, E, F, G, H, I, J, K, L, M, N}
  D = {
          {1, 2, 3}, {6, 7, 22}, {2, 9, 1}, {9, 1, 2},
          {taco, 2, 1}, {1, 2, huh?}, {"what is this", ":D"},
          {left, up, down, right}, {2B, !2B}, {-_-, 0_o, 42},
          {4th, 5th, 999th}, {blue pill, red pill},
          {Cat, Dog, Catdog}, {Q, T, PI}
      }
  C = {
          A &lt; (B + C * D);
          B != C + D (string concatenation);
          E = {taco if A = 1, 1 otherwise};
          N = {Q if M = cat, T if I = 2B};
          L = {blue pill IFF all other variables = 1st in their set}
      }
</pre>
              <br/>
              <p>...OK so I had a little fun with that last example...</p>
              <p>
                The point being, of course, that what might seem like a simple task of assigning values to variables and checking constraints can quickly become difficult with a lot of variables and
                constraints.
              </p>
              <p>Additionally, we see that not all variable domains need be the same, or even the same type / format.</p>
              <p>So how do we tackle this problem? How do we design intelligent agents to do this?</p>
              
              <br/>
              <h3>Formulating CSP as Search</h3>
              <p>&quot;Oh... we're back to search, Andrew?&quot;</p>
              <p>Yes, stop complaining!</p>
              <p>As it turns out, we can formulate our CSPs as search problems (using a search tree) using the following tactic:</p>
              <p class='definition'>A CSP Search Tree <strong>state</strong> is either a partial or complete instantiation of variables.</p>
              <p class='definition'>A CSP Search Tree <strong>leaf state</strong> is therefore a complete instantiation.</p>
              <p class='definition'>The <strong>initial state</strong> is therefore &quot;no assignment&quot; and each <strong>action</strong> assigns one variable to a value.</p>
              <p class='definition'>A <strong>goal state</strong> is then any complete assignment such that all constraints are satisfied.</p>
              <br/>
              <p>So, let's return to our simple example using numerical variables and algebraic constraints:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/spring-2014/cs-161/week-4/csp-0.PNG' />
              </div>
              <br/>
              <p class='question' name='csp-q0'>What is the depth of this type of CSP tree?</p>
              <p class='answer' name='csp-q0'>Simply the number of variables because it will take |V| actions to reach a complete instantiation!</p>
              
              <br/>
              <h3>Map Coloring Problem</h3>
              <p>Perhaps the most widely used example for CSPs is the map coloring problem.</p>
              <p class='definition'>
                The <strong>map coloring problem</strong> asks if, given a map consisting of a set of states, with some adjacent to others, can you assign one of N colors to each state such that no two
                adjacent states have the same color? (NB: here state means the type you'd find in a country, like California)
              </p>
              <br/>
              <br/>
              <p>Some map coloring solvers will go a step further and ask: &quot;If so, what is the minimum number of colors required to complete this task?&quot;</p>
              <p>Let's formulate this as a constraint satisfaction problem!</p>
              <p class='question' name='csp-q1'>What will a state (here, state means the state in our search tree) look like in our map coloring CSP?</p>
              <p class='answer' name='csp-q1'>The assignment of one of the N colors to each of the variables (representing the map states).</p>
              <br/>
              <p class='question' name='csp-q2'>What will our constraints look like?</p>
              <p class='answer' name='csp-q2'>A set of map-state adjacencies such that no adjacency pair may ever be assigned the same color.</p>
              <br/>
              <p class='example'>What is the minimum N (where N is the number of colors) you could use to color the great Republic of Forns, below?</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/spring-2014/cs-161/week-4/csp-1.PNG' />
              </div>
              <br/>
              <p class='example'>Sketch a search tree for the CSP above, given the minimum N you decided for the map coloring.</p>
              <br/>
              <p class='question' name='csp-q3'>What do we notice about CSP node expansion that will save us some work?</p>
              <p class='answer' name='csp-q3'>As soon as we discover an inconsistency, we need not continue to explore down that path!</p>
              
              <br/>
              <h3>CSP as Local Search</h3>
              <p>Now... what would happen if the proud people of The Republic of Forns all declared independence and separated the states into millions of sovereign bodies?</p>
              <p>Would our CSP search tree for the map coloring problem be tractable?</p>
              <p>Errr... no... millions of variables? Not gonna work...</p>
              <p class='definition'>
                <strong>CSP Local Search</strong> operates under the same principles of classical local search: start off with a random complete instantiation, and then try to tweak erroneous
                assignments into a constraint-consistent solution
              </p>
              <br/>
              <p>So, just as an example using our 5-state map from before, we could arrive at the following partial instantiation for, say, N = 3 colors:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/spring-2014/cs-161/week-4/csp-2.PNG' />
              </div>
              <br/>
              <p class='question' name='csp-q4'>How should we choose which, amongst these adjacent possible solutions, to move to next?</p>
              <p class='answer' name='csp-q4'>
                Define a scoring function that assigns a higher cost to adjacent instantiations that violate more constraints! The lower the cost, the fewer constraints that are violated.
              </p>
              <br/>
              <p class='question' name='csp-q5'>What were some of the improvements we talked about with classical local search that might apply to CSP local search?</p>
              <div class='answer' name='csp-q5'>
                <ul class='indent-1'>
                  <li><p><strong>Random restarts:</strong> if we go too many iterations without finding a solution, just start from scratch with a new starting instantiation.</p></li>
                  <li><p><strong>Sideways movements:</strong> allow movements to instantiations that have the same cost score as the one we're currently investigating.</p></li>
                  <li><p><strong>Downward movements:</strong> 
                    for example, simulated annealing allows some movements to instantiations with *worse* scores than the one we're currently looking at, but is only likely to try one if we've
                    been through many failed iterations prior to the downward movement (i.e., we're more likely to take a downward movement the longer we've been searching)
                  </p></li>
                </ul>
              </div>
              <br/>
              <p>So far, with our search strategies, we've begun our problems under the assumption that we don't know anything about a possible solution...</p>
              <p>In classical search, all we could do was guess with some amount of confidence where in the search tree a solution was likely to be found relative to our initial state...</p>
              <p>With CSPs, we started with blank variable instantiations and tried to find one that satisfied all of our constraints.</p>
              <p>What if we knew some evidence that could direct our search in a more intelligent manner? (FOREBODING!!!)</p>
            </div>
            <hr/>
            
            <br/>
            <div id='propLogic' class='scrollspy-element' scrollspy-title='Propositional Logic'></div>
            <h1>Propositional Logic</h1>
            <div>
              <blockquote class='text-center'>
                <p>&quot;Humans, it seems, know things; and what they know helps them do things.&quot;</p>
                <footer>Our Textbook's Start to Chapter 7</footer>
              </blockquote>
              <br/>
              <p>Some humans really know how to start a textbook chapter!</p>
              <p>What the quote means to express is that human cognition has two important qualities that would be nice to recreate:</p>
              <ul class='indent-1'>
                <li><p>Humans have some sort of <strong>knowledge</strong> representation that spans the breadth of human experience from episodic (event-related) to semantic (factual) memory.</p></li>
                <li><p>Using this knowledge, humans rationalize and perform <strong>inference</strong> from the facts that they know and extrapolate unto the facts that they don't.</p></li>
              </ul>
              <br/>
              <p>For example, if I told you that &quot;If it is raining, then the pavement will be wet. Oh, by the way, it's raining.&quot; What might you infer about the pavement?</p>
              <p>Hopefully, you infer that the pavement is wet! (and that I'm bad at concisely relaying information)</p>
              <p>This is a small gap that humans bridge very easily using reasoning about what they know and what they can infer from what they know.</p>
              <p>Computers, however, need a lot of help with this task; to start our quest to implement a reasoning engine, we'll talk about some definitions:</p>
              <p class='definition'>An intelligent system's <strong>knowledge base (KB)</strong> consists of a set of logical <strong>sentences</strong> that represent some assertions of the world.</p>
              <p class='definition'>A KB's <strong>sentences</strong> are not English sentences so much as they are logical expressions relating some properties of the environment.</p>
              <br/>
              <p>In <strong>Propositional Logic</strong>, a KB's sentences are combinations of boolean variables that express our knowledge about the world.</p>
              <p>So pictorially, our task will be to design an inference engine that takes what we know, questions about what we know, and produce an answer:</p>
              <div class='text-center fit-pres'>
                <img src='../../../assets/images/spring-2014/cs-161/week-4/propLog-0.PNG' />
              </div>
              <br/>
              <p>Above, we say that the items that we start off with in our KB are axioms, and the facts that we derived from them are inferred.</p>
              <p class='definition'><strong>Axioms</strong> are the &quot;given&quot; elements of the KB that we assume are true before reasoning; they represent our background knowledge.</p>
              <p class='definition'><strong>Inferred</strong> terms are derived from those initial axioms to extend our knowledge base and answer queries.</p>
              <br/>
              <p class='question' name='propLog-q0'>What are the axioms and derived terms from our example above about whether the sidwalk is wet when it's raining?</p>
              <p class='answer' name='propLog-q0'>
                The axioms are that: (1) If it is raining, then the sidwalk will be wet and (2) it is raining. There is a single derived term: (3) The side walk is wet.
              </p>
              <br/>
              <p>So, we begin to see how to fit the pieces together for our inference engine, but we need a formalization.</p>
              
              <br/>
              <h3>Propositional Syntax</h3>
              <p class='definition'>In propositional logic, we'll represent our knowledge with Boolean variables called <strong>propositions</strong>, i.e., variables that can either be true or false.</p>
<pre class='prettyprint'>
  Boolean variable examples:
  
  Let S = whether or not Andrew's socks are matching today
      H = whether or not it is over 80 degrees out today
      R = whether or not it is raining
      W = whether or not the sidewalk is wet
</pre>
              <br/>
              <p>Thus, every proposition can attain either the value True or False, or T and F as you'll often see them displayed.</p>
              <p>Now, we can build logical sentences comprised of our propositions and logical connectives.</p>
              <p class='definition'>A <strong>logical operator</strong> simply defines some relationship between some number of propositions.</p>
              <div class='definition'><p>Our knowledge representation is therefore composed of:</p>
                <ul class='indent-1'>
                  <li><p><strong>Atoms:</strong> T, F, Prop, &not;Prop, where Prop is some propositional variable.</p></li>
                  <li><p><strong>Sentences:</strong> atoms or atoms used with logical operators: &not;, &or;, &and;, &rArr;</p></li>
                </ul>
              </div>
              <br/>
              <p>Logical operators are defined as follows:</p>
              <p class='toolkit'><strong>Negation (&not;)</strong> is a unary logical operator that flips the Boolean value of a sentence from T to F or from F to T.</p>
<pre class='prettyprint'>
  ; Definition:
  &not;(sentence)
  
  ; Examples:
  &not;T = F
  &not;F = T
  
  ; If Prop = T, then:
  &not;Prop = F
</pre>
              <br/>
              <p class='toolkit'><strong>Conjunction (&and;)</strong> AKA &quot;and&quot; is a binary operator that returns T only if the sentence on its left AND right are T.</p>
<pre class='prettyprint'>
  ; Definition:
  (sentence1) &and; (sentence2)
  
  ; Examples:
  T &and; F = F
  T &and; T = T
  (T &and; F) &and; T = F
  Prop1 &and; Prop2 &and; Prop3
</pre>
              <br/>
              <p class='toolkit'><strong>Disjunction (&or;)</strong> AKA &quot;or&quot; is a binary operator that returns T if at least one of the sentences on its left OR right is T.</p>
<pre class='prettyprint'>
  ; Definition:
  (sentence1) &or; (sentence2)
  
  ; Examples:
  T &or; F = T
  T &or; T = T
  (T &or; F) &or; F = T
  F &or; F = F
  Prop1 &or; Prop2 &or; Prop3
</pre>
              <br/>
              <p class='toolkit'><strong>Implication (&rArr;)</strong> is a logical shorthand indicating an if-then relationship between sentences.</p>
<pre class='prettyprint'>
  ; Definition:
  (sentence1) &rArr; (sentence2)
  ; ...is shorthand for:
  &not;(sentence1) &or; (sentence2)
  
  ; Examples:
  F &rArr; F
    = &not;F &or; F
    = T &or; F
    = T
</pre>
              <br/>
              <p class='toolkit'><strong>If-and-only-if (&hArr;)</strong> is a logical shorthand indicating if-then relationships of the format: (if A then B) AND (if B then A).</p>
<pre class='prettyprint'>
  ; Definition:
  (sentence1) &hArr; (sentence2)
  ; ...is shorthand for:
  ((sentence1) &rArr; (sentence2)) &and; ((sentence2) &rArr; (sentence1))
</pre>
              <br/>
            </div>
            <hr/>
            
            <a class='btn btn-default pull-right hidden-print' href='javascript:window.print();'>
              <span class='glyphicon glyphicon-print'></span>
              &nbsp; PDF / Print
            </a>
            
          </div>
          <!-- END PRESENTATION CONTENT -->
          
          <!-- MATERIALS FROM CLASS: -->
          
          <!-- TODO: Constraint satisfaction problems -->
          <!-- TODO: Propositional Logic -->
          <!-- TODO: First-order Logic -->
            
        </div>
      </div>
      <!-- END MAIN CONTENT -->
      
      
    </div>
    <!-- END WRAPPER -->
    
    <!-- BEGIN FOOTER -->
    <div id="footer">
      <div class="container">
        <div class="col-md-12 text-center">
          
        </div>
      </div>
    </div>
    <!-- END FOOTER -->
    
  </body>
</html>
